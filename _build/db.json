{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/images/div.jpg","path":"images/div.jpg","modified":0,"renderable":0},{"_id":"source/images/innodb-trx-2.png","path":"images/innodb-trx-2.png","modified":0,"renderable":0},{"_id":"source/images/space-page-12.png","path":"images/space-page-12.png","modified":0,"renderable":0},{"_id":"source/images/space-page-1.png","path":"images/space-page-1.png","modified":0,"renderable":0},{"_id":"source/images/space-page-13.png","path":"images/space-page-13.png","modified":0,"renderable":0},{"_id":"source/images/space-page-11.png","path":"images/space-page-11.png","modified":0,"renderable":0},{"_id":"source/images/space-page-10.png","path":"images/space-page-10.png","modified":0,"renderable":0},{"_id":"source/images/space-page-14.png","path":"images/space-page-14.png","modified":0,"renderable":0},{"_id":"source/images/space-page-16.png","path":"images/space-page-16.png","modified":0,"renderable":0},{"_id":"source/images/space-page-15.png","path":"images/space-page-15.png","modified":0,"renderable":0},{"_id":"source/images/space-page-17.png","path":"images/space-page-17.png","modified":0,"renderable":0},{"_id":"source/images/space-page-18.png","path":"images/space-page-18.png","modified":0,"renderable":0},{"_id":"source/images/space-page-2.png","path":"images/space-page-2.png","modified":0,"renderable":0},{"_id":"source/images/space-page-3.png","path":"images/space-page-3.png","modified":0,"renderable":0},{"_id":"source/images/space-page-6.png","path":"images/space-page-6.png","modified":0,"renderable":0},{"_id":"source/images/space-page-5.png","path":"images/space-page-5.png","modified":0,"renderable":0},{"_id":"source/images/space-page-8.png","path":"images/space-page-8.png","modified":0,"renderable":0},{"_id":"source/images/space-page-9.png","path":"images/space-page-9.png","modified":0,"renderable":0},{"_id":"source/images/space-page-7.png","path":"images/space-page-7.png","modified":0,"renderable":0},{"_id":"source/images/innodb-intro-1.png","path":"images/innodb-intro-1.png","modified":0,"renderable":0},{"_id":"source/images/space-page-19.png","path":"images/space-page-19.png","modified":0,"renderable":0},{"_id":"source/images/space-page-20.png","path":"images/space-page-20.png","modified":0,"renderable":0},{"_id":"source/images/space-page-4.png","path":"images/space-page-4.png","modified":0,"renderable":0},{"_id":"source/images/sql-execute-1.jpg","path":"images/sql-execute-1.jpg","modified":0,"renderable":0},{"_id":"source/images/server-trx-2.png","path":"images/server-trx-2.png","modified":0,"renderable":0},{"_id":"source/images/server-trx-4.png","path":"images/server-trx-4.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"source/images/innodb-trx-3.png","path":"images/innodb-trx-3.png","modified":0,"renderable":0},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"source/images/online-ddl-3.jpg","path":"images/online-ddl-3.jpg","modified":0,"renderable":0},{"_id":"source/images/innodb-undo-log-2.png","path":"images/innodb-undo-log-2.png","modified":0,"renderable":0},{"_id":"source/images/server-trx-3.png","path":"images/server-trx-3.png","modified":0,"renderable":0},{"_id":"source/images/server-trx-1.png","path":"images/server-trx-1.png","modified":0,"renderable":0},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/README.md","path":"lib/fancybox/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/LICENSE","path":"lib/fancybox/LICENSE","modified":0,"renderable":1},{"_id":"source/images/innodb-trx-1.png","path":"images/innodb-trx-1.png","modified":0,"renderable":0},{"_id":"source/images/innodb-trx-4.png","path":"images/innodb-trx-4.png","modified":0,"renderable":0},{"_id":"source/images/online-ddl-1.jpg","path":"images/online-ddl-1.jpg","modified":0,"renderable":0},{"_id":"source/images/table-object-1.png","path":"images/table-object-1.png","modified":0,"renderable":0},{"_id":"source/images/innodb-undo-log-3.png","path":"images/innodb-undo-log-3.png","modified":0,"renderable":0},{"_id":"source/images/innodb-undo-log-4.png","path":"images/innodb-undo-log-4.png","modified":0,"renderable":0},{"_id":"source/images/innodb-undo-log-5.png","path":"images/innodb-undo-log-5.png","modified":0,"renderable":0},{"_id":"source/images/online-ddl-2.jpg","path":"images/online-ddl-2.jpg","modified":0,"renderable":0},{"_id":"source/images/innodb-undo-log-1.png","path":"images/innodb-undo-log-1.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.css","path":"lib/fancybox/source/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"source/images/buffer-pool-1.png","path":"images/buffer-pool-1.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.js","path":"lib/fancybox/source/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"source/images/connection-handler-1.jpg","path":"images/connection-handler-1.jpg","modified":0,"renderable":0},{"_id":"source/images/innodb-lock-1.png","path":"images/innodb-lock-1.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"207652cd7fa5092befe8758fdef42cf111aedf41","modified":1607175868570},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1593857338947},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1593857338946},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1593857338947},{"_id":"themes/next/.DS_Store","hash":"d04c5d24df97bf434afba5ea1c9236401e6384be","modified":1605771952558},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1593857338952},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1593857338952},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1593857338952},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1593857338952},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1593857338952},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1593857338989},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1593857338953},{"_id":"themes/next/_config.yml","hash":"920398a2c3b44bb7266fdda769abdd057437362f","modified":1605711706299},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1593857338960},{"_id":"source/archives/index.md","hash":"f275280243804c848b2c8c79a72e35e486be36e8","modified":1593838240368},{"_id":"source/categories/index.md","hash":"4cd6c17983a961a9efde496b64ac548c6fffa17f","modified":1593861512927},{"_id":"source/_posts/.DS_Store","hash":"da55b915ba55ede3ee10b0a724ed5215aba57ee3","modified":1607175909085},{"_id":"source/_posts/menu.md","hash":"c984caa6a155565ff723dba61b4fc8845b62bf87","modified":1607169800489},{"_id":"source/images/div.jpg","hash":"a6d5a557239bd6be506e2c9b655bef51bc80df19","modified":1605713203498},{"_id":"source/images/innodb-trx-2.png","hash":"bb6766df1d72c0991cd675e8e993b205192f76c4","modified":1607175150821},{"_id":"source/images/space-page-12.png","hash":"4c4af3ce9fec7a7b284661cf568786e9575d1376","modified":1607172676331},{"_id":"source/images/space-page-1.png","hash":"6b09cbb30fc86754dac34aa3251354443b35da97","modified":1607172513270},{"_id":"source/images/space-page-13.png","hash":"35e969609d6a823d788628ddaabef121e915f019","modified":1607172689170},{"_id":"source/images/space-page-11.png","hash":"c5827e0f360cca5b4c1b8fc5a18efe45b910891a","modified":1607172663261},{"_id":"source/images/space-page-10.png","hash":"3090de07b8f9f82d61ce67ebd10dc7b0dffdb784","modified":1607172651384},{"_id":"source/images/space-page-14.png","hash":"c0b56faa647e021a1dc8501821e854ce8d2a06c0","modified":1607172703711},{"_id":"source/images/space-page-16.png","hash":"c3fcbf242da34f59bd70afa0c56b780a2b9a5bbb","modified":1607172727709},{"_id":"source/images/space-page-15.png","hash":"ea7d7131aed7a224d53c35e8cd7ce85dbec06a54","modified":1607172715985},{"_id":"source/images/space-page-17.png","hash":"efc2d244948ccf5700b193fdbefdca3260f6f2bd","modified":1607172739674},{"_id":"source/images/space-page-18.png","hash":"8514b490e7e7b6147a4a33976164c2cd6ef28355","modified":1607172758929},{"_id":"source/images/space-page-2.png","hash":"47685c1c6c5e9300b775320648c32a705f244f5b","modified":1607172528168},{"_id":"source/images/space-page-3.png","hash":"3c31b57cad18f5918efba7f23fce8729da86c32d","modified":1607172540601},{"_id":"source/images/space-page-6.png","hash":"c12e6e69a55ff4d01b559432edb56ecdb6b13fd1","modified":1607172603996},{"_id":"source/images/space-page-5.png","hash":"21fdef24cfdff1a5c43ec94a56e770e819319ee2","modified":1607172592526},{"_id":"source/tags/index.md","hash":"5fb0f145c4628f09f7c2406ac106794ec3e8e9f7","modified":1593861555878},{"_id":"source/images/space-page-8.png","hash":"77d609f4b2a3215658d24d648a562bee3fbb8a88","modified":1607172626740},{"_id":"source/images/space-page-9.png","hash":"853fed63609a9786431da042552c14eab2307245","modified":1607172639124},{"_id":"themes/next/.git_bak/config","hash":"e78135eac1ede2f3ca79747839db482790e54b3c","modified":1593857338936},{"_id":"themes/next/.git_bak/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1593857338933},{"_id":"source/images/space-page-7.png","hash":"bbdf70568ccd7172e05308ce0616a0b6c997cc24","modified":1607172615321},{"_id":"themes/next/.git_bak/index","hash":"67865cd6cf6a72bc10f46fa850cd4d45502859d5","modified":1593862256184},{"_id":"themes/next/.git_bak/packed-refs","hash":"106c07d5e79883e01ae524173c32e1ab7ee0d172","modified":1593857338930},{"_id":"themes/next/.git_bak/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1593856664496},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1593857338948},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1593857338947},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1593857338949},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1593857338950},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1593857338950},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1593857338950},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1593857338951},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1593857338951},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1593857338951},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1593857338951},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1593857338950},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1593857338953},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1593857338954},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1593857338954},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1593857338954},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1593857338954},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1593857338955},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1593857338955},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1593857338955},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1593857338955},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1593857338994},{"_id":"themes/next/source/.DS_Store","hash":"45277e4b2271dce055e421d24755387966a2e3bc","modified":1605771952574},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1593857338960},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1593857338960},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1593857338960},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1593857338960},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1593857338961},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1593857338961},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1593857338961},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1593857338961},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1593857338962},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1593857338961},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1593857338962},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1593857338962},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1593857338962},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1593857338963},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1593857338963},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1593857338963},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1593857338963},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1593857338963},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1593857338964},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1593857338964},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1593857338964},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1593857338965},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1593857338964},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1593857338987},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1593857338987},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1593857338988},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1593857338988},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1593857338988},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1593857338988},{"_id":"source/images/innodb-intro-1.png","hash":"fdbf2c8bff19fdc7ab07f5abdb3b8aec0ca995b8","modified":1594985026506},{"_id":"source/images/space-page-19.png","hash":"b6f7aee7dad7b635161221c5c4e84cf65174f2f4","modified":1607172769795},{"_id":"source/images/space-page-20.png","hash":"d7b5f9e39c5d5f47adb930fc60d40939da736475","modified":1607172783474},{"_id":"source/images/space-page-4.png","hash":"faaf616e502c607a37b4045cb7c9020c0750bdba","modified":1607172578975},{"_id":"source/images/sql-execute-1.jpg","hash":"de7bb4171af4fac85259ef6a229c6c8fd4cd245c","modified":1594560155351},{"_id":"source/_posts/database/transaction-intro.md","hash":"f960d3150c96d09c8b35f10bb0b4f7e488fb94c9","modified":1607169795199},{"_id":"source/_posts/clang/new-malloc.md","hash":"b1df260e24777fc61f3d02c38e813dab29be595f","modified":1607169774571},{"_id":"source/_posts/clang/lf_hash.md","hash":"aa6daca14a7ac5551286e555b216a49679634424","modified":1607169768969},{"_id":"source/_posts/clang/cplusplus-lock.md","hash":"496ca07cda35cbef91ff6d028c4e8f5013dd1461","modified":1607169766338},{"_id":"source/_posts/innodb/innodb-buffer-page.md","hash":"28ba88732e9ae55c66611e6ba4891cfd2bbbdc96","modified":1607173860121},{"_id":"source/_posts/innodb/inndo-undo-log.md","hash":"f4749f50953dd5c7d14d843ba84a20f4899414be","modified":1607174869594},{"_id":"source/_posts/innodb/innodb-sql-execute.md","hash":"a772c38ffdc0f1e33816c8de706d76e776b50b18","modified":1607174255900},{"_id":"source/_posts/innodb/innodb-intro.md","hash":"9de6eeae0e8b287008497b168fe4bb23ba733acc","modified":1607174265617},{"_id":"source/_posts/innodb/innodb-lock.md","hash":"71a7eff3347cb2627e51a0c778c9783bd50d5047","modified":1607176341388},{"_id":"source/_posts/innodb/space-page.md","hash":"cb54bd4f2e60f2b1672a2e74dcf46da7c3ab014a","modified":1607176320514},{"_id":"source/_posts/linux/cgroup-linux.md","hash":"d3aed05875d76edd6d73506b9756511dc7c72e3d","modified":1607169778666},{"_id":"source/_posts/linux/tcpdump-linux.md","hash":"54f00aa9418455adbde44e3554f258416b3ed0b0","modified":1607169781649},{"_id":"source/_posts/innodb/innodb-transaction-commit.md","hash":"fbeccf3b35d5e7f5e49d954fa41d0e198d350ee8","modified":1607175848854},{"_id":"source/_posts/linux/perf-linux.md","hash":"bf4599f660c26b6527367fb81c33bd82a5f4850c","modified":1607169784362},{"_id":"source/_posts/mysql/parser.md","hash":"1d68c47c9a4ad1865f6ac3ed3b018d3186589ccc","modified":1607176363091},{"_id":"source/_posts/mysql/connection-handler.md","hash":"8c01ead666740226d05e15a6d287f993fe328700","modified":1607169748618},{"_id":"source/_posts/mysql/sql-execute.md","hash":"d4ce06453f3d187bca537e45d8c697163b3b3c52","modified":1607169754586},{"_id":"source/_posts/mysql/online-ddl.md","hash":"42fbb3b3c5c8bbf2997c0340ab0d422f8872f469","modified":1607169744722},{"_id":"source/_posts/mysql/atomic-ddl.md","hash":"bf0b71022d7c1e7d382905e75a413a6dcb650009","modified":1607169916179},{"_id":"source/_posts/mysql/x-plugin.md","hash":"36fc56d0611dc2e4ce80240a17f95ee1b9cae291","modified":1607169751849},{"_id":"source/_posts/others/io-performance.md","hash":"71e7a267cfc8df906aa25e90b9b5515b5cd2c073","modified":1607169788177},{"_id":"source/_posts/mysql/transaction-commit.md","hash":"25f3af4744dd29016ce4e5d1edc59f86ee04bae3","modified":1607169735109},{"_id":"source/_posts/mysql/table-object.md","hash":"5bb62f5b7f2c414a9aea8ea0ee882ae1ff3ea997","modified":1607172302274},{"_id":"source/images/server-trx-2.png","hash":"5be00c7eb39b93a93a680d65043e011336b92390","modified":1607169208269},{"_id":"source/images/server-trx-4.png","hash":"2576ee207a3b7df498b31e40ea85bb7524b9ce94","modified":1607169248998},{"_id":"themes/next/.git_bak/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1593856664496},{"_id":"themes/next/.git_bak/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1593856664499},{"_id":"themes/next/.git_bak/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1593856664497},{"_id":"themes/next/.git_bak/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1593856664502},{"_id":"themes/next/.git_bak/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1593856664501},{"_id":"themes/next/.git_bak/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1593856664503},{"_id":"themes/next/.git_bak/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1593856664498},{"_id":"themes/next/.git_bak/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1593856664500},{"_id":"themes/next/.git_bak/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1593856664498},{"_id":"themes/next/.git_bak/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1593856664503},{"_id":"themes/next/.git_bak/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1593856664500},{"_id":"themes/next/.git_bak/logs/HEAD","hash":"c6061cb06758c3c5ad7af34c0db7588ca51dcdf7","modified":1593857338935},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1593857338948},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1593857338948},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1593857338949},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1593857338949},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1593857338956},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1593857338956},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1593857338956},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1593857338956},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1593857338957},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1593857338957},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1593857338957},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1593857338958},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1593857338958},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1593857338958},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1593857338959},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1593857338959},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1593857338989},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1593857338959},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1593857338992},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1593857338992},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1593857338993},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1593857338993},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1593857338993},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1593857338993},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1593857338994},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1593857338994},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1593857338994},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1593857338994},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1593857338995},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1593857338995},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1593857338995},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1593857338995},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1593857338996},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1593857338996},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1593857338996},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1593857338996},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1593857338996},{"_id":"themes/next/source/css/.DS_Store","hash":"20c91a5d6779af38b041841890548482c3cfdde7","modified":1605771952555},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1593857338997},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1593857339029},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1593857339033},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1593857339034},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1593857339034},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1593857339034},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1593857339034},{"_id":"themes/next/source/js/utils.js","hash":"72762affb97440177666059dc3392541a5419e4b","modified":1605767949018},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1593857339036},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1593857339023},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1593857339030},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1593857339030},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1593857339030},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1593857339031},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1593857339031},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1593857339031},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1593857339032},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1593857339032},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1593857339032},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1593857339033},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1593857339033},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1593857339033},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1593857339033},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1593857338965},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1593857338965},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1593857338965},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1593857338966},{"_id":"themes/next/layout/_partials/footer.swig","hash":"e5a2bdf45fde7cea9cb03993f5a0fd960326ed5d","modified":1593862255682},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1593857338968},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1593857338969},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1593857338976},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1593857338981},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1593857338983},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1593857338984},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1593857338984},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1593857338977},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1593857338976},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1593857338977},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1593857338979},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1593857338979},{"_id":"source/images/innodb-trx-3.png","hash":"b3c6f18dcc87e756931cba6873cb0013fae88549","modified":1607175164756},{"_id":"themes/next/source/images/avatar.jpg","hash":"e7980d215c86bd4ac681991ae0d6ac2f526d3824","modified":1593859327541},{"_id":"source/images/online-ddl-3.jpg","hash":"8fb4cc60f3ce2cb9dfbc05993121e12bd1a3dfff","modified":1605708774575},{"_id":"source/images/innodb-undo-log-2.png","hash":"cb9c89c09610c48e7ca25701d51099c45f0de75a","modified":1607174381781},{"_id":"source/images/server-trx-3.png","hash":"b17f7d35677aedb0290f122cd945624644cc3e40","modified":1607169230846},{"_id":"source/images/server-trx-1.png","hash":"68dfceb88ddc4ba5d3e2b35db7e7c1a785045c42","modified":1607169187540},{"_id":"themes/next/.git_bak/refs/heads/master","hash":"7b5894d5fc28d7797285dac4f43134462f6c7c5d","modified":1593857338934},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1593857338989},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1593857338989},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1593857338990},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1593857338990},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1593857338990},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1593857338991},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1593857338991},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1593857338991},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1593857338991},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1593857338992},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1593857338992},{"_id":"themes/next/source/css/_common/.DS_Store","hash":"0823e351e6e97d83be981c2791cb3b2597374009","modified":1605771952573},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1593857339028},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1593857339028},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1593857339028},{"_id":"themes/next/source/css/_variables/base.styl","hash":"3ff1998af930bbddb029ef288ecfb76466a01211","modified":1593859539203},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1593857339029},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1593857339035},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1593857339035},{"_id":"themes/next/source/css/_schemes/.DS_Store","hash":"8670556f347907d4e2a0f1cb135159508c073faf","modified":1605771952555},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1593857339039},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1593857339039},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1595148214246},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"d8bf9cb15d9d91c7ad022ba2954b5b4d326f17f7","modified":1595148214246},{"_id":"themes/next/source/lib/fancybox/README.md","hash":"8286582ed7c338fce8bb03566b769fba378bce83","modified":1595148214247},{"_id":"themes/next/source/lib/fancybox/LICENSE","hash":"8624bcdae55baeef00cd11d5dfcfa60f68710a02","modified":1595148214247},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1593857338966},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1593857338966},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1593857338968},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1593857338969},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1593857338966},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1593857338967},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1593857338967},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1593857338967},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1593857338968},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1593857338974},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1593857338974},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1593857338975},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1593857338974},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1593857338975},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1593857338975},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1593857338975},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1593857338976},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1593857338976},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1593857338980},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1593857338980},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1593857338980},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1593857338981},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1593857338981},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1593857338982},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1593857338980},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1593857338982},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1593857338982},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1593857338982},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1593857338982},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1593857338983},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1593857338983},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1593857338984},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1593857338983},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1593857338984},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1593857338985},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1593857338985},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1593857338985},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1593857338986},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1593857338986},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1593857338986},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1593857338986},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1593857338987},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1593857338987},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1593857338978},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1593857338978},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1593857338977},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1593857338978},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1593857338979},{"_id":"source/images/innodb-trx-1.png","hash":"0242d50878064b69a50f0e477fb7c0706c204d53","modified":1607175130030},{"_id":"source/images/innodb-trx-4.png","hash":"0b75cd2cce3164bb12e28ed8e5a01823948e759c","modified":1607175179690},{"_id":"source/images/online-ddl-1.jpg","hash":"646c0ca3e1bf0d868c285e9762ba66e0ef7318c8","modified":1605708669190},{"_id":"source/images/table-object-1.png","hash":"409d195f9514f978a33aed6e6253b03ac11976d2","modified":1607170228545},{"_id":"source/images/innodb-undo-log-3.png","hash":"645c181d542555c3fb0ea06ed0f6046af2375fc4","modified":1607174394908},{"_id":"source/images/innodb-undo-log-4.png","hash":"d523d41853bf141c32b9b9ad481e6338f6dbe387","modified":1607174407328},{"_id":"source/images/innodb-undo-log-5.png","hash":"318c86d1dccfa939db140627f8e67a39465e7354","modified":1607174419352},{"_id":"source/images/online-ddl-2.jpg","hash":"5cd9c05161e419e5d4b8f17ab4f1d1b0bd7e348e","modified":1605708734199},{"_id":"source/images/innodb-undo-log-1.png","hash":"a678ff6e4c0b7a3fbeee530a77b3efe7dbbcf2f2","modified":1607174368992},{"_id":"themes/next/.git_bak/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1593857338932},{"_id":"themes/next/.git_bak/logs/refs/heads/master","hash":"c6061cb06758c3c5ad7af34c0db7588ca51dcdf7","modified":1593857338935},{"_id":"themes/next/source/css/_common/components/.DS_Store","hash":"6c2b21bdf55da079ea8cc0971c134a21741652a5","modified":1605771952553},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1593857338998},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1593857338998},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1593857338999},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1593857339008},{"_id":"themes/next/source/css/_common/scaffolding/.DS_Store","hash":"91b906c868be043ed71d1b12a177eed97cf19754","modified":1605771952572},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1593857339018},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1593857339018},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1593857339018},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1593857339020},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1593857339020},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1593857339021},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1593857339023},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1593857339021},{"_id":"themes/next/source/css/_common/outline/.DS_Store","hash":"1dc9738ff92f4f0ded8c28c84cd1eb1873b8df96","modified":1605771952552},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1593857339014},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1593857339015},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1593857339038},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1593857339024},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1593857339036},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1593857339024},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1593857339025},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1593857339025},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1593857339027},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1593857339025},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1593857339027},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1593857339027},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1593857339027},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1593857339027},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1593857339028},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1593857339025},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1593857339025},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1593857339026},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1593857339026},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1593857339026},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1593857339024},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1593857339026},{"_id":"themes/next/source/lib/fancybox/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1595148214235},{"_id":"themes/next/source/lib/fancybox/.git/config","hash":"0bd9061daa1ae14bc8c15ccb2616123858620669","modified":1595148214239},{"_id":"themes/next/source/css/_schemes/Gemini/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1605713207020},{"_id":"themes/next/source/lib/fancybox/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1595148191607},{"_id":"themes/next/source/lib/fancybox/.git/index","hash":"3d8a64930957b173af9d9655a3219b5b70e32ee1","modified":1595148214251},{"_id":"themes/next/source/lib/fancybox/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1595148214246},{"_id":"themes/next/source/lib/fancybox/.git/packed-refs","hash":"f0b53e687e79fcab7e1836dec921908302da45b9","modified":1595148214231},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"e43435fb9eaa918f5b8e35c9e110124b8bd13751","modified":1595148214248},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1595148214248},{"_id":"source/images/buffer-pool-1.png","hash":"7fb804637d681ef535f6f33769a95b9d8d40b801","modified":1607173793694},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1593857339037},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1593857339038},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1595148214249},{"_id":"themes/next/.git_bak/logs/refs/remotes/origin/HEAD","hash":"c6061cb06758c3c5ad7af34c0db7588ca51dcdf7","modified":1593857338932},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1593857338999},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1593857339000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1593857339001},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1593857339000},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1593857339001},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1593857339002},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1593857339003},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1593857339003},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1593857339004},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1593857339004},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1593857339005},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1593857339006},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1593857339005},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1593857339007},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1593857339007},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1593857339005},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1593857339007},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1593857339008},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1593857339009},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1593857339009},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1593857339010},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1593857339010},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1593857339011},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1593857339019},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1593857339019},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1593857339019},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1593857339020},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1593857339021},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1593857339022},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1593857339022},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1593857339022},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1593857339022},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1593857339023},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1593857339023},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1593857339012},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1593857339012},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1593857339013},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1593857339013},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1593857339013},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1593857339014},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1593857339013},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1593857339014},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1593857339015},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1593857339015},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1593857339016},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1593857339016},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1593857339016},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1593857339017},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1593857339016},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1593857339017},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1593857339017},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1593857339018},{"_id":"themes/next/source/lib/fancybox/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1595148191611},{"_id":"themes/next/source/lib/fancybox/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1595148191608},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1595148191614},{"_id":"themes/next/source/lib/fancybox/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1595148191613},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1595148191615},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1595148191611},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1595148191609},{"_id":"themes/next/source/lib/fancybox/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1595148191613},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1595148191612},{"_id":"themes/next/source/lib/fancybox/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1595148191616},{"_id":"themes/next/source/lib/fancybox/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1595148191606},{"_id":"themes/next/source/lib/fancybox/.git/logs/HEAD","hash":"a14eee48208ac3a9a5b2ae7f225966a916809aea","modified":1595148214237},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"27f034e5db8c32e268e2959b9a7c1258d36e4510","modified":1595148214250},{"_id":"themes/next/.git_bak/objects/pack/pack-86e2565862baf23d3242d9762d7e9890da3bd718.idx","hash":"c2f6240fb7b9c8e09988b3960493fdad157ad6e9","modified":1593857338911},{"_id":"themes/next/source/lib/fancybox/.git/objects/00/c03f6be011e8878608eec12f68caf42b73f38e","hash":"8516bd35bc8f9223e13de5877778c8d14d49d6db","modified":1595148214217},{"_id":"themes/next/source/lib/fancybox/.git/objects/16/b01254a56610f4c6b7721c534ed4fc40ae51dd","hash":"88ca5fd99322d3a4067e0711af79f41c078f2ef5","modified":1595148198440},{"_id":"themes/next/source/lib/fancybox/.git/objects/19/3567a3107003507fafacd255c349857e417926","hash":"ef5eab75e8c6998cb223edb4eb8a26c4cfc9415c","modified":1595148212932},{"_id":"themes/next/source/lib/fancybox/.git/objects/0c/dada082d621dbfdd00f7020c33dc751129167f","hash":"b490c11cdefde6b331a7d4ddb055e34ad08459d8","modified":1595148197084},{"_id":"themes/next/source/lib/fancybox/.git/objects/2f/9eba51ec174b1e0c719d12cafa7c3c07140471","hash":"fc994d9d8b3b21ec7c941eea7e3862970e297e9b","modified":1595148197086},{"_id":"themes/next/source/lib/fancybox/.git/objects/40/9607f1ba381a64c3ccb8d5440299e8ef868ef8","hash":"a462f7a9efebb70c4051f92c09ccbd9885132c77","modified":1595148197075},{"_id":"themes/next/source/lib/fancybox/.git/objects/3d/521bfc64755e348870094e85323dc1b9c96a6b","hash":"e9660fc4f89ecb176b0ab6e4860579c1bfe9f9cb","modified":1595148205957},{"_id":"themes/next/source/lib/fancybox/.git/objects/36/9bab09306448a2970d378b59bb21c059edad63","hash":"877e0c15623d0d6ff8f09bb627fc60a489f3c105","modified":1595148198023},{"_id":"themes/next/source/lib/fancybox/.git/objects/47/d427b6c52396bbab53a05f57aaa82b52c805b1","hash":"c5626bbb62f4d1d1e39034e7f44baf4c509410d6","modified":1595148205959},{"_id":"themes/next/source/lib/fancybox/.git/objects/51/cf05811ed7d35e92551db1ba5a6e267ce781a5","hash":"99c009035ea86e3876b586577677d4d62ae12379","modified":1595148205957},{"_id":"themes/next/source/lib/fancybox/.git/objects/1f/a2c5f332b7e304431213aec21012e53f8781d7","hash":"7632806182aa989d3b7029579d5c03c34b113ee3","modified":1595148197078},{"_id":"themes/next/source/lib/fancybox/.git/objects/53/ceaabe0f8677333c5be196778b3e40840a1869","hash":"7bc1c1c42059d5402335b5293bfb5e54bee22557","modified":1595148197081},{"_id":"themes/next/source/lib/fancybox/.git/objects/63/c555caede30ab06d6dba16644a827e9574c8cb","hash":"846603220288272ad5d35ebdc3c917cc4adce424","modified":1595148197076},{"_id":"themes/next/source/lib/fancybox/.git/objects/64/c47e893a0fef71c8c0930975ef114d9812da56","hash":"eaad75fab15724f9c2b069fc1ce9b8216be149d7","modified":1595148198025},{"_id":"themes/next/source/lib/fancybox/.git/objects/78/068b93f813cecbbd50c8247de547035009d512","hash":"4bc2bee779bd7e3cca13ee34801cf1e12585e5ae","modified":1595148205958},{"_id":"themes/next/source/lib/fancybox/.git/objects/54/0a7b36ee26decfc3f0f34bf73bc85c48899128","hash":"2e5447a9dd879d71368e9dddd34d93849d00b934","modified":1595148214219},{"_id":"themes/next/source/lib/fancybox/.git/objects/7b/15d3cb03fda86241f8b2b335f04e9b9de0e1c4","hash":"d1fe3bd82c90f7d93874798a8ee8ebf1391d7207","modified":1595148209637},{"_id":"themes/next/source/lib/fancybox/.git/objects/7c/c60b295fa2dcb82537a63792c9b3b3c2e74c33","hash":"b2dc23c71b13726c391aaefaa5312227a9b6ab7e","modified":1595148198441},{"_id":"themes/next/source/lib/fancybox/.git/objects/7c/00ef8195b73793d477d22e723ecdac9553ebf3","hash":"fd8c4fd143b32fb3e86367f123feb7c35b305262","modified":1595148205949},{"_id":"themes/next/source/lib/fancybox/.git/objects/89/9d7a75b543fbed2a785f67d995bc77e06eb2e9","hash":"5651e2b80703225f642625c0fb2646543096d2cf","modified":1595148197079},{"_id":"themes/next/source/lib/fancybox/.git/objects/80/6b27034bd69d563e4243c2f12b43c7064b32dd","hash":"b7d3e8020767ae60a2029da8eccb0068623dc618","modified":1595148205955},{"_id":"themes/next/source/lib/fancybox/.git/objects/92/4369c371444afb18fb86309229f5b4c24c6cf4","hash":"9eb6fa8ff9081e6650f6bee350d21567df105737","modified":1595148212930},{"_id":"themes/next/source/lib/fancybox/.git/objects/94/a9ed024d3859793618152ea559a168bbcbb5e2","hash":"1c2d080a86f03eb960e112a94910a5115addf57a","modified":1595148198022},{"_id":"themes/next/source/lib/fancybox/.git/objects/9b/fe9361836240600c1bcc3cab9d42b35e731fad","hash":"3d38ffc7ac1ae85224691ef15d7f32e40c40b3a2","modified":1595148198438},{"_id":"themes/next/source/lib/fancybox/.git/objects/aa/654e17af8c354994f706c4e33bba6b5b70caeb","hash":"22b1bdf0b0974bf5e9022953ac26066056c235ff","modified":1595148214215},{"_id":"themes/next/source/lib/fancybox/.git/objects/b3/b3098638624b56be968573e2dab1684f8a7f06","hash":"6fa11a2d904dff2b8f4ae1bd88bdbb66736438a1","modified":1595148201346},{"_id":"themes/next/source/lib/fancybox/.git/objects/ad/569256343419017e8832a38faaa1c786716a1d","hash":"0538e4abd112b0a843035f28a511edabbe73f2ce","modified":1595148197077},{"_id":"themes/next/source/lib/fancybox/.git/objects/b6/c361c8dcf2f5a7572e81b956272e4cfe1198c1","hash":"3e160c605dbd94dcef2b9692a4a5a82bddb76264","modified":1595148198024},{"_id":"themes/next/source/lib/fancybox/.git/objects/bd/e1f741357b44b49290d43fdd193125202fef81","hash":"9beefc75cc0c37d04e98dd13b51ad85df40e77b9","modified":1595148197083},{"_id":"themes/next/source/lib/fancybox/.git/objects/ce/c0e316bee5d497ee834dbd29e0c5aad8331052","hash":"3d769fa5f55014841d10bb3bdf1b9725c43e9043","modified":1595148197082},{"_id":"themes/next/source/lib/fancybox/.git/objects/c2/fc5def1b6c38369e5e8b849adb956bd79b549e","hash":"27f03b9616e615b2724bac0fa4507d152697f3f1","modified":1595148197080},{"_id":"themes/next/source/lib/fancybox/.git/objects/d5/d10f6be62acc10fec6e11e8dc4affe1184a17b","hash":"cec51b2539349d2aba1ec5d11eaded3815eccdc5","modified":1595148201348},{"_id":"source/images/connection-handler-1.jpg","hash":"92bcdd71f0a568d4403763cd742094e0ef6736bf","modified":1595169913336},{"_id":"themes/next/source/lib/fancybox/.git/objects/f6/bb280a0b2c68256a8e906b35c6976c80c1b3be","hash":"5daaee11fc384fbe0f02c7123036c954ee9a73fd","modified":1595148197084},{"_id":"themes/next/source/lib/fancybox/.git/objects/ac/97c2cc9f61c52753abe4174a4a74b2064e5af0","hash":"272e74036b0612de83d9d0aa9604d3edf888b249","modified":1595148209636},{"_id":"themes/next/source/lib/fancybox/.git/refs/heads/master","hash":"0b56bdb897316a3b4ec6c120673249f65f4cb420","modified":1595148214237},{"_id":"source/images/innodb-lock-1.png","hash":"38355601cc376fb39be6a4ecd63f102ffe5469e5","modified":1607173947363},{"_id":"themes/next/source/lib/fancybox/.git/logs/refs/heads/master","hash":"a14eee48208ac3a9a5b2ae7f225966a916809aea","modified":1595148214238},{"_id":"themes/next/source/lib/fancybox/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1595148214234},{"_id":"themes/next/source/lib/fancybox/.git/logs/refs/remotes/origin/HEAD","hash":"a14eee48208ac3a9a5b2ae7f225966a916809aea","modified":1595148214234},{"_id":"themes/next/.git_bak/objects/pack/pack-86e2565862baf23d3242d9762d7e9890da3bd718.pack","hash":"ce1356563957c2df9e5122a60ede12756fab94ce","modified":1593857338903},{"_id":"public/archives/index.html","hash":"e0b694442d8040d3b35ab13413b9808cedc00f08","modified":1620717797887},{"_id":"public/categories/index.html","hash":"42fc294255e82769b2416549ecb07c8eb00bb4bc","modified":1620717797887},{"_id":"public/tags/index.html","hash":"851e864eea8670c4ddcaf25bd7dec0e2f82e2ff9","modified":1620717797887},{"_id":"public/2020/09/13/others/io-performance/index.html","hash":"24dca77de457173fa21f3d51c7f431b6a3deb22f","modified":1620717797887},{"_id":"public/2020/07/18/innodb/innodb-intro/index.html","hash":"09b6e4a10be1b5761dae0999403d55529463df3c","modified":1620717797887},{"_id":"public/categories/C-C/index.html","hash":"7182edbf10f5ceffcd21693233461746a6610f22","modified":1620717797887},{"_id":"public/categories/数据库/index.html","hash":"72b881052b366bce242eb59a306830cc9716c9ee","modified":1620717797887},{"_id":"public/categories/InnoDB/index.html","hash":"07eef630d4c04d5da13fe753bef54c590151e212","modified":1620717797887},{"_id":"public/categories/Linux/index.html","hash":"36417461d21288a76c186cb35c2f859271d831d8","modified":1620717797887},{"_id":"public/categories/MySQL/index.html","hash":"e6df3c669af4364d6214154a616dd8bcd95f676c","modified":1620717797887},{"_id":"public/categories/其它/index.html","hash":"b26a2df0a5887e72e1f978302995f5d4789cbb6f","modified":1620717797887},{"_id":"public/tags/事务/index.html","hash":"b39c3098a9fc67edc0a032b06126ffcce2b1f347","modified":1620717797887},{"_id":"public/tags/锁/index.html","hash":"ce689b08af1811375206343fc69828d18f939cc8","modified":1620717797887},{"_id":"public/tags/LF-HASH/index.html","hash":"8946a54fe95fd06fdb44e536c0726a0ccf5a8f9e","modified":1620717797887},{"_id":"public/tags/Buffer-Pool/index.html","hash":"b807113c00abdb7edc824e94407029db81120759","modified":1620717797887},{"_id":"public/tags/架构/index.html","hash":"7259520ab510881000929deb8f9d29de7870c13c","modified":1620717797887},{"_id":"public/tags/网络/index.html","hash":"9ae2f9f6b1d513d17e660eea81883fc7779c3099","modified":1620717797887},{"_id":"public/tags/工具/index.html","hash":"d2ca35bdc64e575105759b3621dc321ffca7290d","modified":1620717797887},{"_id":"public/tags/Feature/index.html","hash":"c04b4faa43fa586959caeef204377c80716d3fd6","modified":1620717797887},{"_id":"public/archives/page/2/index.html","hash":"9d972cb3b7b9c8fe2e7c7e396c153dd9b050d77c","modified":1620717797887},{"_id":"public/archives/page/3/index.html","hash":"3b1bf2c9fab67fc5ca77fb743a8c6308ad27975a","modified":1620717797887},{"_id":"public/archives/2020/index.html","hash":"40da3d37a2fb3f9a4d2f8490f93ef4b4708f24a4","modified":1620717797887},{"_id":"public/archives/2020/page/2/index.html","hash":"ff6781992c1d5247a39c3cac1be1b153d0a6b7c3","modified":1620717797887},{"_id":"public/archives/2020/page/3/index.html","hash":"f6348058da9a2c809002120dc850b7b8d2afc833","modified":1620717797887},{"_id":"public/archives/2020/07/index.html","hash":"ac03ec10448d285de48489e85fdba05d26f6c5d7","modified":1620717797887},{"_id":"public/archives/2020/07/page/2/index.html","hash":"3e2d217b79156df08bb9451ab27be65a6fde67e9","modified":1620717797887},{"_id":"public/archives/2020/08/index.html","hash":"8cf7661d88608672cd9aee131100dad5636b56b1","modified":1620717797887},{"_id":"public/archives/2020/09/index.html","hash":"35d6f01e976bb0044ea30aabdd4bddd66fe2b38f","modified":1620717797887},{"_id":"public/archives/2020/11/index.html","hash":"b0ca2b5e1d054709e7b035495b84556b745c702d","modified":1620717797887},{"_id":"public/archives/2020/12/index.html","hash":"e4895f28747b44ee8552544dd4ae14185979aff4","modified":1620717797887},{"_id":"public/2020/12/05/innodb/innodb-transaction-commit/index.html","hash":"7e36e2bdd70c7622c17964587e9afa45a8ee943a","modified":1620717797887},{"_id":"public/2020/12/05/innodb/inndo-undo-log/index.html","hash":"800f423cb5ee5fe6b89eb53874d59e0be42110c0","modified":1620717797887},{"_id":"public/2020/12/05/innodb/innodb-lock/index.html","hash":"035c41e4e24917f7a3a4c8f1ac5d08562e45338c","modified":1620717797887},{"_id":"public/2020/12/05/innodb/innodb-sql-execute/index.html","hash":"3963c8c6885c753adfe61287325e5ff662bfb213","modified":1620717797887},{"_id":"public/2020/12/05/innodb/space-page/index.html","hash":"c52276d9c512bcd0cb1cc0e4ca899a6bb292a8d9","modified":1620717797887},{"_id":"public/2020/12/05/mysql/table-object/index.html","hash":"5f66d7bbc15fa30def9dee4976c148d723003229","modified":1620717797887},{"_id":"public/2020/12/05/mysql/atomic-ddl/index.html","hash":"da134bab501bdc03909b73b46fd640ea44865690","modified":1620717797887},{"_id":"public/2020/12/05/mysql/transaction-commit/index.html","hash":"6bbb2aeb35b711f894514a218b12b1e7fca85212","modified":1620717797887},{"_id":"public/2020/12/05/mysql/parser/index.html","hash":"ab388238125a3d941e0a8d9c6f510194cd025d7b","modified":1620717797887},{"_id":"public/2020/11/18/mysql/online-ddl/index.html","hash":"78ffa2f60bbb2cfa8d8ae4b4e06c2d406d9c35d2","modified":1620717797887},{"_id":"public/2020/11/08/clang/new-malloc/index.html","hash":"3ede73a378d803eca081c2872ada3869befc02f1","modified":1620717797887},{"_id":"public/2020/08/23/innodb/innodb-buffer-page/index.html","hash":"5c1f33c0142e42d36d2a1ce747c931db27a09ffa","modified":1620717797887},{"_id":"public/2020/07/18/linux/cgroup-linux/index.html","hash":"09fd88fbb8eb84ffcfd098e4066e5bc574707979","modified":1620717797887},{"_id":"public/2020/07/18/linux/tcpdump-linux/index.html","hash":"a2bedb4b49261538709dba96990f7a7f0c826f0b","modified":1620717797887},{"_id":"public/2020/07/18/linux/perf-linux/index.html","hash":"ab8d162f62a918e6fdc17b7706ce13ef936a9f8f","modified":1620717797887},{"_id":"public/2020/07/17/clang/lf_hash/index.html","hash":"c5ca97910a2a1d3a46e96f77cea1987b009b2cc4","modified":1620717797887},{"_id":"public/2020/07/17/clang/cplusplus-lock/index.html","hash":"57e09f943b3c1e7d1420e1ebd35d56d90306cd77","modified":1620717797887},{"_id":"public/2020/07/17/mysql/x-plugin/index.html","hash":"e1425bc20fdb24f88f2429f132b8c97cb4958dd1","modified":1620717797887},{"_id":"public/2020/07/15/mysql/connection-handler/index.html","hash":"c9edb0b075180c0f59814c1237e1eb360e266659","modified":1620717797887},{"_id":"public/2020/07/13/database/transaction-intro/index.html","hash":"c0f2d23eb7f879dabb276e8d762387f795dc1741","modified":1620717797887},{"_id":"public/2020/07/04/mysql/sql-execute/index.html","hash":"5b098d954bf6fe37f7853a3b06e9caae633ab88d","modified":1620717797887},{"_id":"public/2020/07/04/menu/index.html","hash":"784cb2d7cad77be2aaad99c9bf204101256669e8","modified":1620717797887},{"_id":"public/index.html","hash":"978bbfeeee283457aa9ad05863ebbd11d4728e73","modified":1620717797887},{"_id":"public/page/2/index.html","hash":"b2a305c8575a9417426034a914ef1f05f9ee5a46","modified":1620717797887},{"_id":"public/page/3/index.html","hash":"ade54c40ed7f176431c83ed20ed1ea21da5202f0","modified":1620717797887},{"_id":"public/images/space-page-12.png","hash":"4c4af3ce9fec7a7b284661cf568786e9575d1376","modified":1620717797887},{"_id":"public/images/innodb-trx-2.png","hash":"bb6766df1d72c0991cd675e8e993b205192f76c4","modified":1620717797887},{"_id":"public/images/space-page-1.png","hash":"6b09cbb30fc86754dac34aa3251354443b35da97","modified":1620717797887},{"_id":"public/images/div.jpg","hash":"a6d5a557239bd6be506e2c9b655bef51bc80df19","modified":1620717797887},{"_id":"public/images/space-page-10.png","hash":"3090de07b8f9f82d61ce67ebd10dc7b0dffdb784","modified":1620717797887},{"_id":"public/images/space-page-13.png","hash":"35e969609d6a823d788628ddaabef121e915f019","modified":1620717797887},{"_id":"public/images/space-page-17.png","hash":"efc2d244948ccf5700b193fdbefdca3260f6f2bd","modified":1620717797887},{"_id":"public/images/space-page-16.png","hash":"c3fcbf242da34f59bd70afa0c56b780a2b9a5bbb","modified":1620717797887},{"_id":"public/images/space-page-14.png","hash":"c0b56faa647e021a1dc8501821e854ce8d2a06c0","modified":1620717797887},{"_id":"public/images/space-page-11.png","hash":"c5827e0f360cca5b4c1b8fc5a18efe45b910891a","modified":1620717797887},{"_id":"public/images/space-page-18.png","hash":"8514b490e7e7b6147a4a33976164c2cd6ef28355","modified":1620717797887},{"_id":"public/images/space-page-15.png","hash":"ea7d7131aed7a224d53c35e8cd7ce85dbec06a54","modified":1620717797887},{"_id":"public/images/space-page-2.png","hash":"47685c1c6c5e9300b775320648c32a705f244f5b","modified":1620717797887},{"_id":"public/images/space-page-3.png","hash":"3c31b57cad18f5918efba7f23fce8729da86c32d","modified":1620717797887},{"_id":"public/images/space-page-6.png","hash":"c12e6e69a55ff4d01b559432edb56ecdb6b13fd1","modified":1620717797887},{"_id":"public/images/space-page-5.png","hash":"21fdef24cfdff1a5c43ec94a56e770e819319ee2","modified":1620717797887},{"_id":"public/images/space-page-8.png","hash":"77d609f4b2a3215658d24d648a562bee3fbb8a88","modified":1620717797887},{"_id":"public/images/space-page-7.png","hash":"bbdf70568ccd7172e05308ce0616a0b6c997cc24","modified":1620717797887},{"_id":"public/images/space-page-9.png","hash":"853fed63609a9786431da042552c14eab2307245","modified":1620717797887},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1620717797887},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1620717797887},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1620717797887},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1620717797887},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1620717797887},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1620717797887},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1620717797887},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1620717797887},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1620717797887},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1620717797887},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1620717797887},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1620717797887},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1620717797887},{"_id":"public/lib/fancybox/LICENSE","hash":"8624bcdae55baeef00cd11d5dfcfa60f68710a02","modified":1620717797887},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1620717797887},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1620717797887},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1620717797887},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1620717797887},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1620717797887},{"_id":"public/js/utils.js","hash":"72762affb97440177666059dc3392541a5419e4b","modified":1620717797887},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1620717797887},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1620717797887},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1620717797887},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1620717797887},{"_id":"public/lib/fancybox/source/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1620717797887},{"_id":"public/lib/fancybox/README.html","hash":"ef332d1b78e923c8ba02c84f37e966c0fd8bb6c5","modified":1620717797887},{"_id":"public/css/main.css","hash":"e893f29b0a615e0b65a35bfb8e04ec1f0dcf0ed3","modified":1620717797887},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1620717797887},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1620717797887},{"_id":"public/lib/fancybox/source/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1620717797887},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"e43435fb9eaa918f5b8e35c9e110124b8bd13751","modified":1620717797887},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1620717797887},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"27f034e5db8c32e268e2959b9a7c1258d36e4510","modified":1620717797887},{"_id":"public/images/innodb-intro-1.png","hash":"fdbf2c8bff19fdc7ab07f5abdb3b8aec0ca995b8","modified":1620717797887},{"_id":"public/images/space-page-19.png","hash":"b6f7aee7dad7b635161221c5c4e84cf65174f2f4","modified":1620717797887},{"_id":"public/images/space-page-20.png","hash":"d7b5f9e39c5d5f47adb930fc60d40939da736475","modified":1620717797887},{"_id":"public/images/space-page-4.png","hash":"faaf616e502c607a37b4045cb7c9020c0750bdba","modified":1620717797887},{"_id":"public/images/sql-execute-1.jpg","hash":"de7bb4171af4fac85259ef6a229c6c8fd4cd245c","modified":1620717797887},{"_id":"public/images/avatar.jpg","hash":"e7980d215c86bd4ac681991ae0d6ac2f526d3824","modified":1620717797887},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1620717797887},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1620717797887},{"_id":"public/images/server-trx-2.png","hash":"5be00c7eb39b93a93a680d65043e011336b92390","modified":1620717797887},{"_id":"public/images/server-trx-4.png","hash":"2576ee207a3b7df498b31e40ea85bb7524b9ce94","modified":1620717797887},{"_id":"public/images/innodb-trx-3.png","hash":"b3c6f18dcc87e756931cba6873cb0013fae88549","modified":1620717797887},{"_id":"public/images/online-ddl-3.jpg","hash":"8fb4cc60f3ce2cb9dfbc05993121e12bd1a3dfff","modified":1620717797887},{"_id":"public/images/innodb-undo-log-2.png","hash":"cb9c89c09610c48e7ca25701d51099c45f0de75a","modified":1620717797887},{"_id":"public/images/server-trx-3.png","hash":"b17f7d35677aedb0290f122cd945624644cc3e40","modified":1620717797887},{"_id":"public/images/server-trx-1.png","hash":"68dfceb88ddc4ba5d3e2b35db7e7c1a785045c42","modified":1620717797887},{"_id":"public/images/online-ddl-1.jpg","hash":"646c0ca3e1bf0d868c285e9762ba66e0ef7318c8","modified":1620717797887},{"_id":"public/images/innodb-trx-1.png","hash":"0242d50878064b69a50f0e477fb7c0706c204d53","modified":1620717797887},{"_id":"public/images/table-object-1.png","hash":"409d195f9514f978a33aed6e6253b03ac11976d2","modified":1620717797887},{"_id":"public/images/innodb-trx-4.png","hash":"0b75cd2cce3164bb12e28ed8e5a01823948e759c","modified":1620717797887},{"_id":"public/images/innodb-undo-log-3.png","hash":"645c181d542555c3fb0ea06ed0f6046af2375fc4","modified":1620717797887},{"_id":"public/images/innodb-undo-log-4.png","hash":"d523d41853bf141c32b9b9ad481e6338f6dbe387","modified":1620717797887},{"_id":"public/images/online-ddl-2.jpg","hash":"5cd9c05161e419e5d4b8f17ab4f1d1b0bd7e348e","modified":1620717797887},{"_id":"public/images/innodb-undo-log-5.png","hash":"318c86d1dccfa939db140627f8e67a39465e7354","modified":1620717797887},{"_id":"public/images/innodb-undo-log-1.png","hash":"a678ff6e4c0b7a3fbeee530a77b3efe7dbbcf2f2","modified":1620717797887},{"_id":"public/images/buffer-pool-1.png","hash":"7fb804637d681ef535f6f33769a95b9d8d40b801","modified":1620717797887},{"_id":"public/images/innodb-lock-1.png","hash":"38355601cc376fb39be6a4ecd63f102ffe5469e5","modified":1620717797887},{"_id":"public/images/connection-handler-1.jpg","hash":"92bcdd71f0a568d4403763cd742094e0ef6736bf","modified":1620717797887}],"Category":[{"name":"C/C++","_id":"ckojpj4x10006gugm41op9821"},{"name":"数据库","_id":"ckojpj4x7000bgugm0bsh0cjo"},{"name":"InnoDB","_id":"ckojpj4xf000ngugmhvb66sv4"},{"name":"Linux","_id":"ckojpj4xr001igugm4u5te2wm"},{"name":"MySQL","_id":"ckojpj4xw0020gugm2dcaf8e4"},{"name":"其它","_id":"ckojpj4y0002egugm5juhfllp"}],"Data":[],"Page":[{"title":"archives","date":"2020-07-04T03:27:53.000Z","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2020-07-04 11:27:53\n---\n","updated":"2020-07-04T04:50:40.368Z","path":"archives/index.html","comments":1,"layout":"page","_id":"ckojpj4v20000gugm3isfef55","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","date":"2020-07-04T06:10:13.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2020-07-04 14:10:13\ntype: \"categories\"\n---\n","updated":"2020-07-04T11:18:32.927Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckojpj4v90002gugm3vf49wvl","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2020-07-04T03:22:07.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2020-07-04 11:22:07\ntype: \"tags\"\n---\n","updated":"2020-07-04T11:19:15.878Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckojpj4w00003gugmb984fuhe","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"总 (Li) 体 (Xia) 说明 (Flag)","date":"2020-07-04T04:06:18.000Z","_content":"声明：本文档仅作为个人学习过程中的总结与归纳，如果存在错误或者不严谨的描述，欢迎拍砖。\n\n<!-- more -->\n\n## 整体说明\n\n整个文档包括但是不限于以下内容：\n\n- 数据库管理系统 (DataBase Management System)\n- 分布式系统 (Distributed System)\n- 操作系统 (Operating System)\n- 网络与并行处理 (Network and Parallel Processing)\n- 编程语言 (Program Language)\n- 算法与数据结构 (Algorithm and Data Structure)\n- 其它 (Others)\n\n文档的整理和更新过程比较佛系，希望自己能够长期坚持 : )\n\n### 数据库系统\n\n最早接触数据库是在大学课堂，学校的数据库课程更侧重数据库的使用，当然也有一些数据库的理论介绍，但是体感并不强烈。至少笔者在学完数据库课程之后，留下的印象就只有以下几个关键字：SQL、事务、ACID。随着最近一两年更多的接触数据库，才开始慢慢对数据库有了更多的了解，也希望自己的一些体会能够帮助更多的人认识数据库。\n\n数据库的基础知识这一部分，暂定会从以下几个方面进行介绍：\n\n- 数据库系统与文件系统\n- 一条 SQL 的执行过程\n- 索引与 B-tree 介绍\n- 事务系统\n- Redo 和 Undo\n- 关于 DDL 的说明\n- BufferPool 介绍\n- 高可用与读写分离\n- 存储计算分离\n\n### 分布式系统\n\n分布式系统可以说是最近几年 IT 领域最热门的词汇之一，好像所有的应用系统，不带上“分布式”都显得不够逼格。这里也谈谈自己对分布式系统的一点浅薄的理解：\n\n- Scale Up or Scale Out\n- Paxos and Raft\n- 分布式数据库\n- 分布式文件系统\n\n### 操作系统\n\n不管在什么版本的程序猿鄙视链条中，操作系统内核程序猿永远都是位于顶端的那一拨，由此可见操作系统的重要性，关于操作系统的介绍，完全是结合遇到的问题展开，谈不上深入了解，只能算是一个记录：\n\n- Page Cache\n- IO 模型\n- mmap 的一点说明\n- 神奇的 fork\n- 系统监控\n- VFS 虚拟文件系统\n\n### 网络与并行处理\n\n从理论和实践两个维度对网络相关的知识作一个总结：\n\n- 网络七层\n- 三次握手\n- tcp 与 socket\n- http 与 https\n- pool and epool\n- react 反应堆模式\n- Netty 入门\n- Mycat 介绍\n\n### 编程语言\n\n本人接触的编程语言不算多，迄今为止重度使用的包括：Java、Python、C++。不同的语言有不同的特点，也有一些想通的地方，本部分的文章主要记录编程语言中的一些重要特征和注意事项：\n\n- 面向对象\n- Java 中的并发包\n- C++ 之指针\n- Python = 慢 ？\n- C++ STL\n- 容器类的使用\n- 多线程\n- 同步与异步\n- 生产者与消费者\n- 设计模式\n- 内存管理\n- 常用的测试框架\n\n### 算法与数据结构\n\n这部分会记录一些常见算法与数据结构，当然也包括LeetCode的随笔，内容随缘。\n\n### 其它\n\n所有不能归为上面类型的都放到这里了，包括一些常见的工具使用：\n\n- perf 使用\n- tcpdump 使用\n- wireshark 使用\n- gdb 使用\n- pdb 使用\n- git 使用总结\n- vim 使用总结\n- cgroup 介绍\n- docker 介绍\n\n以上就是本文档的一个总体说明，Flag 已经立下了，希望自己能够坚持。","source":"_posts/menu.md","raw":"---\ntitle: 总 (Li) 体 (Xia) 说明 (Flag)\ndate: 2020-07-04 12:06:18\n\n---\n声明：本文档仅作为个人学习过程中的总结与归纳，如果存在错误或者不严谨的描述，欢迎拍砖。\n\n<!-- more -->\n\n## 整体说明\n\n整个文档包括但是不限于以下内容：\n\n- 数据库管理系统 (DataBase Management System)\n- 分布式系统 (Distributed System)\n- 操作系统 (Operating System)\n- 网络与并行处理 (Network and Parallel Processing)\n- 编程语言 (Program Language)\n- 算法与数据结构 (Algorithm and Data Structure)\n- 其它 (Others)\n\n文档的整理和更新过程比较佛系，希望自己能够长期坚持 : )\n\n### 数据库系统\n\n最早接触数据库是在大学课堂，学校的数据库课程更侧重数据库的使用，当然也有一些数据库的理论介绍，但是体感并不强烈。至少笔者在学完数据库课程之后，留下的印象就只有以下几个关键字：SQL、事务、ACID。随着最近一两年更多的接触数据库，才开始慢慢对数据库有了更多的了解，也希望自己的一些体会能够帮助更多的人认识数据库。\n\n数据库的基础知识这一部分，暂定会从以下几个方面进行介绍：\n\n- 数据库系统与文件系统\n- 一条 SQL 的执行过程\n- 索引与 B-tree 介绍\n- 事务系统\n- Redo 和 Undo\n- 关于 DDL 的说明\n- BufferPool 介绍\n- 高可用与读写分离\n- 存储计算分离\n\n### 分布式系统\n\n分布式系统可以说是最近几年 IT 领域最热门的词汇之一，好像所有的应用系统，不带上“分布式”都显得不够逼格。这里也谈谈自己对分布式系统的一点浅薄的理解：\n\n- Scale Up or Scale Out\n- Paxos and Raft\n- 分布式数据库\n- 分布式文件系统\n\n### 操作系统\n\n不管在什么版本的程序猿鄙视链条中，操作系统内核程序猿永远都是位于顶端的那一拨，由此可见操作系统的重要性，关于操作系统的介绍，完全是结合遇到的问题展开，谈不上深入了解，只能算是一个记录：\n\n- Page Cache\n- IO 模型\n- mmap 的一点说明\n- 神奇的 fork\n- 系统监控\n- VFS 虚拟文件系统\n\n### 网络与并行处理\n\n从理论和实践两个维度对网络相关的知识作一个总结：\n\n- 网络七层\n- 三次握手\n- tcp 与 socket\n- http 与 https\n- pool and epool\n- react 反应堆模式\n- Netty 入门\n- Mycat 介绍\n\n### 编程语言\n\n本人接触的编程语言不算多，迄今为止重度使用的包括：Java、Python、C++。不同的语言有不同的特点，也有一些想通的地方，本部分的文章主要记录编程语言中的一些重要特征和注意事项：\n\n- 面向对象\n- Java 中的并发包\n- C++ 之指针\n- Python = 慢 ？\n- C++ STL\n- 容器类的使用\n- 多线程\n- 同步与异步\n- 生产者与消费者\n- 设计模式\n- 内存管理\n- 常用的测试框架\n\n### 算法与数据结构\n\n这部分会记录一些常见算法与数据结构，当然也包括LeetCode的随笔，内容随缘。\n\n### 其它\n\n所有不能归为上面类型的都放到这里了，包括一些常见的工具使用：\n\n- perf 使用\n- tcpdump 使用\n- wireshark 使用\n- gdb 使用\n- pdb 使用\n- git 使用总结\n- vim 使用总结\n- cgroup 介绍\n- docker 介绍\n\n以上就是本文档的一个总体说明，Flag 已经立下了，希望自己能够坚持。","slug":"menu","published":1,"updated":"2020-12-05T12:03:20.489Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4v60001gugm5wij4jlg","content":"<p>声明：本文档仅作为个人学习过程中的总结与归纳，如果存在错误或者不严谨的描述，欢迎拍砖。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"整体说明\"><a href=\"#整体说明\" class=\"headerlink\" title=\"整体说明\"></a>整体说明</h2><p>整个文档包括但是不限于以下内容：</p>\n<ul>\n<li>数据库管理系统 (DataBase Management System)</li>\n<li>分布式系统 (Distributed System)</li>\n<li>操作系统 (Operating System)</li>\n<li>网络与并行处理 (Network and Parallel Processing)</li>\n<li>编程语言 (Program Language)</li>\n<li>算法与数据结构 (Algorithm and Data Structure)</li>\n<li>其它 (Others)</li>\n</ul>\n<p>文档的整理和更新过程比较佛系，希望自己能够长期坚持 : )</p>\n<h3 id=\"数据库系统\"><a href=\"#数据库系统\" class=\"headerlink\" title=\"数据库系统\"></a>数据库系统</h3><p>最早接触数据库是在大学课堂，学校的数据库课程更侧重数据库的使用，当然也有一些数据库的理论介绍，但是体感并不强烈。至少笔者在学完数据库课程之后，留下的印象就只有以下几个关键字：SQL、事务、ACID。随着最近一两年更多的接触数据库，才开始慢慢对数据库有了更多的了解，也希望自己的一些体会能够帮助更多的人认识数据库。</p>\n<p>数据库的基础知识这一部分，暂定会从以下几个方面进行介绍：</p>\n<ul>\n<li>数据库系统与文件系统</li>\n<li>一条 SQL 的执行过程</li>\n<li>索引与 B-tree 介绍</li>\n<li>事务系统</li>\n<li>Redo 和 Undo</li>\n<li>关于 DDL 的说明</li>\n<li>BufferPool 介绍</li>\n<li>高可用与读写分离</li>\n<li>存储计算分离</li>\n</ul>\n<h3 id=\"分布式系统\"><a href=\"#分布式系统\" class=\"headerlink\" title=\"分布式系统\"></a>分布式系统</h3><p>分布式系统可以说是最近几年 IT 领域最热门的词汇之一，好像所有的应用系统，不带上“分布式”都显得不够逼格。这里也谈谈自己对分布式系统的一点浅薄的理解：</p>\n<ul>\n<li>Scale Up or Scale Out</li>\n<li>Paxos and Raft</li>\n<li>分布式数据库</li>\n<li>分布式文件系统</li>\n</ul>\n<h3 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h3><p>不管在什么版本的程序猿鄙视链条中，操作系统内核程序猿永远都是位于顶端的那一拨，由此可见操作系统的重要性，关于操作系统的介绍，完全是结合遇到的问题展开，谈不上深入了解，只能算是一个记录：</p>\n<ul>\n<li>Page Cache</li>\n<li>IO 模型</li>\n<li>mmap 的一点说明</li>\n<li>神奇的 fork</li>\n<li>系统监控</li>\n<li>VFS 虚拟文件系统</li>\n</ul>\n<h3 id=\"网络与并行处理\"><a href=\"#网络与并行处理\" class=\"headerlink\" title=\"网络与并行处理\"></a>网络与并行处理</h3><p>从理论和实践两个维度对网络相关的知识作一个总结：</p>\n<ul>\n<li>网络七层</li>\n<li>三次握手</li>\n<li>tcp 与 socket</li>\n<li>http 与 https</li>\n<li>pool and epool</li>\n<li>react 反应堆模式</li>\n<li>Netty 入门</li>\n<li>Mycat 介绍</li>\n</ul>\n<h3 id=\"编程语言\"><a href=\"#编程语言\" class=\"headerlink\" title=\"编程语言\"></a>编程语言</h3><p>本人接触的编程语言不算多，迄今为止重度使用的包括：Java、Python、C++。不同的语言有不同的特点，也有一些想通的地方，本部分的文章主要记录编程语言中的一些重要特征和注意事项：</p>\n<ul>\n<li>面向对象</li>\n<li>Java 中的并发包</li>\n<li>C++ 之指针</li>\n<li>Python = 慢 ？</li>\n<li>C++ STL</li>\n<li>容器类的使用</li>\n<li>多线程</li>\n<li>同步与异步</li>\n<li>生产者与消费者</li>\n<li>设计模式</li>\n<li>内存管理</li>\n<li>常用的测试框架</li>\n</ul>\n<h3 id=\"算法与数据结构\"><a href=\"#算法与数据结构\" class=\"headerlink\" title=\"算法与数据结构\"></a>算法与数据结构</h3><p>这部分会记录一些常见算法与数据结构，当然也包括LeetCode的随笔，内容随缘。</p>\n<h3 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h3><p>所有不能归为上面类型的都放到这里了，包括一些常见的工具使用：</p>\n<ul>\n<li>perf 使用</li>\n<li>tcpdump 使用</li>\n<li>wireshark 使用</li>\n<li>gdb 使用</li>\n<li>pdb 使用</li>\n<li>git 使用总结</li>\n<li>vim 使用总结</li>\n<li>cgroup 介绍</li>\n<li>docker 介绍</li>\n</ul>\n<p>以上就是本文档的一个总体说明，Flag 已经立下了，希望自己能够坚持。</p>\n","site":{"data":{}},"excerpt":"<p>声明：本文档仅作为个人学习过程中的总结与归纳，如果存在错误或者不严谨的描述，欢迎拍砖。</p>","more":"<h2 id=\"整体说明\"><a href=\"#整体说明\" class=\"headerlink\" title=\"整体说明\"></a>整体说明</h2><p>整个文档包括但是不限于以下内容：</p>\n<ul>\n<li>数据库管理系统 (DataBase Management System)</li>\n<li>分布式系统 (Distributed System)</li>\n<li>操作系统 (Operating System)</li>\n<li>网络与并行处理 (Network and Parallel Processing)</li>\n<li>编程语言 (Program Language)</li>\n<li>算法与数据结构 (Algorithm and Data Structure)</li>\n<li>其它 (Others)</li>\n</ul>\n<p>文档的整理和更新过程比较佛系，希望自己能够长期坚持 : )</p>\n<h3 id=\"数据库系统\"><a href=\"#数据库系统\" class=\"headerlink\" title=\"数据库系统\"></a>数据库系统</h3><p>最早接触数据库是在大学课堂，学校的数据库课程更侧重数据库的使用，当然也有一些数据库的理论介绍，但是体感并不强烈。至少笔者在学完数据库课程之后，留下的印象就只有以下几个关键字：SQL、事务、ACID。随着最近一两年更多的接触数据库，才开始慢慢对数据库有了更多的了解，也希望自己的一些体会能够帮助更多的人认识数据库。</p>\n<p>数据库的基础知识这一部分，暂定会从以下几个方面进行介绍：</p>\n<ul>\n<li>数据库系统与文件系统</li>\n<li>一条 SQL 的执行过程</li>\n<li>索引与 B-tree 介绍</li>\n<li>事务系统</li>\n<li>Redo 和 Undo</li>\n<li>关于 DDL 的说明</li>\n<li>BufferPool 介绍</li>\n<li>高可用与读写分离</li>\n<li>存储计算分离</li>\n</ul>\n<h3 id=\"分布式系统\"><a href=\"#分布式系统\" class=\"headerlink\" title=\"分布式系统\"></a>分布式系统</h3><p>分布式系统可以说是最近几年 IT 领域最热门的词汇之一，好像所有的应用系统，不带上“分布式”都显得不够逼格。这里也谈谈自己对分布式系统的一点浅薄的理解：</p>\n<ul>\n<li>Scale Up or Scale Out</li>\n<li>Paxos and Raft</li>\n<li>分布式数据库</li>\n<li>分布式文件系统</li>\n</ul>\n<h3 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h3><p>不管在什么版本的程序猿鄙视链条中，操作系统内核程序猿永远都是位于顶端的那一拨，由此可见操作系统的重要性，关于操作系统的介绍，完全是结合遇到的问题展开，谈不上深入了解，只能算是一个记录：</p>\n<ul>\n<li>Page Cache</li>\n<li>IO 模型</li>\n<li>mmap 的一点说明</li>\n<li>神奇的 fork</li>\n<li>系统监控</li>\n<li>VFS 虚拟文件系统</li>\n</ul>\n<h3 id=\"网络与并行处理\"><a href=\"#网络与并行处理\" class=\"headerlink\" title=\"网络与并行处理\"></a>网络与并行处理</h3><p>从理论和实践两个维度对网络相关的知识作一个总结：</p>\n<ul>\n<li>网络七层</li>\n<li>三次握手</li>\n<li>tcp 与 socket</li>\n<li>http 与 https</li>\n<li>pool and epool</li>\n<li>react 反应堆模式</li>\n<li>Netty 入门</li>\n<li>Mycat 介绍</li>\n</ul>\n<h3 id=\"编程语言\"><a href=\"#编程语言\" class=\"headerlink\" title=\"编程语言\"></a>编程语言</h3><p>本人接触的编程语言不算多，迄今为止重度使用的包括：Java、Python、C++。不同的语言有不同的特点，也有一些想通的地方，本部分的文章主要记录编程语言中的一些重要特征和注意事项：</p>\n<ul>\n<li>面向对象</li>\n<li>Java 中的并发包</li>\n<li>C++ 之指针</li>\n<li>Python = 慢 ？</li>\n<li>C++ STL</li>\n<li>容器类的使用</li>\n<li>多线程</li>\n<li>同步与异步</li>\n<li>生产者与消费者</li>\n<li>设计模式</li>\n<li>内存管理</li>\n<li>常用的测试框架</li>\n</ul>\n<h3 id=\"算法与数据结构\"><a href=\"#算法与数据结构\" class=\"headerlink\" title=\"算法与数据结构\"></a>算法与数据结构</h3><p>这部分会记录一些常见算法与数据结构，当然也包括LeetCode的随笔，内容随缘。</p>\n<h3 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h3><p>所有不能归为上面类型的都放到这里了，包括一些常见的工具使用：</p>\n<ul>\n<li>perf 使用</li>\n<li>tcpdump 使用</li>\n<li>wireshark 使用</li>\n<li>gdb 使用</li>\n<li>pdb 使用</li>\n<li>git 使用总结</li>\n<li>vim 使用总结</li>\n<li>cgroup 介绍</li>\n<li>docker 介绍</li>\n</ul>\n<p>以上就是本文档的一个总体说明，Flag 已经立下了，希望自己能够坚持。</p>"},{"title":"new/delete、malloc/free 杂谈","date":"2020-11-08T08:21:20.000Z","_content":"\n很多从 Java 或者 Python 等语言转到 C/C++ 的时候，都会对内存管理，对象申请等问题非常疑惑，笔者今天尝试结合自己的切身经历进行一个简单的记录。\n\n<!-- more -->\n\n## 堆和栈\n\n内存区域通常可以划分为以下几个类型：\n\n- 栈：由编译器在需要的时候分配，通常包括：局部变量、参数等\n- 堆：由程序手动分配、回收\n- 全局/静态存储：存放全局变量和静态变量\n- 常量存储：存放常量\n\n一个简单的例子如下：\n\n```\n/* main.cpp */\n\nint a = 0;  // 全局/静态存储\nchar *p1;  // 全局/静态存储\n\nmain() {\n  int b;  // 栈\n  char s[] = \"abc\";  // abc 在全局/静态存储\n  char *p2;  // 栈\n  char *p3 = \"123456\";  // 123456\\0 在常量存储，p3 在栈\n\n  static int c = 0； // 全局/静态存储\n\n  p1 = (char *)malloc(10);  // 堆\n}\n```\n\n回到堆和栈的概念本身，一个比较好的角度是：\n\n- 栈对应的是自动变量（局部变量）：会在作用域（如函数作用域、块作用域等）结束后析构、释放内存。因为分配和释放的次序是刚好完全相反的，所以可用到堆栈先进后出（first-in-last-out, FILO）的特性，而 C++ 语言的实现一般也会使用到调用堆栈（call stack）来分配自动变量（但非标准的要求）；\n- 堆对应的是自由存储：可以在函数结束后继续生存，所以也需要配合 delete 来手动析构、释放内存（也可使用智能指针避免手动 delete ）。由于分配和释放次序没有限制，不能使用堆栈这种数据结构做分配，实现上可能采用自由链表（free list）或其他动态内存分配机制；\n\n更多关于堆和栈的更对信息，例如：管理方式、分配效率等，在此不做介绍。\n\n## new/delete VS malloc/free\n\n回到本文讨论的内容，首先需要明确的是：不管是 new 还是 malloc ，都是在堆上进行内存分配，所以都需要手动的进行内存的回收。\n\n关于两者的区别，可以总结如下：\n\n1. new/delete 是 C++ 的操作符，而 malloc/free 是 C 中的函数；\n2. new 做两件事，一是分配内存，二是调用类的构造函数；同样，delete 会调用类的析构函数和释放内存。而 malloc 和 free 只是分配和释放内存；\n3. new 建立的是一个对象，而 malloc 分配的是一块内存；new 建立的对象可以用成员函数访问，不要直接访问它的地址空间；malloc 分配的是一块内存区域，用指针访问，可以在里面移动指针；new 出来的指针是带有类型信息的，而 malloc 返回的是 void 指针；\n4. new/delete 是保留字，不需要头文件支持；malloc/free 需要头文件库函数支持；\n\n一个简单的例子如下：\n\n```\nclass Obj {\npublic:\n    Obj() { cout << \"Initialization\" << endl; }\n    ~Obj() { cout << \"Destroy\" << endl; }\n    void Initialize() { cout << \"Initialization\" << endl; }\n    void Destroy() { cout << \"Destroy\" << endl; }\n};\n\nvoid UseMallocFree() {\n    Obj *a = (Obj*)malloc(sizeof(obj));\n    a->Intialize();\n    // ...\n    a->Destroy();\n    free(a);\n}\n\nvoid UseNewDelete() {\n    Obj *a = new Obj;\n    //...\n    delete a;\n}\n```\n\n类 Obj 的函数 Initialize 模拟了构造函数的功能，函数 Destroy 模拟了析构函数的功能。函数 UseMallocFree 中，由于 malloc/free 不能执行构造函数与析构函数，必须调用成员函数 Initialize 和 Destroy 来完成初始化与清除工作。函数 UseNewDelete 则简单得多。\n\n注意：new 和 delete 配套使用，new[] 和 delete[] 配套使用。","source":"_posts/clang/new-malloc.md","raw":"---\ntitle: new/delete、malloc/free 杂谈\ndate: 2020-11-08 16:21:20\ncategories: \n- C/C++\n\n---\n\n很多从 Java 或者 Python 等语言转到 C/C++ 的时候，都会对内存管理，对象申请等问题非常疑惑，笔者今天尝试结合自己的切身经历进行一个简单的记录。\n\n<!-- more -->\n\n## 堆和栈\n\n内存区域通常可以划分为以下几个类型：\n\n- 栈：由编译器在需要的时候分配，通常包括：局部变量、参数等\n- 堆：由程序手动分配、回收\n- 全局/静态存储：存放全局变量和静态变量\n- 常量存储：存放常量\n\n一个简单的例子如下：\n\n```\n/* main.cpp */\n\nint a = 0;  // 全局/静态存储\nchar *p1;  // 全局/静态存储\n\nmain() {\n  int b;  // 栈\n  char s[] = \"abc\";  // abc 在全局/静态存储\n  char *p2;  // 栈\n  char *p3 = \"123456\";  // 123456\\0 在常量存储，p3 在栈\n\n  static int c = 0； // 全局/静态存储\n\n  p1 = (char *)malloc(10);  // 堆\n}\n```\n\n回到堆和栈的概念本身，一个比较好的角度是：\n\n- 栈对应的是自动变量（局部变量）：会在作用域（如函数作用域、块作用域等）结束后析构、释放内存。因为分配和释放的次序是刚好完全相反的，所以可用到堆栈先进后出（first-in-last-out, FILO）的特性，而 C++ 语言的实现一般也会使用到调用堆栈（call stack）来分配自动变量（但非标准的要求）；\n- 堆对应的是自由存储：可以在函数结束后继续生存，所以也需要配合 delete 来手动析构、释放内存（也可使用智能指针避免手动 delete ）。由于分配和释放次序没有限制，不能使用堆栈这种数据结构做分配，实现上可能采用自由链表（free list）或其他动态内存分配机制；\n\n更多关于堆和栈的更对信息，例如：管理方式、分配效率等，在此不做介绍。\n\n## new/delete VS malloc/free\n\n回到本文讨论的内容，首先需要明确的是：不管是 new 还是 malloc ，都是在堆上进行内存分配，所以都需要手动的进行内存的回收。\n\n关于两者的区别，可以总结如下：\n\n1. new/delete 是 C++ 的操作符，而 malloc/free 是 C 中的函数；\n2. new 做两件事，一是分配内存，二是调用类的构造函数；同样，delete 会调用类的析构函数和释放内存。而 malloc 和 free 只是分配和释放内存；\n3. new 建立的是一个对象，而 malloc 分配的是一块内存；new 建立的对象可以用成员函数访问，不要直接访问它的地址空间；malloc 分配的是一块内存区域，用指针访问，可以在里面移动指针；new 出来的指针是带有类型信息的，而 malloc 返回的是 void 指针；\n4. new/delete 是保留字，不需要头文件支持；malloc/free 需要头文件库函数支持；\n\n一个简单的例子如下：\n\n```\nclass Obj {\npublic:\n    Obj() { cout << \"Initialization\" << endl; }\n    ~Obj() { cout << \"Destroy\" << endl; }\n    void Initialize() { cout << \"Initialization\" << endl; }\n    void Destroy() { cout << \"Destroy\" << endl; }\n};\n\nvoid UseMallocFree() {\n    Obj *a = (Obj*)malloc(sizeof(obj));\n    a->Intialize();\n    // ...\n    a->Destroy();\n    free(a);\n}\n\nvoid UseNewDelete() {\n    Obj *a = new Obj;\n    //...\n    delete a;\n}\n```\n\n类 Obj 的函数 Initialize 模拟了构造函数的功能，函数 Destroy 模拟了析构函数的功能。函数 UseMallocFree 中，由于 malloc/free 不能执行构造函数与析构函数，必须调用成员函数 Initialize 和 Destroy 来完成初始化与清除工作。函数 UseNewDelete 则简单得多。\n\n注意：new 和 delete 配套使用，new[] 和 delete[] 配套使用。","slug":"clang/new-malloc","published":1,"updated":"2020-12-05T12:02:54.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4wz0004gugmfzq770ef","content":"<p>很多从 Java 或者 Python 等语言转到 C/C++ 的时候，都会对内存管理，对象申请等问题非常疑惑，笔者今天尝试结合自己的切身经历进行一个简单的记录。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"堆和栈\"><a href=\"#堆和栈\" class=\"headerlink\" title=\"堆和栈\"></a>堆和栈</h2><p>内存区域通常可以划分为以下几个类型：</p>\n<ul>\n<li>栈：由编译器在需要的时候分配，通常包括：局部变量、参数等</li>\n<li>堆：由程序手动分配、回收</li>\n<li>全局/静态存储：存放全局变量和静态变量</li>\n<li>常量存储：存放常量</li>\n</ul>\n<p>一个简单的例子如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;* main.cpp *&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">int a &#x3D; 0;  &#x2F;&#x2F; 全局&#x2F;静态存储</span><br><span class=\"line\">char *p1;  &#x2F;&#x2F; 全局&#x2F;静态存储</span><br><span class=\"line\"></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  int b;  &#x2F;&#x2F; 栈</span><br><span class=\"line\">  char s[] &#x3D; &quot;abc&quot;;  &#x2F;&#x2F; abc 在全局&#x2F;静态存储</span><br><span class=\"line\">  char *p2;  &#x2F;&#x2F; 栈</span><br><span class=\"line\">  char *p3 &#x3D; &quot;123456&quot;;  &#x2F;&#x2F; 123456\\0 在常量存储，p3 在栈</span><br><span class=\"line\"></span><br><span class=\"line\">  static int c &#x3D; 0； &#x2F;&#x2F; 全局&#x2F;静态存储</span><br><span class=\"line\"></span><br><span class=\"line\">  p1 &#x3D; (char *)malloc(10);  &#x2F;&#x2F; 堆</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>回到堆和栈的概念本身，一个比较好的角度是：</p>\n<ul>\n<li>栈对应的是自动变量（局部变量）：会在作用域（如函数作用域、块作用域等）结束后析构、释放内存。因为分配和释放的次序是刚好完全相反的，所以可用到堆栈先进后出（first-in-last-out, FILO）的特性，而 C++ 语言的实现一般也会使用到调用堆栈（call stack）来分配自动变量（但非标准的要求）；</li>\n<li>堆对应的是自由存储：可以在函数结束后继续生存，所以也需要配合 delete 来手动析构、释放内存（也可使用智能指针避免手动 delete ）。由于分配和释放次序没有限制，不能使用堆栈这种数据结构做分配，实现上可能采用自由链表（free list）或其他动态内存分配机制；</li>\n</ul>\n<p>更多关于堆和栈的更对信息，例如：管理方式、分配效率等，在此不做介绍。</p>\n<h2 id=\"new-delete-VS-malloc-free\"><a href=\"#new-delete-VS-malloc-free\" class=\"headerlink\" title=\"new/delete VS malloc/free\"></a>new/delete VS malloc/free</h2><p>回到本文讨论的内容，首先需要明确的是：不管是 new 还是 malloc ，都是在堆上进行内存分配，所以都需要手动的进行内存的回收。</p>\n<p>关于两者的区别，可以总结如下：</p>\n<ol>\n<li>new/delete 是 C++ 的操作符，而 malloc/free 是 C 中的函数；</li>\n<li>new 做两件事，一是分配内存，二是调用类的构造函数；同样，delete 会调用类的析构函数和释放内存。而 malloc 和 free 只是分配和释放内存；</li>\n<li>new 建立的是一个对象，而 malloc 分配的是一块内存；new 建立的对象可以用成员函数访问，不要直接访问它的地址空间；malloc 分配的是一块内存区域，用指针访问，可以在里面移动指针；new 出来的指针是带有类型信息的，而 malloc 返回的是 void 指针；</li>\n<li>new/delete 是保留字，不需要头文件支持；malloc/free 需要头文件库函数支持；</li>\n</ol>\n<p>一个简单的例子如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Obj &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Obj() &#123; cout &lt;&lt; &quot;Initialization&quot; &lt;&lt; endl; &#125;</span><br><span class=\"line\">    ~Obj() &#123; cout &lt;&lt; &quot;Destroy&quot; &lt;&lt; endl; &#125;</span><br><span class=\"line\">    void Initialize() &#123; cout &lt;&lt; &quot;Initialization&quot; &lt;&lt; endl; &#125;</span><br><span class=\"line\">    void Destroy() &#123; cout &lt;&lt; &quot;Destroy&quot; &lt;&lt; endl; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void UseMallocFree() &#123;</span><br><span class=\"line\">    Obj *a &#x3D; (Obj*)malloc(sizeof(obj));</span><br><span class=\"line\">    a-&gt;Intialize();</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">    a-&gt;Destroy();</span><br><span class=\"line\">    free(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void UseNewDelete() &#123;</span><br><span class=\"line\">    Obj *a &#x3D; new Obj;</span><br><span class=\"line\">    &#x2F;&#x2F;...</span><br><span class=\"line\">    delete a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类 Obj 的函数 Initialize 模拟了构造函数的功能，函数 Destroy 模拟了析构函数的功能。函数 UseMallocFree 中，由于 malloc/free 不能执行构造函数与析构函数，必须调用成员函数 Initialize 和 Destroy 来完成初始化与清除工作。函数 UseNewDelete 则简单得多。</p>\n<p>注意：new 和 delete 配套使用，new[] 和 delete[] 配套使用。</p>\n","site":{"data":{}},"excerpt":"<p>很多从 Java 或者 Python 等语言转到 C/C++ 的时候，都会对内存管理，对象申请等问题非常疑惑，笔者今天尝试结合自己的切身经历进行一个简单的记录。</p>","more":"<h2 id=\"堆和栈\"><a href=\"#堆和栈\" class=\"headerlink\" title=\"堆和栈\"></a>堆和栈</h2><p>内存区域通常可以划分为以下几个类型：</p>\n<ul>\n<li>栈：由编译器在需要的时候分配，通常包括：局部变量、参数等</li>\n<li>堆：由程序手动分配、回收</li>\n<li>全局/静态存储：存放全局变量和静态变量</li>\n<li>常量存储：存放常量</li>\n</ul>\n<p>一个简单的例子如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;* main.cpp *&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">int a &#x3D; 0;  &#x2F;&#x2F; 全局&#x2F;静态存储</span><br><span class=\"line\">char *p1;  &#x2F;&#x2F; 全局&#x2F;静态存储</span><br><span class=\"line\"></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  int b;  &#x2F;&#x2F; 栈</span><br><span class=\"line\">  char s[] &#x3D; &quot;abc&quot;;  &#x2F;&#x2F; abc 在全局&#x2F;静态存储</span><br><span class=\"line\">  char *p2;  &#x2F;&#x2F; 栈</span><br><span class=\"line\">  char *p3 &#x3D; &quot;123456&quot;;  &#x2F;&#x2F; 123456\\0 在常量存储，p3 在栈</span><br><span class=\"line\"></span><br><span class=\"line\">  static int c &#x3D; 0； &#x2F;&#x2F; 全局&#x2F;静态存储</span><br><span class=\"line\"></span><br><span class=\"line\">  p1 &#x3D; (char *)malloc(10);  &#x2F;&#x2F; 堆</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>回到堆和栈的概念本身，一个比较好的角度是：</p>\n<ul>\n<li>栈对应的是自动变量（局部变量）：会在作用域（如函数作用域、块作用域等）结束后析构、释放内存。因为分配和释放的次序是刚好完全相反的，所以可用到堆栈先进后出（first-in-last-out, FILO）的特性，而 C++ 语言的实现一般也会使用到调用堆栈（call stack）来分配自动变量（但非标准的要求）；</li>\n<li>堆对应的是自由存储：可以在函数结束后继续生存，所以也需要配合 delete 来手动析构、释放内存（也可使用智能指针避免手动 delete ）。由于分配和释放次序没有限制，不能使用堆栈这种数据结构做分配，实现上可能采用自由链表（free list）或其他动态内存分配机制；</li>\n</ul>\n<p>更多关于堆和栈的更对信息，例如：管理方式、分配效率等，在此不做介绍。</p>\n<h2 id=\"new-delete-VS-malloc-free\"><a href=\"#new-delete-VS-malloc-free\" class=\"headerlink\" title=\"new/delete VS malloc/free\"></a>new/delete VS malloc/free</h2><p>回到本文讨论的内容，首先需要明确的是：不管是 new 还是 malloc ，都是在堆上进行内存分配，所以都需要手动的进行内存的回收。</p>\n<p>关于两者的区别，可以总结如下：</p>\n<ol>\n<li>new/delete 是 C++ 的操作符，而 malloc/free 是 C 中的函数；</li>\n<li>new 做两件事，一是分配内存，二是调用类的构造函数；同样，delete 会调用类的析构函数和释放内存。而 malloc 和 free 只是分配和释放内存；</li>\n<li>new 建立的是一个对象，而 malloc 分配的是一块内存；new 建立的对象可以用成员函数访问，不要直接访问它的地址空间；malloc 分配的是一块内存区域，用指针访问，可以在里面移动指针；new 出来的指针是带有类型信息的，而 malloc 返回的是 void 指针；</li>\n<li>new/delete 是保留字，不需要头文件支持；malloc/free 需要头文件库函数支持；</li>\n</ol>\n<p>一个简单的例子如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Obj &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Obj() &#123; cout &lt;&lt; &quot;Initialization&quot; &lt;&lt; endl; &#125;</span><br><span class=\"line\">    ~Obj() &#123; cout &lt;&lt; &quot;Destroy&quot; &lt;&lt; endl; &#125;</span><br><span class=\"line\">    void Initialize() &#123; cout &lt;&lt; &quot;Initialization&quot; &lt;&lt; endl; &#125;</span><br><span class=\"line\">    void Destroy() &#123; cout &lt;&lt; &quot;Destroy&quot; &lt;&lt; endl; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void UseMallocFree() &#123;</span><br><span class=\"line\">    Obj *a &#x3D; (Obj*)malloc(sizeof(obj));</span><br><span class=\"line\">    a-&gt;Intialize();</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">    a-&gt;Destroy();</span><br><span class=\"line\">    free(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void UseNewDelete() &#123;</span><br><span class=\"line\">    Obj *a &#x3D; new Obj;</span><br><span class=\"line\">    &#x2F;&#x2F;...</span><br><span class=\"line\">    delete a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类 Obj 的函数 Initialize 模拟了构造函数的功能，函数 Destroy 模拟了析构函数的功能。函数 UseMallocFree 中，由于 malloc/free 不能执行构造函数与析构函数，必须调用成员函数 Initialize 和 Destroy 来完成初始化与清除工作。函数 UseNewDelete 则简单得多。</p>\n<p>注意：new 和 delete 配套使用，new[] 和 delete[] 配套使用。</p>"},{"title":"初识事务","date":"2020-07-13T15:03:15.000Z","_content":"\n提到数据库，相信很多人第一个想到的就是事务，今天就从事务开始，对数据库的基本特征以及背后的实现逻辑进行一个简单的说明。\n\n<!-- more -->\n\n## 事务\n\n在写这篇文章的时候，笔者特意又重新查了下事务的定义。维基百科中关于事务的定义是：“事务是数据库系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成”。事务的概念本身并没有什么好展开的，事务之所以成为数据库系统最重要的特征之一，是因为事务的 ACID 属性。\n\n### ACID\n\n**Atomicity（原子性）** ：事务中的一组操作，要么全部成功，要么全部失败，不存在部分成功的情况。原子性的定义相对是比较直观的，可以类比编程语言中的原子操作，从这个角度上来说，事务是数据库系统处理用户操作的最小单位（自动提交模式可以看作是一条语句一个事务）。数据库系统内部主要通过 Undo（回滚日志、前进项）来保证原子性。每一个操作在执行时，都会记录下执行前的状态到 Undo 中，当事务需要回滚时，就可以通过 Undo 恢复到事务执行前的状态。\n\n**Consistency（一致性）** ：数据库总是从一个一致性状态转移到另一个一致性状态。一致性的定义比较模糊，什么叫从一个一致性状态转移到另一个一致性状态？其实这是由于中文的翻译往往只翻译了一半，关于一致性有一段非常最要的补充：\n\n```shell\nAny data written to the database must be valid according to all defined rules, \nincluding constraints, cascades, triggers, and any combination thereof. \n```\n\n总结起来就是：数据库在任意时刻的状态都必须符合所有的验证规则。一个简单的例子：表A记录了用户的账户余额，表B记录了用户的消费记录。从数据库的角度，A中的值与B中记录的和应该总是一个固定值，这就是一条验证规则。另外一个例子：表A存了用户信息，表B存了地址信息，表B中的地址被表A引用（外键），那么删除表B中的记录时，必须检查表A中的记录，这也是一条验证规则。关于一致性的判断，更多的需要与关系间的内在逻辑相结合。\n\n**Isolation（隔离性）** ：不同事务间的操作是相互隔离的，一个事务的操作不受其他事务的影响，也不会影响其他事务。关于隔离性，不同的数据库有不同的实现逻辑，按照可见性进行划分，可以分为四种不同的隔离级别。关于隔离级别，下个部分会进行详细介绍。\n\n**Durability（持久性）** ：一个事务只要提交成功就必须完整保存，不管发生任何软件或者硬件故障都必须保证数据不会丢失。持久性可以说是数据库系统的基础，在真实的业务场景中，数据丢失也往往是最无法容忍的。数据库系统主要通过 Redo（重做日志、后进项）来保证持久性。Redo 是一种典型的 WAL，每一个操作在执行时，都会记录这个操作的内容，并持久化到 Redo 中。当系统恢复时，如果发现之前的操作没有生效，可以通过 Redo 进行重做，保证已提交的操作有效。\n\n### 事务隔离级别\n\n前面提到，按照可见性进行划分，隔离性可以分为四种不同的事务隔离级别，下面逐一进行说明。\n\n**Read Uncommit（读未提交）** ：一个事务的修改可以立即被其它事务读取。读未提交的问题是会出现脏读，举例来说：事务1修改表A的数据，未提交，此时事务2读到了修改项，随后事务1进行了回滚。读未提交是最弱的一种隔离级别，在生产环境中，基本上不会使用。\n\n**Read Committed（读已提交）** ：一个事务的修改在事务提交后可以立即被其它事务读取到。读已提交避免了脏读的问题，这也是当前主流的数据库默认的事务隔离级别。\n\n**Repeatable Read（可重复读）** ：一个事务内部，前后多次的查询结果保持一致。回到隔离性的定义：一个事务的操作不受其他事务的影响。可重复读要解决的就是这个问题。在内部实现上，不管是读已提交还是可重复读，都需要借助 Readview 和 Undo 来实现，只是开启 Readview 的时间点有区别。Readview 和 Undo 也是 MySQL 实现 MVCC 的基础，更多细节在后续的文章单独介绍。\n\n**Serializable（串行化）** ：所有的事务，按顺序执行，任意时刻最多只有一个事务在执行。串行化从本质上来说完全限制了并发，在真实环境中一般不会使用。\n\n### 总结\n\n这篇文章主要从事务入手，简单的介绍了事务的基本特性和实现逻辑，引入了数据库系统中几个非常重要的概念：Undo、Redo、Readview、MVCC。这些概念会在后续的文章中详细说明。\n\n","source":"_posts/database/transaction-intro.md","raw":"---\ntitle: 初识事务\ndate: 2020-07-13 23:03:15\ntags:\n- 事务\ncategories: \n- 数据库\n\n---\n\n提到数据库，相信很多人第一个想到的就是事务，今天就从事务开始，对数据库的基本特征以及背后的实现逻辑进行一个简单的说明。\n\n<!-- more -->\n\n## 事务\n\n在写这篇文章的时候，笔者特意又重新查了下事务的定义。维基百科中关于事务的定义是：“事务是数据库系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成”。事务的概念本身并没有什么好展开的，事务之所以成为数据库系统最重要的特征之一，是因为事务的 ACID 属性。\n\n### ACID\n\n**Atomicity（原子性）** ：事务中的一组操作，要么全部成功，要么全部失败，不存在部分成功的情况。原子性的定义相对是比较直观的，可以类比编程语言中的原子操作，从这个角度上来说，事务是数据库系统处理用户操作的最小单位（自动提交模式可以看作是一条语句一个事务）。数据库系统内部主要通过 Undo（回滚日志、前进项）来保证原子性。每一个操作在执行时，都会记录下执行前的状态到 Undo 中，当事务需要回滚时，就可以通过 Undo 恢复到事务执行前的状态。\n\n**Consistency（一致性）** ：数据库总是从一个一致性状态转移到另一个一致性状态。一致性的定义比较模糊，什么叫从一个一致性状态转移到另一个一致性状态？其实这是由于中文的翻译往往只翻译了一半，关于一致性有一段非常最要的补充：\n\n```shell\nAny data written to the database must be valid according to all defined rules, \nincluding constraints, cascades, triggers, and any combination thereof. \n```\n\n总结起来就是：数据库在任意时刻的状态都必须符合所有的验证规则。一个简单的例子：表A记录了用户的账户余额，表B记录了用户的消费记录。从数据库的角度，A中的值与B中记录的和应该总是一个固定值，这就是一条验证规则。另外一个例子：表A存了用户信息，表B存了地址信息，表B中的地址被表A引用（外键），那么删除表B中的记录时，必须检查表A中的记录，这也是一条验证规则。关于一致性的判断，更多的需要与关系间的内在逻辑相结合。\n\n**Isolation（隔离性）** ：不同事务间的操作是相互隔离的，一个事务的操作不受其他事务的影响，也不会影响其他事务。关于隔离性，不同的数据库有不同的实现逻辑，按照可见性进行划分，可以分为四种不同的隔离级别。关于隔离级别，下个部分会进行详细介绍。\n\n**Durability（持久性）** ：一个事务只要提交成功就必须完整保存，不管发生任何软件或者硬件故障都必须保证数据不会丢失。持久性可以说是数据库系统的基础，在真实的业务场景中，数据丢失也往往是最无法容忍的。数据库系统主要通过 Redo（重做日志、后进项）来保证持久性。Redo 是一种典型的 WAL，每一个操作在执行时，都会记录这个操作的内容，并持久化到 Redo 中。当系统恢复时，如果发现之前的操作没有生效，可以通过 Redo 进行重做，保证已提交的操作有效。\n\n### 事务隔离级别\n\n前面提到，按照可见性进行划分，隔离性可以分为四种不同的事务隔离级别，下面逐一进行说明。\n\n**Read Uncommit（读未提交）** ：一个事务的修改可以立即被其它事务读取。读未提交的问题是会出现脏读，举例来说：事务1修改表A的数据，未提交，此时事务2读到了修改项，随后事务1进行了回滚。读未提交是最弱的一种隔离级别，在生产环境中，基本上不会使用。\n\n**Read Committed（读已提交）** ：一个事务的修改在事务提交后可以立即被其它事务读取到。读已提交避免了脏读的问题，这也是当前主流的数据库默认的事务隔离级别。\n\n**Repeatable Read（可重复读）** ：一个事务内部，前后多次的查询结果保持一致。回到隔离性的定义：一个事务的操作不受其他事务的影响。可重复读要解决的就是这个问题。在内部实现上，不管是读已提交还是可重复读，都需要借助 Readview 和 Undo 来实现，只是开启 Readview 的时间点有区别。Readview 和 Undo 也是 MySQL 实现 MVCC 的基础，更多细节在后续的文章单独介绍。\n\n**Serializable（串行化）** ：所有的事务，按顺序执行，任意时刻最多只有一个事务在执行。串行化从本质上来说完全限制了并发，在真实环境中一般不会使用。\n\n### 总结\n\n这篇文章主要从事务入手，简单的介绍了事务的基本特性和实现逻辑，引入了数据库系统中几个非常重要的概念：Undo、Redo、Readview、MVCC。这些概念会在后续的文章中详细说明。\n\n","slug":"database/transaction-intro","published":1,"updated":"2020-12-05T12:03:15.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4x00005gugmbewn2i5i","content":"<p>提到数据库，相信很多人第一个想到的就是事务，今天就从事务开始，对数据库的基本特征以及背后的实现逻辑进行一个简单的说明。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>在写这篇文章的时候，笔者特意又重新查了下事务的定义。维基百科中关于事务的定义是：“事务是数据库系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成”。事务的概念本身并没有什么好展开的，事务之所以成为数据库系统最重要的特征之一，是因为事务的 ACID 属性。</p>\n<h3 id=\"ACID\"><a href=\"#ACID\" class=\"headerlink\" title=\"ACID\"></a>ACID</h3><p><strong>Atomicity（原子性）</strong> ：事务中的一组操作，要么全部成功，要么全部失败，不存在部分成功的情况。原子性的定义相对是比较直观的，可以类比编程语言中的原子操作，从这个角度上来说，事务是数据库系统处理用户操作的最小单位（自动提交模式可以看作是一条语句一个事务）。数据库系统内部主要通过 Undo（回滚日志、前进项）来保证原子性。每一个操作在执行时，都会记录下执行前的状态到 Undo 中，当事务需要回滚时，就可以通过 Undo 恢复到事务执行前的状态。</p>\n<p><strong>Consistency（一致性）</strong> ：数据库总是从一个一致性状态转移到另一个一致性状态。一致性的定义比较模糊，什么叫从一个一致性状态转移到另一个一致性状态？其实这是由于中文的翻译往往只翻译了一半，关于一致性有一段非常最要的补充：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Any data written to the database must be valid according to all defined rules, </span><br><span class=\"line\">including constraints, cascades, triggers, and any combination thereof.</span><br></pre></td></tr></table></figure>\n\n<p>总结起来就是：数据库在任意时刻的状态都必须符合所有的验证规则。一个简单的例子：表A记录了用户的账户余额，表B记录了用户的消费记录。从数据库的角度，A中的值与B中记录的和应该总是一个固定值，这就是一条验证规则。另外一个例子：表A存了用户信息，表B存了地址信息，表B中的地址被表A引用（外键），那么删除表B中的记录时，必须检查表A中的记录，这也是一条验证规则。关于一致性的判断，更多的需要与关系间的内在逻辑相结合。</p>\n<p><strong>Isolation（隔离性）</strong> ：不同事务间的操作是相互隔离的，一个事务的操作不受其他事务的影响，也不会影响其他事务。关于隔离性，不同的数据库有不同的实现逻辑，按照可见性进行划分，可以分为四种不同的隔离级别。关于隔离级别，下个部分会进行详细介绍。</p>\n<p><strong>Durability（持久性）</strong> ：一个事务只要提交成功就必须完整保存，不管发生任何软件或者硬件故障都必须保证数据不会丢失。持久性可以说是数据库系统的基础，在真实的业务场景中，数据丢失也往往是最无法容忍的。数据库系统主要通过 Redo（重做日志、后进项）来保证持久性。Redo 是一种典型的 WAL，每一个操作在执行时，都会记录这个操作的内容，并持久化到 Redo 中。当系统恢复时，如果发现之前的操作没有生效，可以通过 Redo 进行重做，保证已提交的操作有效。</p>\n<h3 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h3><p>前面提到，按照可见性进行划分，隔离性可以分为四种不同的事务隔离级别，下面逐一进行说明。</p>\n<p><strong>Read Uncommit（读未提交）</strong> ：一个事务的修改可以立即被其它事务读取。读未提交的问题是会出现脏读，举例来说：事务1修改表A的数据，未提交，此时事务2读到了修改项，随后事务1进行了回滚。读未提交是最弱的一种隔离级别，在生产环境中，基本上不会使用。</p>\n<p><strong>Read Committed（读已提交）</strong> ：一个事务的修改在事务提交后可以立即被其它事务读取到。读已提交避免了脏读的问题，这也是当前主流的数据库默认的事务隔离级别。</p>\n<p><strong>Repeatable Read（可重复读）</strong> ：一个事务内部，前后多次的查询结果保持一致。回到隔离性的定义：一个事务的操作不受其他事务的影响。可重复读要解决的就是这个问题。在内部实现上，不管是读已提交还是可重复读，都需要借助 Readview 和 Undo 来实现，只是开启 Readview 的时间点有区别。Readview 和 Undo 也是 MySQL 实现 MVCC 的基础，更多细节在后续的文章单独介绍。</p>\n<p><strong>Serializable（串行化）</strong> ：所有的事务，按顺序执行，任意时刻最多只有一个事务在执行。串行化从本质上来说完全限制了并发，在真实环境中一般不会使用。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这篇文章主要从事务入手，简单的介绍了事务的基本特性和实现逻辑，引入了数据库系统中几个非常重要的概念：Undo、Redo、Readview、MVCC。这些概念会在后续的文章中详细说明。</p>\n","site":{"data":{}},"excerpt":"<p>提到数据库，相信很多人第一个想到的就是事务，今天就从事务开始，对数据库的基本特征以及背后的实现逻辑进行一个简单的说明。</p>","more":"<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>在写这篇文章的时候，笔者特意又重新查了下事务的定义。维基百科中关于事务的定义是：“事务是数据库系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成”。事务的概念本身并没有什么好展开的，事务之所以成为数据库系统最重要的特征之一，是因为事务的 ACID 属性。</p>\n<h3 id=\"ACID\"><a href=\"#ACID\" class=\"headerlink\" title=\"ACID\"></a>ACID</h3><p><strong>Atomicity（原子性）</strong> ：事务中的一组操作，要么全部成功，要么全部失败，不存在部分成功的情况。原子性的定义相对是比较直观的，可以类比编程语言中的原子操作，从这个角度上来说，事务是数据库系统处理用户操作的最小单位（自动提交模式可以看作是一条语句一个事务）。数据库系统内部主要通过 Undo（回滚日志、前进项）来保证原子性。每一个操作在执行时，都会记录下执行前的状态到 Undo 中，当事务需要回滚时，就可以通过 Undo 恢复到事务执行前的状态。</p>\n<p><strong>Consistency（一致性）</strong> ：数据库总是从一个一致性状态转移到另一个一致性状态。一致性的定义比较模糊，什么叫从一个一致性状态转移到另一个一致性状态？其实这是由于中文的翻译往往只翻译了一半，关于一致性有一段非常最要的补充：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Any data written to the database must be valid according to all defined rules, </span><br><span class=\"line\">including constraints, cascades, triggers, and any combination thereof.</span><br></pre></td></tr></table></figure>\n\n<p>总结起来就是：数据库在任意时刻的状态都必须符合所有的验证规则。一个简单的例子：表A记录了用户的账户余额，表B记录了用户的消费记录。从数据库的角度，A中的值与B中记录的和应该总是一个固定值，这就是一条验证规则。另外一个例子：表A存了用户信息，表B存了地址信息，表B中的地址被表A引用（外键），那么删除表B中的记录时，必须检查表A中的记录，这也是一条验证规则。关于一致性的判断，更多的需要与关系间的内在逻辑相结合。</p>\n<p><strong>Isolation（隔离性）</strong> ：不同事务间的操作是相互隔离的，一个事务的操作不受其他事务的影响，也不会影响其他事务。关于隔离性，不同的数据库有不同的实现逻辑，按照可见性进行划分，可以分为四种不同的隔离级别。关于隔离级别，下个部分会进行详细介绍。</p>\n<p><strong>Durability（持久性）</strong> ：一个事务只要提交成功就必须完整保存，不管发生任何软件或者硬件故障都必须保证数据不会丢失。持久性可以说是数据库系统的基础，在真实的业务场景中，数据丢失也往往是最无法容忍的。数据库系统主要通过 Redo（重做日志、后进项）来保证持久性。Redo 是一种典型的 WAL，每一个操作在执行时，都会记录这个操作的内容，并持久化到 Redo 中。当系统恢复时，如果发现之前的操作没有生效，可以通过 Redo 进行重做，保证已提交的操作有效。</p>\n<h3 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h3><p>前面提到，按照可见性进行划分，隔离性可以分为四种不同的事务隔离级别，下面逐一进行说明。</p>\n<p><strong>Read Uncommit（读未提交）</strong> ：一个事务的修改可以立即被其它事务读取。读未提交的问题是会出现脏读，举例来说：事务1修改表A的数据，未提交，此时事务2读到了修改项，随后事务1进行了回滚。读未提交是最弱的一种隔离级别，在生产环境中，基本上不会使用。</p>\n<p><strong>Read Committed（读已提交）</strong> ：一个事务的修改在事务提交后可以立即被其它事务读取到。读已提交避免了脏读的问题，这也是当前主流的数据库默认的事务隔离级别。</p>\n<p><strong>Repeatable Read（可重复读）</strong> ：一个事务内部，前后多次的查询结果保持一致。回到隔离性的定义：一个事务的操作不受其他事务的影响。可重复读要解决的就是这个问题。在内部实现上，不管是读已提交还是可重复读，都需要借助 Readview 和 Undo 来实现，只是开启 Readview 的时间点有区别。Readview 和 Undo 也是 MySQL 实现 MVCC 的基础，更多细节在后续的文章单独介绍。</p>\n<p><strong>Serializable（串行化）</strong> ：所有的事务，按顺序执行，任意时刻最多只有一个事务在执行。串行化从本质上来说完全限制了并发，在真实环境中一般不会使用。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这篇文章主要从事务入手，简单的介绍了事务的基本特性和实现逻辑，引入了数据库系统中几个非常重要的概念：Undo、Redo、Readview、MVCC。这些概念会在后续的文章中详细说明。</p>"},{"title":"MySQL 中几种锁的使用","date":"2020-07-17T14:49:43.000Z","_content":"\nMySQL 中常用的几种锁包括：mysql_rwlock_t、mysql_mutex_t、mysql_cond_t，本文结合 MySQL 源码对各种锁的使用做一个简单的总结。\n\n<!-- more -->\n\n## mysql_rwlock_t\n\n### 数据结构\n\n```c++\n/**\n  Type of an instrumented rwlock.\n  @c mysql_rwlock_t is a drop-in replacement for @c pthread_rwlock_t.\n  @sa mysql_rwlock_init\n  @sa mysql_rwlock_rdlock\n  @sa mysql_rwlock_tryrdlock\n  @sa mysql_rwlock_wrlock\n  @sa mysql_rwlock_trywrlock\n  @sa mysql_rwlock_unlock\n  @sa mysql_rwlock_destroy\n*/\ntypedef struct st_mysql_rwlock mysql_rwlock_t;\n\nstruct st_mysql_rwlock\n{\n  /** The real rwlock */\n  native_rw_lock_t m_rwlock;\n  /**\n    The instrumentation hook.\n    Note that this hook is not conditionally defined,\n    for binary compatibility of the @c mysql_rwlock_t interface.\n  */\n  struct PSI_rwlock *m_psi;\n};\n\ntypedef pthread_rwlock_t native_rw_lock_t;\n```\n\n### 使用方式\n\n```c++\nPSI_rwlock_key key_rwlock_LOCK_xxx;\nmysql_rwlock_t m_lock;\n\nmysql_rwlock_init(key_rwlock_LOCK_xxx, &m_lock);\n\nmysql_rwlock_rdlock(&m_lock);\nmysql_rwlock_wrlock(&m_lock);\nmysql_rwlock_trywrlock(&m_lock);\nmysql_rwlock_unlock(&m_lock);\n\nmysql_rwlock_destroy(&m_lock);\n```\n\n### 说明\n\nmysql_rwlock_t 基本上可以看作是对 pthread_rwlock_t 的一个封装，pthread_rwlock_t 是读写锁，同时可以有多个线程获得读锁，同时只允许有一个线程获得写锁。其他线程在等待锁的时候同样会进入睡眠。读写锁在互斥锁的基础上，允许多个线程读，在某些场景下能提高性能。\n\n## mysql_mutex_t\n\n### 数据结构\n\n```c++\n/**\n  Type of an instrumented mutex.\n  @c mysql_mutex_t is a drop-in replacement for @c my_mutex_t.\n  @sa mysql_mutex_assert_owner\n  @sa mysql_mutex_assert_not_owner\n  @sa mysql_mutex_init\n  @sa mysql_mutex_lock\n  @sa mysql_mutex_unlock\n  @sa mysql_mutex_destroy\n*/\ntypedef struct st_mysql_mutex mysql_mutex_t;\n\nstruct st_mysql_mutex\n{\n  /** The real mutex. */\n  my_mutex_t m_mutex;\n  /**\n    The instrumentation hook.\n    Note that this hook is not conditionally defined,\n    for binary compatibility of the @c mysql_mutex_t interface.\n  */\n  struct PSI_mutex *m_psi;\n};\n\ntypedef native_mutex_t my_mutex_t;\n\ntypedef pthread_mutex_t native_mutex_t;\n```\n\n### 使用方式\n\n```c++\nPSI_mutex_key key_LOCK_xxx;\nmysql_mutex_t m_lock;\n\nmysql_mutex_init(key_LOCK_xxx, &m_lock, NULL);\n\nmysql_mutex_lock(&m_lock);\nmysql_mutex_unlock(&m_lock);\n\nmysql_mutex_destroy(&m_lock);\n```\n\n### 使用技巧\n\n1. Thread 如果已经获得了 mutex， 那么如果再次 lock 的话，会产生死锁，所以 MySQL 内部大量的 mutex_owner 判断逻辑（ mysql_mutex_assert_owner(&m_mutex) ）；\n2. 与1类似，可以在利用一个计数值来统计当前正在等到锁的线程个数，锁 owner 可以根据此计数值来判断是否需要释放锁。\n\n### 说明\n\nmysql_mutex_t 基本上可以看作是对 pthread_mutex_t 的一个封装，pthread_mutex_t 是互斥锁，同一瞬间只能有一个线程能够获取锁，其他线程在等待获取锁的时候会进入休眠状态。因此 pthread_mutex_t 消耗的 CPU 资源很小，但是性能不高，因为会引起线程切换。\n\n## mysql_cond_t\n\n### 数据结构\n\n```c++\n/**\n  Type of an instrumented condition.\n  @c mysql_cond_t is a drop-in replacement for @c pthread_cond_t.\n  @sa mysql_cond_init\n  @sa mysql_cond_wait\n  @sa mysql_cond_timedwait\n  @sa mysql_cond_signal\n  @sa mysql_cond_broadcast\n  @sa mysql_cond_destroy\n*/\ntypedef struct st_mysql_cond mysql_cond_t;\n\nstruct st_mysql_cond\n{\n  /** The real condition */\n  pthread_cond_t m_cond;\n  /**\n    The instrumentation hook.\n    Note that this hook is not conditionally defined,\n    for binary compatibility of the @c mysql_cond_t interface.\n  */\n  struct PSI_cond *m_psi;\n};\n```\n\n### 使用方式\n\n```c++\nPSI_cond_key key_COND_xxx;\nmysql_cond_t m_cond;\n\nmysql_cond_init(key_COND_xxx, &m_cond);\n\n// mysql_cond_t 需要与 mysql_mutex_t 配合使用\nstruct timespec abs_timeout;\nmysql_cond_timedwait(&m_cond, &m_mutex, &abs_timeout);\n\nmysql_cond_signal(&m_cond);\nmysql_cond_broadcast(&m_cond);\n\nmysql_cond_destroy(&m_cond);\n```\n\n## 补充\n\n除了 pthread_rwlock_t 和 pthread_mutex_t 之外，还有一个常用的锁 pthread_spinlock_t。pthread_spinlock_t 是自旋锁，同一瞬间也只能有一个线程能够获取锁，不同的是，其他线程在等待获取锁的过程中并不进入睡眠状态，而是在 CPU 上进入自旋等待。自旋锁的性能很高，但是只适合对很小的代码段加锁（或短期持有的锁），自旋锁对 CPU 的占用相对较高。","source":"_posts/clang/cplusplus-lock.md","raw":"---\ntitle: MySQL 中几种锁的使用\ndate: 2020-07-17 22:49:43\ntags:\n- 锁\ncategories: \n- C/C++\n\n---\n\nMySQL 中常用的几种锁包括：mysql_rwlock_t、mysql_mutex_t、mysql_cond_t，本文结合 MySQL 源码对各种锁的使用做一个简单的总结。\n\n<!-- more -->\n\n## mysql_rwlock_t\n\n### 数据结构\n\n```c++\n/**\n  Type of an instrumented rwlock.\n  @c mysql_rwlock_t is a drop-in replacement for @c pthread_rwlock_t.\n  @sa mysql_rwlock_init\n  @sa mysql_rwlock_rdlock\n  @sa mysql_rwlock_tryrdlock\n  @sa mysql_rwlock_wrlock\n  @sa mysql_rwlock_trywrlock\n  @sa mysql_rwlock_unlock\n  @sa mysql_rwlock_destroy\n*/\ntypedef struct st_mysql_rwlock mysql_rwlock_t;\n\nstruct st_mysql_rwlock\n{\n  /** The real rwlock */\n  native_rw_lock_t m_rwlock;\n  /**\n    The instrumentation hook.\n    Note that this hook is not conditionally defined,\n    for binary compatibility of the @c mysql_rwlock_t interface.\n  */\n  struct PSI_rwlock *m_psi;\n};\n\ntypedef pthread_rwlock_t native_rw_lock_t;\n```\n\n### 使用方式\n\n```c++\nPSI_rwlock_key key_rwlock_LOCK_xxx;\nmysql_rwlock_t m_lock;\n\nmysql_rwlock_init(key_rwlock_LOCK_xxx, &m_lock);\n\nmysql_rwlock_rdlock(&m_lock);\nmysql_rwlock_wrlock(&m_lock);\nmysql_rwlock_trywrlock(&m_lock);\nmysql_rwlock_unlock(&m_lock);\n\nmysql_rwlock_destroy(&m_lock);\n```\n\n### 说明\n\nmysql_rwlock_t 基本上可以看作是对 pthread_rwlock_t 的一个封装，pthread_rwlock_t 是读写锁，同时可以有多个线程获得读锁，同时只允许有一个线程获得写锁。其他线程在等待锁的时候同样会进入睡眠。读写锁在互斥锁的基础上，允许多个线程读，在某些场景下能提高性能。\n\n## mysql_mutex_t\n\n### 数据结构\n\n```c++\n/**\n  Type of an instrumented mutex.\n  @c mysql_mutex_t is a drop-in replacement for @c my_mutex_t.\n  @sa mysql_mutex_assert_owner\n  @sa mysql_mutex_assert_not_owner\n  @sa mysql_mutex_init\n  @sa mysql_mutex_lock\n  @sa mysql_mutex_unlock\n  @sa mysql_mutex_destroy\n*/\ntypedef struct st_mysql_mutex mysql_mutex_t;\n\nstruct st_mysql_mutex\n{\n  /** The real mutex. */\n  my_mutex_t m_mutex;\n  /**\n    The instrumentation hook.\n    Note that this hook is not conditionally defined,\n    for binary compatibility of the @c mysql_mutex_t interface.\n  */\n  struct PSI_mutex *m_psi;\n};\n\ntypedef native_mutex_t my_mutex_t;\n\ntypedef pthread_mutex_t native_mutex_t;\n```\n\n### 使用方式\n\n```c++\nPSI_mutex_key key_LOCK_xxx;\nmysql_mutex_t m_lock;\n\nmysql_mutex_init(key_LOCK_xxx, &m_lock, NULL);\n\nmysql_mutex_lock(&m_lock);\nmysql_mutex_unlock(&m_lock);\n\nmysql_mutex_destroy(&m_lock);\n```\n\n### 使用技巧\n\n1. Thread 如果已经获得了 mutex， 那么如果再次 lock 的话，会产生死锁，所以 MySQL 内部大量的 mutex_owner 判断逻辑（ mysql_mutex_assert_owner(&m_mutex) ）；\n2. 与1类似，可以在利用一个计数值来统计当前正在等到锁的线程个数，锁 owner 可以根据此计数值来判断是否需要释放锁。\n\n### 说明\n\nmysql_mutex_t 基本上可以看作是对 pthread_mutex_t 的一个封装，pthread_mutex_t 是互斥锁，同一瞬间只能有一个线程能够获取锁，其他线程在等待获取锁的时候会进入休眠状态。因此 pthread_mutex_t 消耗的 CPU 资源很小，但是性能不高，因为会引起线程切换。\n\n## mysql_cond_t\n\n### 数据结构\n\n```c++\n/**\n  Type of an instrumented condition.\n  @c mysql_cond_t is a drop-in replacement for @c pthread_cond_t.\n  @sa mysql_cond_init\n  @sa mysql_cond_wait\n  @sa mysql_cond_timedwait\n  @sa mysql_cond_signal\n  @sa mysql_cond_broadcast\n  @sa mysql_cond_destroy\n*/\ntypedef struct st_mysql_cond mysql_cond_t;\n\nstruct st_mysql_cond\n{\n  /** The real condition */\n  pthread_cond_t m_cond;\n  /**\n    The instrumentation hook.\n    Note that this hook is not conditionally defined,\n    for binary compatibility of the @c mysql_cond_t interface.\n  */\n  struct PSI_cond *m_psi;\n};\n```\n\n### 使用方式\n\n```c++\nPSI_cond_key key_COND_xxx;\nmysql_cond_t m_cond;\n\nmysql_cond_init(key_COND_xxx, &m_cond);\n\n// mysql_cond_t 需要与 mysql_mutex_t 配合使用\nstruct timespec abs_timeout;\nmysql_cond_timedwait(&m_cond, &m_mutex, &abs_timeout);\n\nmysql_cond_signal(&m_cond);\nmysql_cond_broadcast(&m_cond);\n\nmysql_cond_destroy(&m_cond);\n```\n\n## 补充\n\n除了 pthread_rwlock_t 和 pthread_mutex_t 之外，还有一个常用的锁 pthread_spinlock_t。pthread_spinlock_t 是自旋锁，同一瞬间也只能有一个线程能够获取锁，不同的是，其他线程在等待获取锁的过程中并不进入睡眠状态，而是在 CPU 上进入自旋等待。自旋锁的性能很高，但是只适合对很小的代码段加锁（或短期持有的锁），自旋锁对 CPU 的占用相对较高。","slug":"clang/cplusplus-lock","published":1,"updated":"2020-12-05T12:02:46.338Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4x30007gugmhdls02hz","content":"<p>MySQL 中常用的几种锁包括：mysql_rwlock_t、mysql_mutex_t、mysql_cond_t，本文结合 MySQL 源码对各种锁的使用做一个简单的总结。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"mysql-rwlock-t\"><a href=\"#mysql-rwlock-t\" class=\"headerlink\" title=\"mysql_rwlock_t\"></a>mysql_rwlock_t</h2><h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  Type of an instrumented rwlock.</span></span><br><span class=\"line\"><span class=\"comment\">  @c mysql_rwlock_t is a drop-in replacement for @c pthread_rwlock_t.</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_init</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_rdlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_tryrdlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_wrlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_trywrlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_unlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_destroy</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_rwlock</span> <span class=\"title\">mysql_rwlock_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_rwlock</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/** The real rwlock */</span></span><br><span class=\"line\">  <span class=\"keyword\">native_rw_lock_t</span> m_rwlock;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    The instrumentation hook.</span></span><br><span class=\"line\"><span class=\"comment\">    Note that this hook is not conditionally defined,</span></span><br><span class=\"line\"><span class=\"comment\">    for binary compatibility of the @c mysql_rwlock_t interface.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PSI_rwlock</span> *<span class=\"title\">m_psi</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">pthread_rwlock_t</span> <span class=\"keyword\">native_rw_lock_t</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PSI_rwlock_key key_rwlock_LOCK_xxx;</span><br><span class=\"line\"><span class=\"keyword\">mysql_rwlock_t</span> m_lock;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_rwlock_init(key_rwlock_LOCK_xxx, &amp;m_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_rwlock_rdlock(&amp;m_lock);</span><br><span class=\"line\">mysql_rwlock_wrlock(&amp;m_lock);</span><br><span class=\"line\">mysql_rwlock_trywrlock(&amp;m_lock);</span><br><span class=\"line\">mysql_rwlock_unlock(&amp;m_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_rwlock_destroy(&amp;m_lock);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>mysql_rwlock_t 基本上可以看作是对 pthread_rwlock_t 的一个封装，pthread_rwlock_t 是读写锁，同时可以有多个线程获得读锁，同时只允许有一个线程获得写锁。其他线程在等待锁的时候同样会进入睡眠。读写锁在互斥锁的基础上，允许多个线程读，在某些场景下能提高性能。</p>\n<h2 id=\"mysql-mutex-t\"><a href=\"#mysql-mutex-t\" class=\"headerlink\" title=\"mysql_mutex_t\"></a>mysql_mutex_t</h2><h3 id=\"数据结构-1\"><a href=\"#数据结构-1\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  Type of an instrumented mutex.</span></span><br><span class=\"line\"><span class=\"comment\">  @c mysql_mutex_t is a drop-in replacement for @c my_mutex_t.</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_assert_owner</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_assert_not_owner</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_init</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_lock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_unlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_destroy</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_mutex</span> <span class=\"title\">mysql_mutex_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_mutex</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/** The real mutex. */</span></span><br><span class=\"line\">  <span class=\"keyword\">my_mutex_t</span> m_mutex;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    The instrumentation hook.</span></span><br><span class=\"line\"><span class=\"comment\">    Note that this hook is not conditionally defined,</span></span><br><span class=\"line\"><span class=\"comment\">    for binary compatibility of the @c mysql_mutex_t interface.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PSI_mutex</span> *<span class=\"title\">m_psi</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">native_mutex_t</span> <span class=\"keyword\">my_mutex_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">pthread_mutex_t</span> <span class=\"keyword\">native_mutex_t</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用方式-1\"><a href=\"#使用方式-1\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PSI_mutex_key key_LOCK_xxx;</span><br><span class=\"line\"><span class=\"keyword\">mysql_mutex_t</span> m_lock;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_mutex_init(key_LOCK_xxx, &amp;m_lock, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_mutex_lock(&amp;m_lock);</span><br><span class=\"line\">mysql_mutex_unlock(&amp;m_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_mutex_destroy(&amp;m_lock);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用技巧\"><a href=\"#使用技巧\" class=\"headerlink\" title=\"使用技巧\"></a>使用技巧</h3><ol>\n<li>Thread 如果已经获得了 mutex， 那么如果再次 lock 的话，会产生死锁，所以 MySQL 内部大量的 mutex_owner 判断逻辑（ mysql_mutex_assert_owner(&amp;m_mutex) ）；</li>\n<li>与1类似，可以在利用一个计数值来统计当前正在等到锁的线程个数，锁 owner 可以根据此计数值来判断是否需要释放锁。</li>\n</ol>\n<h3 id=\"说明-1\"><a href=\"#说明-1\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>mysql_mutex_t 基本上可以看作是对 pthread_mutex_t 的一个封装，pthread_mutex_t 是互斥锁，同一瞬间只能有一个线程能够获取锁，其他线程在等待获取锁的时候会进入休眠状态。因此 pthread_mutex_t 消耗的 CPU 资源很小，但是性能不高，因为会引起线程切换。</p>\n<h2 id=\"mysql-cond-t\"><a href=\"#mysql-cond-t\" class=\"headerlink\" title=\"mysql_cond_t\"></a>mysql_cond_t</h2><h3 id=\"数据结构-2\"><a href=\"#数据结构-2\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  Type of an instrumented condition.</span></span><br><span class=\"line\"><span class=\"comment\">  @c mysql_cond_t is a drop-in replacement for @c pthread_cond_t.</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_init</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_wait</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_timedwait</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_signal</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_broadcast</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_destroy</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_cond</span> <span class=\"title\">mysql_cond_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_cond</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/** The real condition */</span></span><br><span class=\"line\">  <span class=\"keyword\">pthread_cond_t</span> m_cond;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    The instrumentation hook.</span></span><br><span class=\"line\"><span class=\"comment\">    Note that this hook is not conditionally defined,</span></span><br><span class=\"line\"><span class=\"comment\">    for binary compatibility of the @c mysql_cond_t interface.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PSI_cond</span> *<span class=\"title\">m_psi</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用方式-2\"><a href=\"#使用方式-2\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PSI_cond_key key_COND_xxx;</span><br><span class=\"line\"><span class=\"keyword\">mysql_cond_t</span> m_cond;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_cond_init(key_COND_xxx, &amp;m_cond);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// mysql_cond_t 需要与 mysql_mutex_t 配合使用</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timespec</span> <span class=\"title\">abs_timeout</span>;</span></span><br><span class=\"line\">mysql_cond_timedwait(&amp;m_cond, &amp;m_mutex, &amp;abs_timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_cond_signal(&amp;m_cond);</span><br><span class=\"line\">mysql_cond_broadcast(&amp;m_cond);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_cond_destroy(&amp;m_cond);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><p>除了 pthread_rwlock_t 和 pthread_mutex_t 之外，还有一个常用的锁 pthread_spinlock_t。pthread_spinlock_t 是自旋锁，同一瞬间也只能有一个线程能够获取锁，不同的是，其他线程在等待获取锁的过程中并不进入睡眠状态，而是在 CPU 上进入自旋等待。自旋锁的性能很高，但是只适合对很小的代码段加锁（或短期持有的锁），自旋锁对 CPU 的占用相对较高。</p>\n","site":{"data":{}},"excerpt":"<p>MySQL 中常用的几种锁包括：mysql_rwlock_t、mysql_mutex_t、mysql_cond_t，本文结合 MySQL 源码对各种锁的使用做一个简单的总结。</p>","more":"<h2 id=\"mysql-rwlock-t\"><a href=\"#mysql-rwlock-t\" class=\"headerlink\" title=\"mysql_rwlock_t\"></a>mysql_rwlock_t</h2><h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  Type of an instrumented rwlock.</span></span><br><span class=\"line\"><span class=\"comment\">  @c mysql_rwlock_t is a drop-in replacement for @c pthread_rwlock_t.</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_init</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_rdlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_tryrdlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_wrlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_trywrlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_unlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_destroy</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_rwlock</span> <span class=\"title\">mysql_rwlock_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_rwlock</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/** The real rwlock */</span></span><br><span class=\"line\">  <span class=\"keyword\">native_rw_lock_t</span> m_rwlock;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    The instrumentation hook.</span></span><br><span class=\"line\"><span class=\"comment\">    Note that this hook is not conditionally defined,</span></span><br><span class=\"line\"><span class=\"comment\">    for binary compatibility of the @c mysql_rwlock_t interface.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PSI_rwlock</span> *<span class=\"title\">m_psi</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">pthread_rwlock_t</span> <span class=\"keyword\">native_rw_lock_t</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PSI_rwlock_key key_rwlock_LOCK_xxx;</span><br><span class=\"line\"><span class=\"keyword\">mysql_rwlock_t</span> m_lock;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_rwlock_init(key_rwlock_LOCK_xxx, &amp;m_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_rwlock_rdlock(&amp;m_lock);</span><br><span class=\"line\">mysql_rwlock_wrlock(&amp;m_lock);</span><br><span class=\"line\">mysql_rwlock_trywrlock(&amp;m_lock);</span><br><span class=\"line\">mysql_rwlock_unlock(&amp;m_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_rwlock_destroy(&amp;m_lock);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>mysql_rwlock_t 基本上可以看作是对 pthread_rwlock_t 的一个封装，pthread_rwlock_t 是读写锁，同时可以有多个线程获得读锁，同时只允许有一个线程获得写锁。其他线程在等待锁的时候同样会进入睡眠。读写锁在互斥锁的基础上，允许多个线程读，在某些场景下能提高性能。</p>\n<h2 id=\"mysql-mutex-t\"><a href=\"#mysql-mutex-t\" class=\"headerlink\" title=\"mysql_mutex_t\"></a>mysql_mutex_t</h2><h3 id=\"数据结构-1\"><a href=\"#数据结构-1\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  Type of an instrumented mutex.</span></span><br><span class=\"line\"><span class=\"comment\">  @c mysql_mutex_t is a drop-in replacement for @c my_mutex_t.</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_assert_owner</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_assert_not_owner</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_init</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_lock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_unlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_destroy</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_mutex</span> <span class=\"title\">mysql_mutex_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_mutex</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/** The real mutex. */</span></span><br><span class=\"line\">  <span class=\"keyword\">my_mutex_t</span> m_mutex;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    The instrumentation hook.</span></span><br><span class=\"line\"><span class=\"comment\">    Note that this hook is not conditionally defined,</span></span><br><span class=\"line\"><span class=\"comment\">    for binary compatibility of the @c mysql_mutex_t interface.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PSI_mutex</span> *<span class=\"title\">m_psi</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">native_mutex_t</span> <span class=\"keyword\">my_mutex_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">pthread_mutex_t</span> <span class=\"keyword\">native_mutex_t</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用方式-1\"><a href=\"#使用方式-1\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PSI_mutex_key key_LOCK_xxx;</span><br><span class=\"line\"><span class=\"keyword\">mysql_mutex_t</span> m_lock;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_mutex_init(key_LOCK_xxx, &amp;m_lock, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_mutex_lock(&amp;m_lock);</span><br><span class=\"line\">mysql_mutex_unlock(&amp;m_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_mutex_destroy(&amp;m_lock);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用技巧\"><a href=\"#使用技巧\" class=\"headerlink\" title=\"使用技巧\"></a>使用技巧</h3><ol>\n<li>Thread 如果已经获得了 mutex， 那么如果再次 lock 的话，会产生死锁，所以 MySQL 内部大量的 mutex_owner 判断逻辑（ mysql_mutex_assert_owner(&amp;m_mutex) ）；</li>\n<li>与1类似，可以在利用一个计数值来统计当前正在等到锁的线程个数，锁 owner 可以根据此计数值来判断是否需要释放锁。</li>\n</ol>\n<h3 id=\"说明-1\"><a href=\"#说明-1\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>mysql_mutex_t 基本上可以看作是对 pthread_mutex_t 的一个封装，pthread_mutex_t 是互斥锁，同一瞬间只能有一个线程能够获取锁，其他线程在等待获取锁的时候会进入休眠状态。因此 pthread_mutex_t 消耗的 CPU 资源很小，但是性能不高，因为会引起线程切换。</p>\n<h2 id=\"mysql-cond-t\"><a href=\"#mysql-cond-t\" class=\"headerlink\" title=\"mysql_cond_t\"></a>mysql_cond_t</h2><h3 id=\"数据结构-2\"><a href=\"#数据结构-2\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  Type of an instrumented condition.</span></span><br><span class=\"line\"><span class=\"comment\">  @c mysql_cond_t is a drop-in replacement for @c pthread_cond_t.</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_init</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_wait</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_timedwait</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_signal</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_broadcast</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_destroy</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_cond</span> <span class=\"title\">mysql_cond_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_cond</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/** The real condition */</span></span><br><span class=\"line\">  <span class=\"keyword\">pthread_cond_t</span> m_cond;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    The instrumentation hook.</span></span><br><span class=\"line\"><span class=\"comment\">    Note that this hook is not conditionally defined,</span></span><br><span class=\"line\"><span class=\"comment\">    for binary compatibility of the @c mysql_cond_t interface.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PSI_cond</span> *<span class=\"title\">m_psi</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用方式-2\"><a href=\"#使用方式-2\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PSI_cond_key key_COND_xxx;</span><br><span class=\"line\"><span class=\"keyword\">mysql_cond_t</span> m_cond;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_cond_init(key_COND_xxx, &amp;m_cond);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// mysql_cond_t 需要与 mysql_mutex_t 配合使用</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timespec</span> <span class=\"title\">abs_timeout</span>;</span></span><br><span class=\"line\">mysql_cond_timedwait(&amp;m_cond, &amp;m_mutex, &amp;abs_timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_cond_signal(&amp;m_cond);</span><br><span class=\"line\">mysql_cond_broadcast(&amp;m_cond);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_cond_destroy(&amp;m_cond);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><p>除了 pthread_rwlock_t 和 pthread_mutex_t 之外，还有一个常用的锁 pthread_spinlock_t。pthread_spinlock_t 是自旋锁，同一瞬间也只能有一个线程能够获取锁，不同的是，其他线程在等待获取锁的过程中并不进入睡眠状态，而是在 CPU 上进入自旋等待。自旋锁的性能很高，但是只适合对很小的代码段加锁（或短期持有的锁），自旋锁对 CPU 的占用相对较高。</p>"},{"title":"MySQL LF_HASH","date":"2020-07-17T15:07:18.000Z","_content":"\nMySQL 中有很多实现非常好的数据结构，本文要介绍的 LF_HASH 就是其中一个。\n\n<!-- more -->\n\n## 要解决的问题\n\nLF_HASH 主要解决的是以下两个问题：\n\n1. HASH 结构并发修改的问题，特别是查询、插入、删除并发操作时，如何保证当前查询到的元素不会被其它线程删除？\n2. 扩容问题，如何保证在数据元素增多时，有效的进行扩容，减少数据的移动工作？\n\n第一个问题，解决办法是引入 pin 的概念，通过 pin 来记录正在被使用的数据元素，防止被其它线程删除（和 Hazard Pointer 的异同点？）\n\n第二个问题，解决办法是先取 key 的 hash 值，然后对 hash 的二进制进行 reverse，将高位相同的元素放入同一个 bucket。扩容时，只需要在单个 bucket 内插入一个新的锚点，不需要进行任何的数据移动。\n\n> https://kernelmaker.github.io/MySQL_lf_allocator\n>\n> https://baotiao.github.io/2019/09/15/mysql-lf_hash/\n\n## 不解决的问题\n\nLF_HASH 只保证 HASH 结构的线程安全，并不保证单个元素不被修改，单个数据元素还是要通过单独的 lock 来进行保护。\n\n## 使用指南\n\nLF_HASH 的使用和普通 HASH 稍有区别，主要包括以下几点：\n\n### 初始化 LF_HASH\n\n```c++\n/*\n  Initializes lf_hash, the arguments are compatible with hash_init\n\n  @note element_size sets both the size of allocated memory block for\n  lf_alloc and a size of memcpy'ed block size in lf_hash_insert. Typically\n  they are the same, indeed. But LF_HASH::element_size can be decreased\n  after lf_hash_init, and then lf_alloc will allocate larger block that\n  lf_hash_insert will copy over. It is desireable if part of the element\n  is expensive to initialize - for example if there is a mutex or\n  DYNAMIC_ARRAY. In this case they should be initialize in the\n  LF_ALLOCATOR::constructor, and lf_hash_insert should not overwrite them.\n  See wt_init() for example.\n  As an alternative to using the above trick with decreasing\n  LF_HASH::element_size one can provide an \"initialize\" hook that will finish\n  initialization of object provided by LF_ALLOCATOR and set element key from\n  object passed as parameter to lf_hash_insert instead of doing simple memcpy.\n*/\nvoid lf_hash_init2(LF_HASH *hash, uint element_size, uint flags,\n                   uint key_offset, uint key_length,\n                   hash_get_key_function get_key, CHARSET_INFO *charset,\n                   lf_hash_func *hash_function, lf_allocator_func *ctor,\n                   lf_allocator_func *dtor, lf_hash_init_func *init) {\n  lf_alloc_init2(&hash->alloc, sizeof(LF_SLIST) + element_size,\n                 offsetof(LF_SLIST, key), ctor, dtor);\n  lf_dynarray_init(&hash->array, sizeof(LF_SLIST *));\n  hash->size = 1;\n  hash->count = 0;\n  hash->element_size = element_size;\n  hash->flags = flags;\n  hash->charset = charset ? charset : &my_charset_bin;\n  hash->key_offset = key_offset;\n  hash->key_length = key_length;\n  hash->get_key = get_key;\n  hash->hash_function = hash_function ? hash_function : cset_hash_sort_adapter;\n  hash->initialize = init;\n  DBUG_ASSERT(get_key ? !key_offset && !key_length : key_length);\n}\n\nvoid lf_hash_destroy(LF_HASH *hash) {\n  LF_SLIST *el, **head = (LF_SLIST **)lf_dynarray_value(&hash->array, 0);\n\n  if (unlikely(!head)) {\n    return;\n  }\n  el = *head;\n\n  while (el) {\n    LF_SLIST *next = el->link;\n    if (el->hashnr & 1) {\n      lf_alloc_direct_free(&hash->alloc, el); /* normal node */\n    } else {\n      my_free(el); /* dummy node */\n    }\n    el = (LF_SLIST *)next;\n  }\n  lf_alloc_destroy(&hash->alloc);\n  lf_dynarray_destroy(&hash->array);\n}\n```\n\n初始化时需要定义 key 的获取方式，构造&析构方式，插入方法等。其中构造&析构方式，插入方法可以缺省；\n\n### 查询 LF_HASH\n\n```c++\nlf_hash_get_pins(&m_hash);\n\nlf_hash_search(&m_hash, pins, key, length);\n\nlf_hash_search_unpin(pins);\n\nlf_hash_put_pins(pins);\n```\n\n注意，查询的时候必须用 pins&unpin 进行保护，不论查询的结果如何。为什么要这样处理呢？这里涉及到一个对“无锁”概念的理解问题。无锁 HASH 中的无锁到底指的是什么？\n\n无锁指的是：HASH 中的数据是安全的，特别指删除过程是安全的，查询的线程不会被删除的线程影响。如果做到安全呢？pin 在这个过程中起到了关键作用，LF_HASH 在删除时，不是立即删除，而是放入到内部的待删除队列，此时删除操作返回成功，再次查询也无法查询到结果。但是，已经 pin 住的查询依旧有效，数据的访问也正常，直到 unpin 操作完成，删除操作才会真正执行。\n\n### 插入 LF_HASH\n\n```c++\nlf_hash_get_pins(&m_hash);\n\nlf_hash_insert(&m_hash, pins, item);\n\nlf_hash_put_pins(pins); \n```\n\n###  删除 LF_HASH\n\n```c++\nlf_hash_get_pins(&m_hash);\n\nlf_hash_delete(&m_hash, pins, key, length);\n\nlf_hash_put_pins(pins);\n```\n\n## 注意事项\n\nLF_HASH 的使用过程中需要注意：由于 LF_HASH 的删除操作“同步返回，异步删除”的特点，HASH 中管理的对象最好利用一个状态位进行标记，删除前先维护状态位的值。\n\n\n\n","source":"_posts/clang/lf_hash.md","raw":"---\ntitle: MySQL LF_HASH\ndate: 2020-07-17 23:07:18\ntags:\n- LF_HASH\ncategories: \n- C/C++\n\n---\n\nMySQL 中有很多实现非常好的数据结构，本文要介绍的 LF_HASH 就是其中一个。\n\n<!-- more -->\n\n## 要解决的问题\n\nLF_HASH 主要解决的是以下两个问题：\n\n1. HASH 结构并发修改的问题，特别是查询、插入、删除并发操作时，如何保证当前查询到的元素不会被其它线程删除？\n2. 扩容问题，如何保证在数据元素增多时，有效的进行扩容，减少数据的移动工作？\n\n第一个问题，解决办法是引入 pin 的概念，通过 pin 来记录正在被使用的数据元素，防止被其它线程删除（和 Hazard Pointer 的异同点？）\n\n第二个问题，解决办法是先取 key 的 hash 值，然后对 hash 的二进制进行 reverse，将高位相同的元素放入同一个 bucket。扩容时，只需要在单个 bucket 内插入一个新的锚点，不需要进行任何的数据移动。\n\n> https://kernelmaker.github.io/MySQL_lf_allocator\n>\n> https://baotiao.github.io/2019/09/15/mysql-lf_hash/\n\n## 不解决的问题\n\nLF_HASH 只保证 HASH 结构的线程安全，并不保证单个元素不被修改，单个数据元素还是要通过单独的 lock 来进行保护。\n\n## 使用指南\n\nLF_HASH 的使用和普通 HASH 稍有区别，主要包括以下几点：\n\n### 初始化 LF_HASH\n\n```c++\n/*\n  Initializes lf_hash, the arguments are compatible with hash_init\n\n  @note element_size sets both the size of allocated memory block for\n  lf_alloc and a size of memcpy'ed block size in lf_hash_insert. Typically\n  they are the same, indeed. But LF_HASH::element_size can be decreased\n  after lf_hash_init, and then lf_alloc will allocate larger block that\n  lf_hash_insert will copy over. It is desireable if part of the element\n  is expensive to initialize - for example if there is a mutex or\n  DYNAMIC_ARRAY. In this case they should be initialize in the\n  LF_ALLOCATOR::constructor, and lf_hash_insert should not overwrite them.\n  See wt_init() for example.\n  As an alternative to using the above trick with decreasing\n  LF_HASH::element_size one can provide an \"initialize\" hook that will finish\n  initialization of object provided by LF_ALLOCATOR and set element key from\n  object passed as parameter to lf_hash_insert instead of doing simple memcpy.\n*/\nvoid lf_hash_init2(LF_HASH *hash, uint element_size, uint flags,\n                   uint key_offset, uint key_length,\n                   hash_get_key_function get_key, CHARSET_INFO *charset,\n                   lf_hash_func *hash_function, lf_allocator_func *ctor,\n                   lf_allocator_func *dtor, lf_hash_init_func *init) {\n  lf_alloc_init2(&hash->alloc, sizeof(LF_SLIST) + element_size,\n                 offsetof(LF_SLIST, key), ctor, dtor);\n  lf_dynarray_init(&hash->array, sizeof(LF_SLIST *));\n  hash->size = 1;\n  hash->count = 0;\n  hash->element_size = element_size;\n  hash->flags = flags;\n  hash->charset = charset ? charset : &my_charset_bin;\n  hash->key_offset = key_offset;\n  hash->key_length = key_length;\n  hash->get_key = get_key;\n  hash->hash_function = hash_function ? hash_function : cset_hash_sort_adapter;\n  hash->initialize = init;\n  DBUG_ASSERT(get_key ? !key_offset && !key_length : key_length);\n}\n\nvoid lf_hash_destroy(LF_HASH *hash) {\n  LF_SLIST *el, **head = (LF_SLIST **)lf_dynarray_value(&hash->array, 0);\n\n  if (unlikely(!head)) {\n    return;\n  }\n  el = *head;\n\n  while (el) {\n    LF_SLIST *next = el->link;\n    if (el->hashnr & 1) {\n      lf_alloc_direct_free(&hash->alloc, el); /* normal node */\n    } else {\n      my_free(el); /* dummy node */\n    }\n    el = (LF_SLIST *)next;\n  }\n  lf_alloc_destroy(&hash->alloc);\n  lf_dynarray_destroy(&hash->array);\n}\n```\n\n初始化时需要定义 key 的获取方式，构造&析构方式，插入方法等。其中构造&析构方式，插入方法可以缺省；\n\n### 查询 LF_HASH\n\n```c++\nlf_hash_get_pins(&m_hash);\n\nlf_hash_search(&m_hash, pins, key, length);\n\nlf_hash_search_unpin(pins);\n\nlf_hash_put_pins(pins);\n```\n\n注意，查询的时候必须用 pins&unpin 进行保护，不论查询的结果如何。为什么要这样处理呢？这里涉及到一个对“无锁”概念的理解问题。无锁 HASH 中的无锁到底指的是什么？\n\n无锁指的是：HASH 中的数据是安全的，特别指删除过程是安全的，查询的线程不会被删除的线程影响。如果做到安全呢？pin 在这个过程中起到了关键作用，LF_HASH 在删除时，不是立即删除，而是放入到内部的待删除队列，此时删除操作返回成功，再次查询也无法查询到结果。但是，已经 pin 住的查询依旧有效，数据的访问也正常，直到 unpin 操作完成，删除操作才会真正执行。\n\n### 插入 LF_HASH\n\n```c++\nlf_hash_get_pins(&m_hash);\n\nlf_hash_insert(&m_hash, pins, item);\n\nlf_hash_put_pins(pins); \n```\n\n###  删除 LF_HASH\n\n```c++\nlf_hash_get_pins(&m_hash);\n\nlf_hash_delete(&m_hash, pins, key, length);\n\nlf_hash_put_pins(pins);\n```\n\n## 注意事项\n\nLF_HASH 的使用过程中需要注意：由于 LF_HASH 的删除操作“同步返回，异步删除”的特点，HASH 中管理的对象最好利用一个状态位进行标记，删除前先维护状态位的值。\n\n\n\n","slug":"clang/lf_hash","published":1,"updated":"2020-12-05T12:02:48.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4x50009gugm1v0g49r1","content":"<p>MySQL 中有很多实现非常好的数据结构，本文要介绍的 LF_HASH 就是其中一个。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"要解决的问题\"><a href=\"#要解决的问题\" class=\"headerlink\" title=\"要解决的问题\"></a>要解决的问题</h2><p>LF_HASH 主要解决的是以下两个问题：</p>\n<ol>\n<li>HASH 结构并发修改的问题，特别是查询、插入、删除并发操作时，如何保证当前查询到的元素不会被其它线程删除？</li>\n<li>扩容问题，如何保证在数据元素增多时，有效的进行扩容，减少数据的移动工作？</li>\n</ol>\n<p>第一个问题，解决办法是引入 pin 的概念，通过 pin 来记录正在被使用的数据元素，防止被其它线程删除（和 Hazard Pointer 的异同点？）</p>\n<p>第二个问题，解决办法是先取 key 的 hash 值，然后对 hash 的二进制进行 reverse，将高位相同的元素放入同一个 bucket。扩容时，只需要在单个 bucket 内插入一个新的锚点，不需要进行任何的数据移动。</p>\n<blockquote>\n<p><a href=\"https://kernelmaker.github.io/MySQL_lf_allocator\" target=\"_blank\" rel=\"noopener\">https://kernelmaker.github.io/MySQL_lf_allocator</a></p>\n<p><a href=\"https://baotiao.github.io/2019/09/15/mysql-lf_hash/\" target=\"_blank\" rel=\"noopener\">https://baotiao.github.io/2019/09/15/mysql-lf_hash/</a></p>\n</blockquote>\n<h2 id=\"不解决的问题\"><a href=\"#不解决的问题\" class=\"headerlink\" title=\"不解决的问题\"></a>不解决的问题</h2><p>LF_HASH 只保证 HASH 结构的线程安全，并不保证单个元素不被修改，单个数据元素还是要通过单独的 lock 来进行保护。</p>\n<h2 id=\"使用指南\"><a href=\"#使用指南\" class=\"headerlink\" title=\"使用指南\"></a>使用指南</h2><p>LF_HASH 的使用和普通 HASH 稍有区别，主要包括以下几点：</p>\n<h3 id=\"初始化-LF-HASH\"><a href=\"#初始化-LF-HASH\" class=\"headerlink\" title=\"初始化 LF_HASH\"></a>初始化 LF_HASH</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  Initializes lf_hash, the arguments are compatible with hash_init</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">  @note element_size sets both the size of allocated memory block for</span></span><br><span class=\"line\"><span class=\"comment\">  lf_alloc and a size of memcpy'ed block size in lf_hash_insert. Typically</span></span><br><span class=\"line\"><span class=\"comment\">  they are the same, indeed. But LF_HASH::element_size can be decreased</span></span><br><span class=\"line\"><span class=\"comment\">  after lf_hash_init, and then lf_alloc will allocate larger block that</span></span><br><span class=\"line\"><span class=\"comment\">  lf_hash_insert will copy over. It is desireable if part of the element</span></span><br><span class=\"line\"><span class=\"comment\">  is expensive to initialize - for example if there is a mutex or</span></span><br><span class=\"line\"><span class=\"comment\">  DYNAMIC_ARRAY. In this case they should be initialize in the</span></span><br><span class=\"line\"><span class=\"comment\">  LF_ALLOCATOR::constructor, and lf_hash_insert should not overwrite them.</span></span><br><span class=\"line\"><span class=\"comment\">  See wt_init() for example.</span></span><br><span class=\"line\"><span class=\"comment\">  As an alternative to using the above trick with decreasing</span></span><br><span class=\"line\"><span class=\"comment\">  LF_HASH::element_size one can provide an \"initialize\" hook that will finish</span></span><br><span class=\"line\"><span class=\"comment\">  initialization of object provided by LF_ALLOCATOR and set element key from</span></span><br><span class=\"line\"><span class=\"comment\">  object passed as parameter to lf_hash_insert instead of doing simple memcpy.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lf_hash_init2</span><span class=\"params\">(LF_HASH *hash, uint element_size, uint flags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   uint key_offset, uint key_length,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   hash_get_key_function get_key, CHARSET_INFO *charset,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   lf_hash_func *hash_function, lf_allocator_func *ctor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   lf_allocator_func *dtor, lf_hash_init_func *init)</span> </span>&#123;</span><br><span class=\"line\">  lf_alloc_init2(&amp;hash-&gt;alloc, <span class=\"keyword\">sizeof</span>(LF_SLIST) + element_size,</span><br><span class=\"line\">                 offsetof(LF_SLIST, key), ctor, dtor);</span><br><span class=\"line\">  lf_dynarray_init(&amp;hash-&gt;<span class=\"built_in\">array</span>, <span class=\"keyword\">sizeof</span>(LF_SLIST *));</span><br><span class=\"line\">  hash-&gt;<span class=\"built_in\">size</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">  hash-&gt;count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  hash-&gt;element_size = element_size;</span><br><span class=\"line\">  hash-&gt;flags = flags;</span><br><span class=\"line\">  hash-&gt;charset = charset ? charset : &amp;my_charset_bin;</span><br><span class=\"line\">  hash-&gt;key_offset = key_offset;</span><br><span class=\"line\">  hash-&gt;key_length = key_length;</span><br><span class=\"line\">  hash-&gt;get_key = get_key;</span><br><span class=\"line\">  hash-&gt;hash_function = hash_function ? hash_function : cset_hash_sort_adapter;</span><br><span class=\"line\">  hash-&gt;initialize = init;</span><br><span class=\"line\">  DBUG_ASSERT(get_key ? !key_offset &amp;&amp; !key_length : key_length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lf_hash_destroy</span><span class=\"params\">(LF_HASH *hash)</span> </span>&#123;</span><br><span class=\"line\">  LF_SLIST *el, **head = (LF_SLIST **)lf_dynarray_value(&amp;hash-&gt;<span class=\"built_in\">array</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (unlikely(!head)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  el = *head;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (el) &#123;</span><br><span class=\"line\">    LF_SLIST *next = el-&gt;link;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (el-&gt;hashnr &amp; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      lf_alloc_direct_free(&amp;hash-&gt;alloc, el); <span class=\"comment\">/* normal node */</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      my_free(el); <span class=\"comment\">/* dummy node */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    el = (LF_SLIST *)next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lf_alloc_destroy(&amp;hash-&gt;alloc);</span><br><span class=\"line\">  lf_dynarray_destroy(&amp;hash-&gt;<span class=\"built_in\">array</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始化时需要定义 key 的获取方式，构造&amp;析构方式，插入方法等。其中构造&amp;析构方式，插入方法可以缺省；</p>\n<h3 id=\"查询-LF-HASH\"><a href=\"#查询-LF-HASH\" class=\"headerlink\" title=\"查询 LF_HASH\"></a>查询 LF_HASH</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lf_hash_get_pins(&amp;m_hash);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_search(&amp;m_hash, pins, key, length);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_search_unpin(pins);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_put_pins(pins);</span><br></pre></td></tr></table></figure>\n\n<p>注意，查询的时候必须用 pins&amp;unpin 进行保护，不论查询的结果如何。为什么要这样处理呢？这里涉及到一个对“无锁”概念的理解问题。无锁 HASH 中的无锁到底指的是什么？</p>\n<p>无锁指的是：HASH 中的数据是安全的，特别指删除过程是安全的，查询的线程不会被删除的线程影响。如果做到安全呢？pin 在这个过程中起到了关键作用，LF_HASH 在删除时，不是立即删除，而是放入到内部的待删除队列，此时删除操作返回成功，再次查询也无法查询到结果。但是，已经 pin 住的查询依旧有效，数据的访问也正常，直到 unpin 操作完成，删除操作才会真正执行。</p>\n<h3 id=\"插入-LF-HASH\"><a href=\"#插入-LF-HASH\" class=\"headerlink\" title=\"插入 LF_HASH\"></a>插入 LF_HASH</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lf_hash_get_pins(&amp;m_hash);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_insert(&amp;m_hash, pins, item);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_put_pins(pins);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除-LF-HASH\"><a href=\"#删除-LF-HASH\" class=\"headerlink\" title=\"删除 LF_HASH\"></a>删除 LF_HASH</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lf_hash_get_pins(&amp;m_hash);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_delete(&amp;m_hash, pins, key, length);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_put_pins(pins);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>LF_HASH 的使用过程中需要注意：由于 LF_HASH 的删除操作“同步返回，异步删除”的特点，HASH 中管理的对象最好利用一个状态位进行标记，删除前先维护状态位的值。</p>\n","site":{"data":{}},"excerpt":"<p>MySQL 中有很多实现非常好的数据结构，本文要介绍的 LF_HASH 就是其中一个。</p>","more":"<h2 id=\"要解决的问题\"><a href=\"#要解决的问题\" class=\"headerlink\" title=\"要解决的问题\"></a>要解决的问题</h2><p>LF_HASH 主要解决的是以下两个问题：</p>\n<ol>\n<li>HASH 结构并发修改的问题，特别是查询、插入、删除并发操作时，如何保证当前查询到的元素不会被其它线程删除？</li>\n<li>扩容问题，如何保证在数据元素增多时，有效的进行扩容，减少数据的移动工作？</li>\n</ol>\n<p>第一个问题，解决办法是引入 pin 的概念，通过 pin 来记录正在被使用的数据元素，防止被其它线程删除（和 Hazard Pointer 的异同点？）</p>\n<p>第二个问题，解决办法是先取 key 的 hash 值，然后对 hash 的二进制进行 reverse，将高位相同的元素放入同一个 bucket。扩容时，只需要在单个 bucket 内插入一个新的锚点，不需要进行任何的数据移动。</p>\n<blockquote>\n<p><a href=\"https://kernelmaker.github.io/MySQL_lf_allocator\" target=\"_blank\" rel=\"noopener\">https://kernelmaker.github.io/MySQL_lf_allocator</a></p>\n<p><a href=\"https://baotiao.github.io/2019/09/15/mysql-lf_hash/\" target=\"_blank\" rel=\"noopener\">https://baotiao.github.io/2019/09/15/mysql-lf_hash/</a></p>\n</blockquote>\n<h2 id=\"不解决的问题\"><a href=\"#不解决的问题\" class=\"headerlink\" title=\"不解决的问题\"></a>不解决的问题</h2><p>LF_HASH 只保证 HASH 结构的线程安全，并不保证单个元素不被修改，单个数据元素还是要通过单独的 lock 来进行保护。</p>\n<h2 id=\"使用指南\"><a href=\"#使用指南\" class=\"headerlink\" title=\"使用指南\"></a>使用指南</h2><p>LF_HASH 的使用和普通 HASH 稍有区别，主要包括以下几点：</p>\n<h3 id=\"初始化-LF-HASH\"><a href=\"#初始化-LF-HASH\" class=\"headerlink\" title=\"初始化 LF_HASH\"></a>初始化 LF_HASH</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  Initializes lf_hash, the arguments are compatible with hash_init</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">  @note element_size sets both the size of allocated memory block for</span></span><br><span class=\"line\"><span class=\"comment\">  lf_alloc and a size of memcpy'ed block size in lf_hash_insert. Typically</span></span><br><span class=\"line\"><span class=\"comment\">  they are the same, indeed. But LF_HASH::element_size can be decreased</span></span><br><span class=\"line\"><span class=\"comment\">  after lf_hash_init, and then lf_alloc will allocate larger block that</span></span><br><span class=\"line\"><span class=\"comment\">  lf_hash_insert will copy over. It is desireable if part of the element</span></span><br><span class=\"line\"><span class=\"comment\">  is expensive to initialize - for example if there is a mutex or</span></span><br><span class=\"line\"><span class=\"comment\">  DYNAMIC_ARRAY. In this case they should be initialize in the</span></span><br><span class=\"line\"><span class=\"comment\">  LF_ALLOCATOR::constructor, and lf_hash_insert should not overwrite them.</span></span><br><span class=\"line\"><span class=\"comment\">  See wt_init() for example.</span></span><br><span class=\"line\"><span class=\"comment\">  As an alternative to using the above trick with decreasing</span></span><br><span class=\"line\"><span class=\"comment\">  LF_HASH::element_size one can provide an \"initialize\" hook that will finish</span></span><br><span class=\"line\"><span class=\"comment\">  initialization of object provided by LF_ALLOCATOR and set element key from</span></span><br><span class=\"line\"><span class=\"comment\">  object passed as parameter to lf_hash_insert instead of doing simple memcpy.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lf_hash_init2</span><span class=\"params\">(LF_HASH *hash, uint element_size, uint flags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   uint key_offset, uint key_length,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   hash_get_key_function get_key, CHARSET_INFO *charset,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   lf_hash_func *hash_function, lf_allocator_func *ctor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   lf_allocator_func *dtor, lf_hash_init_func *init)</span> </span>&#123;</span><br><span class=\"line\">  lf_alloc_init2(&amp;hash-&gt;alloc, <span class=\"keyword\">sizeof</span>(LF_SLIST) + element_size,</span><br><span class=\"line\">                 offsetof(LF_SLIST, key), ctor, dtor);</span><br><span class=\"line\">  lf_dynarray_init(&amp;hash-&gt;<span class=\"built_in\">array</span>, <span class=\"keyword\">sizeof</span>(LF_SLIST *));</span><br><span class=\"line\">  hash-&gt;<span class=\"built_in\">size</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">  hash-&gt;count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  hash-&gt;element_size = element_size;</span><br><span class=\"line\">  hash-&gt;flags = flags;</span><br><span class=\"line\">  hash-&gt;charset = charset ? charset : &amp;my_charset_bin;</span><br><span class=\"line\">  hash-&gt;key_offset = key_offset;</span><br><span class=\"line\">  hash-&gt;key_length = key_length;</span><br><span class=\"line\">  hash-&gt;get_key = get_key;</span><br><span class=\"line\">  hash-&gt;hash_function = hash_function ? hash_function : cset_hash_sort_adapter;</span><br><span class=\"line\">  hash-&gt;initialize = init;</span><br><span class=\"line\">  DBUG_ASSERT(get_key ? !key_offset &amp;&amp; !key_length : key_length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lf_hash_destroy</span><span class=\"params\">(LF_HASH *hash)</span> </span>&#123;</span><br><span class=\"line\">  LF_SLIST *el, **head = (LF_SLIST **)lf_dynarray_value(&amp;hash-&gt;<span class=\"built_in\">array</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (unlikely(!head)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  el = *head;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (el) &#123;</span><br><span class=\"line\">    LF_SLIST *next = el-&gt;link;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (el-&gt;hashnr &amp; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      lf_alloc_direct_free(&amp;hash-&gt;alloc, el); <span class=\"comment\">/* normal node */</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      my_free(el); <span class=\"comment\">/* dummy node */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    el = (LF_SLIST *)next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lf_alloc_destroy(&amp;hash-&gt;alloc);</span><br><span class=\"line\">  lf_dynarray_destroy(&amp;hash-&gt;<span class=\"built_in\">array</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始化时需要定义 key 的获取方式，构造&amp;析构方式，插入方法等。其中构造&amp;析构方式，插入方法可以缺省；</p>\n<h3 id=\"查询-LF-HASH\"><a href=\"#查询-LF-HASH\" class=\"headerlink\" title=\"查询 LF_HASH\"></a>查询 LF_HASH</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lf_hash_get_pins(&amp;m_hash);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_search(&amp;m_hash, pins, key, length);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_search_unpin(pins);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_put_pins(pins);</span><br></pre></td></tr></table></figure>\n\n<p>注意，查询的时候必须用 pins&amp;unpin 进行保护，不论查询的结果如何。为什么要这样处理呢？这里涉及到一个对“无锁”概念的理解问题。无锁 HASH 中的无锁到底指的是什么？</p>\n<p>无锁指的是：HASH 中的数据是安全的，特别指删除过程是安全的，查询的线程不会被删除的线程影响。如果做到安全呢？pin 在这个过程中起到了关键作用，LF_HASH 在删除时，不是立即删除，而是放入到内部的待删除队列，此时删除操作返回成功，再次查询也无法查询到结果。但是，已经 pin 住的查询依旧有效，数据的访问也正常，直到 unpin 操作完成，删除操作才会真正执行。</p>\n<h3 id=\"插入-LF-HASH\"><a href=\"#插入-LF-HASH\" class=\"headerlink\" title=\"插入 LF_HASH\"></a>插入 LF_HASH</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lf_hash_get_pins(&amp;m_hash);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_insert(&amp;m_hash, pins, item);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_put_pins(pins);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除-LF-HASH\"><a href=\"#删除-LF-HASH\" class=\"headerlink\" title=\"删除 LF_HASH\"></a>删除 LF_HASH</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lf_hash_get_pins(&amp;m_hash);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_delete(&amp;m_hash, pins, key, length);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_put_pins(pins);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>LF_HASH 的使用过程中需要注意：由于 LF_HASH 的删除操作“同步返回，异步删除”的特点，HASH 中管理的对象最好利用一个状态位进行标记，删除前先维护状态位的值。</p>"},{"title":"InnoDB Buffer Page 生命周期","date":"2020-08-23T08:15:50.000Z","_content":"\nInnoDB 没有使用操作系统自己的 Page Cache 机制，而是自己设计了一套 Buffer Pool 来进行 Page 的管理，关于 InnoDB Buffer Pool 的介绍，可以参考[这篇文章](http://mysql.taobao.org/monthly/2017/05/01/)，里面对 InnoDB Buffer Pool 作了比较深入的介绍。本文尝试从另外一个角度介绍一下一个 Buffer Page 的生命周期。本文给出的所有示例代码均基于 MySQL 8.0.18 版本。\n\n<!-- more -->\n\n## 类图结构\n\n<img src=\"/images/buffer-pool-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n## 申请\n\n### Page 读取\n\nPage 的读取有一个统一的入口函数 `buffer_page_get_gen` ，该方法的主要入参为 `page_id` ，即获取指定的页，MySQL 8.0 中的主要流程如下：\n\n```c++\n/* 以 Buf_fetch_normal 为例 */\n|--> fetch.single_page\n|    |--> get(block) // loop\n|    |    |--> lookup\n|    |    |    |--> buf_page_hash_get_low // 检查 page_hash 中是否存在\n|    |    |--> buf_block_fix // buf_fix_count 计数 +1\n|    |    |\n|    |    |--> read_page\n|    |    |    |--> buf_read_page // 从文件中读取 page\n|    |    |    |    |--> buf_read_page_low\n|    |    |    |    |    |--> buf_page_init_for_read\n|    |    |    |    |    |    |--> buf_LRU_get_free_block // 申请 1 个 block\n|    |    |    |    |    |    |--> buf_page_hash_get_low // 再次检查 page_hash 中是否存在\n|    |    |    |    |    |    |--> buf_page_init\n|    |    |    |    |    |    |    |--> buf_block_init_low\n|    |    |    |    |    |    |    |--> buf_page_init_low\n|    |    |    |    |    |    |    |--> HASH_INSERT // 插入 page_hash\n|    |    |    |    |    |    |--> buf_page_set_io_fix // io_fix 设置为 BUF_IO_READ\n|    |    |    |    |    |    |--> buf_LRU_add_block // 添加到 LRU\n|    |    |    |    |    |\n|    |    |    |    |    |--> _fil_io // 读取文件\n|    |    |    |    |    |--> buf_page_io_complete // 同步模式 IO 完成\n|    |    |    |    |    |    |--> buf_page_set_io_fix // io_fix 设置为 BUF_IO_NONE\n|    |\n|    |--> buf_page_make_young_if_needed\n|    |\n|    |--> buf_read_ahead_linear\n```\n\n读取 1 个 Page 时，首先会检查 `page_hash` ，如果 `page_hash` 中存在，则直接读取并设置 `buf_fix_count` 后返回；否则需要从文件中读取 Page，从文件中读取 Page 时首先需要申请 1 个 Block（具体申请过程在后面介绍），然后添加到 `page_hash` 和 `LRU` 列表中，最后进行数据的读取。对于 1 个新的 Page 的创建过程，入口函数为 `buf_page_create` ，基本流程如下：\n\n```c++\n/* buf_page_create */\n|--> buf_page_create\n|    |--> buf_LRU_get_free_block // 申请 1 个 block\n|    |--> buf_page_hash_get_low // 检查 page_hash 中是否存在\n|    |\n|    |--> buf_page_init\n|    |    |--> buf_block_init_low\n|    |    |--> buf_page_init_low\n|    |    |--> HASH_INSERT // 插入 page_hash\n|    |--> buf_block_buf_fix_inc // buf_fix_count 计数 +1\n|    |--> buf_LRU_add_block // 添加到 LRU\n```\n\n### Block 申请\n\nBlock 申请的入口函数为 `buf_LRU_get_free_block` ，该方法会从 Buffer Pool 中申请 1 个 Block 供后续的 Page 读取使用。Block 申请的主要流程如下：\n\n```c++\n|--> buf_LRU_get_free_block // loop\n|    |--> buf_LRU_get_free_only // 从 free_list 分配\n|    |\n|    |--> buf_LRU_scan_and_free_block // 从 LRU 中回收\n|    |    |--> buf_LRU_free_from_unzip_LRU_list\n|    |    |    |--> buf_LRU_free_page\n|    |    |--> buf_LRU_free_from_common_LRU_list\n|    |    |    |--> buf_flush_ready_for_replace\n|    |    |    |--> buf_LRU_free_page\n|    |\n|    |--> os_event_set(buf_flush_event) // 唤醒刷脏线程\n|    |\n|    |--> buf_flush_single_page_from_LRU // 从 LRU 中刷脏\n|    |    |--> buf_LRU_free_page\n|    |    |--> buf_flush_page\n```\n\nBuffer Pool 中维护了三个列表：`free_list` 、`LRU` 、`flush_list` 。其中 `free_list` 列表是当前可供使用的 Block，`LRU` 列表中保存了当前所有已经使用的 Block，`flush_list` 列表中保存了所有脏页 Block。申请 1 个 Block 时：\n\n1. 首先判断当前 `free_list` 列表是否为空，若 `free_list` 列表非空，则直接从 `free_list` 列表中进行分配。若无法直接从 `free_list` 列表分配，则会尝试从 `LRU` 列表中进行回收。\n2. `LRU` 是一个非严格的最近使用列表，从 `LRU` 列表回收时会从列表尾部往前遍历（加入 `LRU` 列表时从头部加入），如果找到可回收的 Page（遇到脏页会跳过），则会释放 Page 并将对应的 Block 重新放入 `free_list` 列表中。`LRU` 列表的遍历过程并不是无限的，例如：在第一次遍历时，当检查的 Page 数目达到 `BUF_LRU_SEARCH_SCAN_THRESHOLD` 时会退出遍历过程。\n3. 如果无法从 `LRU` 列表中回收 Block，则会唤醒刷脏线程，刷脏线程的处理流程在下面会做介绍。\n4. 同时还会从 `LRU` 列表中进行刷脏，该过程是同步的，依然是遍历 `LRU` 列表，但此时不会跳过脏页，遇到脏页直接进行刷脏。\n\n## 管理\n\n### 加入 flush_list\n\n前面提到过 `flush_list` 列表中保存的是所有脏页 Block，脏页在 mtr 提交时会加入 `flush_list` 中，基本过程如下：\n\n```c++\n|--> mtr_t::Command::execute()\n|    |--> add_dirty_page_to_flush_list\n|    |    |--> buf_flush_note_modification\n|    |    |    |--> buf_flush_insert_into_flush_list\n|    |    |    |    |--> UT_LIST_ADD_FIRST // 插入 flush_list 头部\n```\n\n注意：`flush_list` 是一个非严格有序的列表（可以看做按照 `oldest_modification` 有序），脏页插入列表后位置不再修改，再次修改时仅修改 `newest_modification` 。\n\n### 加入 LRU\n\n`LRU` 列表中保存了当前所有已经使用的 Block，申请完 1 个 Block 并完成初始化后会加到 `LRU` 列表中（默认会加入到 old 区域头部），加入 `LRU` 列表的基本过程如下：\n\n```c++\n|--> buf_LRU_add_block\n|    |--> buf_LRU_add_block_low\n|    |    |--> UT_LIST_ADD_FIRST // 插入 young 区域头部\n|    |    |--> UT_LIST_INSERT_AFTER // 插入 old 区域头部\n|    |    |\n|    |    |--> buf_LRU_old_adjust_len // 调整 LRU\n```\n\n### 管理 LRU\n\n前面提到 `LRU` 是一个非严格的最近使用列表，InnoDB 将 `LRU` 列表划分为两个区域：young 区域和 old 区域。`LRU` 列表的示意图如下：\n\n```c++\n/** LRU 列表示意图\n                                                LRU_old\n                                                   |\n**********************young************************|********old*********\n|==================================================|===================|\n\n几个主要的常量：\nBUF_LRU_OLD_TOLERANCE      20\nBUF_LRU_NON_OLD_MIN_LEN    5\nBUF_LRU_OLD_MIN_LEN        512\nBUF_LRU_OLD_RATIO_DIV      1024\n\n参数控制：\ninnodb_old_block_pct       old 区域占比\n\n*/\n```\n\n`buf_LRU_old_adjust_len`  方法会根据 `innodb_old_block_pct` 参数，维护 young 区域和 old 区域的长度，主要逻辑如下：\n\n1. 当 `LRU` 长度小于 ` BUF_LRU_OLD_MIN_LEN` 时，不划分区域。\n2. 不是每次操作 `LRU` 列表后都需要立即调整，`BUF_LRU_OLD_TOLERANCE`  可以看成是容忍范围。\n3. 当 old 区域变大时，LRU_old 指针向前移动；反之向后移动。\n\n当 Block 被再次访问时，会触发 `buf_page_make_young_if_needed` 函数进行 Block 位置的调整，基本过程如下：\n\n```c++\n|--> buf_page_make_young_if_needed\n|    |--> buf_page_peek_if_too_old // 判断访问间隔\n|    |    |--> buf_page_peek_if_young // 判断 young 区域位置\n|    |\n|    |--> buf_page_make_young\n|    |    |--> buf_LRU_make_block_young\n|    |    |    |--> buf_LRU_remove_block\n|    |    |    |--> buf_LRU_add_block_low\n```\n\n`buf_page_make_young_if_needed` 移动 Block 时需要考虑：\n\n1. 访问间隔需要大于 `buf_LRU_old_threshold_ms` 。\n2. 当 Block 在 young 区域前 1/4 时，不需要移动。\n\nInnoDB 中 `LRU` 列表的设计虽然简单，但是也有许多优化在里面，感兴趣的同学可以仔细研究，本文仅是一个简单的介绍。\n\n## 回收\n\n### 释放 Page\n\n前面提到，当 `free_list` 列表为空时，会首先尝试从 `LRU` 列表中进行回收，Page 的释放入口函数为 `buf_LRU_free_page` ，该方法的主要处理流程如下：\n\n```c++\n|--> buf_LRU_free_page\n|    |--> buf_page_can_relocate // 检查 buf_fix_count 计数和 io_fix 状态\n|    |\n|    |--> buf_LRU_block_remove_hashed // 从 LRU 和 page_hash 中删除\n|    |    |--> buf_LRU_remove_block\n|    |    |    |--> buf_LRU_old_adjust_len\n|    |    |--> HASH_DELETE\n|    |\n|    |--> btr_search_drop_page_hash_index // 从 AHI 中删除\n|    |\n|    |--> buf_LRU_block_free_hashed_page // 放回 free_list\n|    |    |--> buf_LRU_block_free_non_file_page\n```\n\n释放 1 个 Page 时，首先需要检查 `io_fix` 状态和 `buf_fix_count` 计数，确保当前 Page 没有被使用，然后将 Block 从依次从 `LRU` 列表、`page_hash` 、`AHI` 中删除，最后将 Block 重新放入到 `free_list` 列表中。\n\n### 同步刷脏\n\n同步刷脏的入口函数为 `buf_flush_page` ，同步刷脏过程仅会刷 1 个 Page，保证能够获取到 1 个可用的 Block，主要处理流程如下：\n\n```c++\n|--> buf_flush_page // 刷单个 page\n|    |--> buf_page_set_io_fix // io_fix 设置为 BUF_IO_WRITE\n|    |--> buf_flush_write_block_low\n|    |    |--> log_write_up_to // 写 redo\n|    |    |\n|    |    |--> fil_io\n|    |    |--> buf_dblwr_write_single_page // 写数据页\n|    |    |\n|    |    |--> fil_flush\n|    |    |--> buf_page_io_complete\n|    |    |    |--> buf_flush_write_complete\n|    |    |    |    |--> buf_flush_remove\n|    |    |    |    |--> buf_page_set_io_fix // io_fix 设置为 BUF_IO_NONE\n|    |    |    |\n|    |    |    |--> buf_LRU_free_page\n```\n\nInnoDB 通过严格的 WAL 机制保证数据的一致性，刷脏过程同样如此。首先需要保证对应的日志文件落盘，然后再写入数据页。最后将 Block 从 `flush_list` 列表中移除，此时 Page 变成可回收状态，再次调用 `buf_LRU_free_page` 进行回收。\n\n同步刷脏的过程不仅在获取 Block 时会被调用，在表删除的时候同样会被调用，表删除时会根据 `space_id` 进行批量的刷脏，入口函数为 `buf_LRU_flush_or_remove_pages` ，处理流程如下：\n\n```c++\n|--> buf_LRU_flush_or_remove_pages // 根据 space_id 刷脏\n|    |--> buf_LRU_drop_page_hash_for_tablespace // 遍历 LRU\n|    |    |--> buf_LRU_drop_page_hash_batch\n|    |    |    |--> btr_search_drop_page_hash_when_freed\n|    |    |    |    |--> buf_page_get_gen\n|    |    |    |    |--> btr_search_drop_page_hash_index // 从 AHI 中删除\n|    |\n|    |--> buf_LRU_remove_pages\n|    |    |--> buf_LRU_remove_all_pages // 遍历 LRU\n|    |    |    |--> buf_LRU_block_remove_hashed // 从 LRU 和 page_hash 中删除\n|    |    |    |--> buf_LRU_block_free_hashed_page // 放回 free_list\n|    |    |\n|    |    |--> buf_flush_dirty_pages\n|    |    |    |--> buf_flush_or_remove_pages // 遍历 flush_list\n|    |    |    |    |--> buf_flush_or_remove_page\n|    |    |    |    |    |--> buf_flush_remove\n|    |    |    |    |    |\n|    |    |    |    |    |--> buf_flush_page\n```\n\n具体的过程在此不再赘述，大家可以自己去阅读相应的代码。需要注意的是：如果单个 session 中使用了临时表，那么在 session 退出的时候，也会进入到上述的刷脏流程，当 `LRU` 列表很大时，session 退出的性能将会受到很大的影响。\n\n### 异步刷脏\n\n除了同步刷脏之外，MySQL 中还引入单独的刷脏线程进行异步刷脏。刷脏线程按照功能划分包括两种：coordinator 线程和 cleaner 线程。coordinator 线程会计算最大的刷脏量，然后分配刷脏任务给 cleaner 线程，cleaner 线程进行实际的刷脏工作（coordinator 线程本身也会参与刷脏）。异步刷脏的入口函数为 `buf_flush_page_cleaner_init` ，基本流程如下：\n\n```c++\n|--> buf_flush_page_coordinator_thread\n|    |--> os_event_wait(buf_flush_event)\n|    \n|    /* loop */\n|    |--> page_cleaner_flush_pages_recommendation // 计算最大刷脏量\n|    |--> pc_request // 任务分发，slot 数目等于 bp_instance 数目\n|    |    |--> os_event_set(page_cleaner->is_requested)\n|    |--> pc_flush_slot // 参与刷脏\n|    |--> pc_wait_finished\n\n\n|--> buf_flush_page_cleaner_thread\n|    |--> os_event_wait(page_cleaner->is_requested)\n|    |--> pc_flush_slot // 1 个线程处理 1 个 bp_instance\n|    |    |--> buf_flush_LRU_list // 从 LRU 中刷脏\n|    |    |    |--> buf_flush_do_batch(BUF_FLUSH_LRU)\n|    |    |\n|    |    |--> buf_flush_do_batch(BUF_FLUSH_LIST) // 从 flush_list 刷脏\n|    |    |    |--> buf_flush_batch\n|    |    |    |    |--> buf_do_LRU_batch\n|    |    |    |    |    |--> buf_free_from_unzip_LRU_list_batch\n|    |    |    |    |    |--> buf_flush_LRU_list_batch\n|    |    |    |    |    |    |--> buf_LRU_free_page\n|    |    |    |    |    |    |--> buf_flush_page_and_try_neighbors\n|    |    |    |    |    |    |    |--> buf_flush_try_neighbors\n|    |    |    |    |    |    |    |    |--> buf_flush_page\n|    |    |    |    |\n|    |    |    |    |--> buf_do_flush_list_batch\n|    |    |    |    |    |--> buf_flush_page_and_try_neighbors\n```\n\n异步刷脏的具体过程可以参考[这篇文章](http://mysql.taobao.org/monthly/2018/09/02/)，异步刷脏过程中有一个非常重要的点就是 `page_cleaner_flush_pages_recommendation` 计算最大刷脏量，相关的细节在此不再展开，后面有机会再单独整理一篇各种后台线程的更新逻辑。\n\n## 总结\n\n本文从申请、管理、回收三部分对 InnoDB Buffer Page 的生命周期管理进行了介绍，文中的内容只是一个基本概要，更多的细节还需要读者在阅读代码的过程中慢慢发掘。","source":"_posts/innodb/innodb-buffer-page.md","raw":"---\ntitle: InnoDB Buffer Page 生命周期\ndate: 2020-08-23 16:15:50\ntags:\n- Buffer Pool\ncategories: \n- InnoDB\n\n---\n\nInnoDB 没有使用操作系统自己的 Page Cache 机制，而是自己设计了一套 Buffer Pool 来进行 Page 的管理，关于 InnoDB Buffer Pool 的介绍，可以参考[这篇文章](http://mysql.taobao.org/monthly/2017/05/01/)，里面对 InnoDB Buffer Pool 作了比较深入的介绍。本文尝试从另外一个角度介绍一下一个 Buffer Page 的生命周期。本文给出的所有示例代码均基于 MySQL 8.0.18 版本。\n\n<!-- more -->\n\n## 类图结构\n\n<img src=\"/images/buffer-pool-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n## 申请\n\n### Page 读取\n\nPage 的读取有一个统一的入口函数 `buffer_page_get_gen` ，该方法的主要入参为 `page_id` ，即获取指定的页，MySQL 8.0 中的主要流程如下：\n\n```c++\n/* 以 Buf_fetch_normal 为例 */\n|--> fetch.single_page\n|    |--> get(block) // loop\n|    |    |--> lookup\n|    |    |    |--> buf_page_hash_get_low // 检查 page_hash 中是否存在\n|    |    |--> buf_block_fix // buf_fix_count 计数 +1\n|    |    |\n|    |    |--> read_page\n|    |    |    |--> buf_read_page // 从文件中读取 page\n|    |    |    |    |--> buf_read_page_low\n|    |    |    |    |    |--> buf_page_init_for_read\n|    |    |    |    |    |    |--> buf_LRU_get_free_block // 申请 1 个 block\n|    |    |    |    |    |    |--> buf_page_hash_get_low // 再次检查 page_hash 中是否存在\n|    |    |    |    |    |    |--> buf_page_init\n|    |    |    |    |    |    |    |--> buf_block_init_low\n|    |    |    |    |    |    |    |--> buf_page_init_low\n|    |    |    |    |    |    |    |--> HASH_INSERT // 插入 page_hash\n|    |    |    |    |    |    |--> buf_page_set_io_fix // io_fix 设置为 BUF_IO_READ\n|    |    |    |    |    |    |--> buf_LRU_add_block // 添加到 LRU\n|    |    |    |    |    |\n|    |    |    |    |    |--> _fil_io // 读取文件\n|    |    |    |    |    |--> buf_page_io_complete // 同步模式 IO 完成\n|    |    |    |    |    |    |--> buf_page_set_io_fix // io_fix 设置为 BUF_IO_NONE\n|    |\n|    |--> buf_page_make_young_if_needed\n|    |\n|    |--> buf_read_ahead_linear\n```\n\n读取 1 个 Page 时，首先会检查 `page_hash` ，如果 `page_hash` 中存在，则直接读取并设置 `buf_fix_count` 后返回；否则需要从文件中读取 Page，从文件中读取 Page 时首先需要申请 1 个 Block（具体申请过程在后面介绍），然后添加到 `page_hash` 和 `LRU` 列表中，最后进行数据的读取。对于 1 个新的 Page 的创建过程，入口函数为 `buf_page_create` ，基本流程如下：\n\n```c++\n/* buf_page_create */\n|--> buf_page_create\n|    |--> buf_LRU_get_free_block // 申请 1 个 block\n|    |--> buf_page_hash_get_low // 检查 page_hash 中是否存在\n|    |\n|    |--> buf_page_init\n|    |    |--> buf_block_init_low\n|    |    |--> buf_page_init_low\n|    |    |--> HASH_INSERT // 插入 page_hash\n|    |--> buf_block_buf_fix_inc // buf_fix_count 计数 +1\n|    |--> buf_LRU_add_block // 添加到 LRU\n```\n\n### Block 申请\n\nBlock 申请的入口函数为 `buf_LRU_get_free_block` ，该方法会从 Buffer Pool 中申请 1 个 Block 供后续的 Page 读取使用。Block 申请的主要流程如下：\n\n```c++\n|--> buf_LRU_get_free_block // loop\n|    |--> buf_LRU_get_free_only // 从 free_list 分配\n|    |\n|    |--> buf_LRU_scan_and_free_block // 从 LRU 中回收\n|    |    |--> buf_LRU_free_from_unzip_LRU_list\n|    |    |    |--> buf_LRU_free_page\n|    |    |--> buf_LRU_free_from_common_LRU_list\n|    |    |    |--> buf_flush_ready_for_replace\n|    |    |    |--> buf_LRU_free_page\n|    |\n|    |--> os_event_set(buf_flush_event) // 唤醒刷脏线程\n|    |\n|    |--> buf_flush_single_page_from_LRU // 从 LRU 中刷脏\n|    |    |--> buf_LRU_free_page\n|    |    |--> buf_flush_page\n```\n\nBuffer Pool 中维护了三个列表：`free_list` 、`LRU` 、`flush_list` 。其中 `free_list` 列表是当前可供使用的 Block，`LRU` 列表中保存了当前所有已经使用的 Block，`flush_list` 列表中保存了所有脏页 Block。申请 1 个 Block 时：\n\n1. 首先判断当前 `free_list` 列表是否为空，若 `free_list` 列表非空，则直接从 `free_list` 列表中进行分配。若无法直接从 `free_list` 列表分配，则会尝试从 `LRU` 列表中进行回收。\n2. `LRU` 是一个非严格的最近使用列表，从 `LRU` 列表回收时会从列表尾部往前遍历（加入 `LRU` 列表时从头部加入），如果找到可回收的 Page（遇到脏页会跳过），则会释放 Page 并将对应的 Block 重新放入 `free_list` 列表中。`LRU` 列表的遍历过程并不是无限的，例如：在第一次遍历时，当检查的 Page 数目达到 `BUF_LRU_SEARCH_SCAN_THRESHOLD` 时会退出遍历过程。\n3. 如果无法从 `LRU` 列表中回收 Block，则会唤醒刷脏线程，刷脏线程的处理流程在下面会做介绍。\n4. 同时还会从 `LRU` 列表中进行刷脏，该过程是同步的，依然是遍历 `LRU` 列表，但此时不会跳过脏页，遇到脏页直接进行刷脏。\n\n## 管理\n\n### 加入 flush_list\n\n前面提到过 `flush_list` 列表中保存的是所有脏页 Block，脏页在 mtr 提交时会加入 `flush_list` 中，基本过程如下：\n\n```c++\n|--> mtr_t::Command::execute()\n|    |--> add_dirty_page_to_flush_list\n|    |    |--> buf_flush_note_modification\n|    |    |    |--> buf_flush_insert_into_flush_list\n|    |    |    |    |--> UT_LIST_ADD_FIRST // 插入 flush_list 头部\n```\n\n注意：`flush_list` 是一个非严格有序的列表（可以看做按照 `oldest_modification` 有序），脏页插入列表后位置不再修改，再次修改时仅修改 `newest_modification` 。\n\n### 加入 LRU\n\n`LRU` 列表中保存了当前所有已经使用的 Block，申请完 1 个 Block 并完成初始化后会加到 `LRU` 列表中（默认会加入到 old 区域头部），加入 `LRU` 列表的基本过程如下：\n\n```c++\n|--> buf_LRU_add_block\n|    |--> buf_LRU_add_block_low\n|    |    |--> UT_LIST_ADD_FIRST // 插入 young 区域头部\n|    |    |--> UT_LIST_INSERT_AFTER // 插入 old 区域头部\n|    |    |\n|    |    |--> buf_LRU_old_adjust_len // 调整 LRU\n```\n\n### 管理 LRU\n\n前面提到 `LRU` 是一个非严格的最近使用列表，InnoDB 将 `LRU` 列表划分为两个区域：young 区域和 old 区域。`LRU` 列表的示意图如下：\n\n```c++\n/** LRU 列表示意图\n                                                LRU_old\n                                                   |\n**********************young************************|********old*********\n|==================================================|===================|\n\n几个主要的常量：\nBUF_LRU_OLD_TOLERANCE      20\nBUF_LRU_NON_OLD_MIN_LEN    5\nBUF_LRU_OLD_MIN_LEN        512\nBUF_LRU_OLD_RATIO_DIV      1024\n\n参数控制：\ninnodb_old_block_pct       old 区域占比\n\n*/\n```\n\n`buf_LRU_old_adjust_len`  方法会根据 `innodb_old_block_pct` 参数，维护 young 区域和 old 区域的长度，主要逻辑如下：\n\n1. 当 `LRU` 长度小于 ` BUF_LRU_OLD_MIN_LEN` 时，不划分区域。\n2. 不是每次操作 `LRU` 列表后都需要立即调整，`BUF_LRU_OLD_TOLERANCE`  可以看成是容忍范围。\n3. 当 old 区域变大时，LRU_old 指针向前移动；反之向后移动。\n\n当 Block 被再次访问时，会触发 `buf_page_make_young_if_needed` 函数进行 Block 位置的调整，基本过程如下：\n\n```c++\n|--> buf_page_make_young_if_needed\n|    |--> buf_page_peek_if_too_old // 判断访问间隔\n|    |    |--> buf_page_peek_if_young // 判断 young 区域位置\n|    |\n|    |--> buf_page_make_young\n|    |    |--> buf_LRU_make_block_young\n|    |    |    |--> buf_LRU_remove_block\n|    |    |    |--> buf_LRU_add_block_low\n```\n\n`buf_page_make_young_if_needed` 移动 Block 时需要考虑：\n\n1. 访问间隔需要大于 `buf_LRU_old_threshold_ms` 。\n2. 当 Block 在 young 区域前 1/4 时，不需要移动。\n\nInnoDB 中 `LRU` 列表的设计虽然简单，但是也有许多优化在里面，感兴趣的同学可以仔细研究，本文仅是一个简单的介绍。\n\n## 回收\n\n### 释放 Page\n\n前面提到，当 `free_list` 列表为空时，会首先尝试从 `LRU` 列表中进行回收，Page 的释放入口函数为 `buf_LRU_free_page` ，该方法的主要处理流程如下：\n\n```c++\n|--> buf_LRU_free_page\n|    |--> buf_page_can_relocate // 检查 buf_fix_count 计数和 io_fix 状态\n|    |\n|    |--> buf_LRU_block_remove_hashed // 从 LRU 和 page_hash 中删除\n|    |    |--> buf_LRU_remove_block\n|    |    |    |--> buf_LRU_old_adjust_len\n|    |    |--> HASH_DELETE\n|    |\n|    |--> btr_search_drop_page_hash_index // 从 AHI 中删除\n|    |\n|    |--> buf_LRU_block_free_hashed_page // 放回 free_list\n|    |    |--> buf_LRU_block_free_non_file_page\n```\n\n释放 1 个 Page 时，首先需要检查 `io_fix` 状态和 `buf_fix_count` 计数，确保当前 Page 没有被使用，然后将 Block 从依次从 `LRU` 列表、`page_hash` 、`AHI` 中删除，最后将 Block 重新放入到 `free_list` 列表中。\n\n### 同步刷脏\n\n同步刷脏的入口函数为 `buf_flush_page` ，同步刷脏过程仅会刷 1 个 Page，保证能够获取到 1 个可用的 Block，主要处理流程如下：\n\n```c++\n|--> buf_flush_page // 刷单个 page\n|    |--> buf_page_set_io_fix // io_fix 设置为 BUF_IO_WRITE\n|    |--> buf_flush_write_block_low\n|    |    |--> log_write_up_to // 写 redo\n|    |    |\n|    |    |--> fil_io\n|    |    |--> buf_dblwr_write_single_page // 写数据页\n|    |    |\n|    |    |--> fil_flush\n|    |    |--> buf_page_io_complete\n|    |    |    |--> buf_flush_write_complete\n|    |    |    |    |--> buf_flush_remove\n|    |    |    |    |--> buf_page_set_io_fix // io_fix 设置为 BUF_IO_NONE\n|    |    |    |\n|    |    |    |--> buf_LRU_free_page\n```\n\nInnoDB 通过严格的 WAL 机制保证数据的一致性，刷脏过程同样如此。首先需要保证对应的日志文件落盘，然后再写入数据页。最后将 Block 从 `flush_list` 列表中移除，此时 Page 变成可回收状态，再次调用 `buf_LRU_free_page` 进行回收。\n\n同步刷脏的过程不仅在获取 Block 时会被调用，在表删除的时候同样会被调用，表删除时会根据 `space_id` 进行批量的刷脏，入口函数为 `buf_LRU_flush_or_remove_pages` ，处理流程如下：\n\n```c++\n|--> buf_LRU_flush_or_remove_pages // 根据 space_id 刷脏\n|    |--> buf_LRU_drop_page_hash_for_tablespace // 遍历 LRU\n|    |    |--> buf_LRU_drop_page_hash_batch\n|    |    |    |--> btr_search_drop_page_hash_when_freed\n|    |    |    |    |--> buf_page_get_gen\n|    |    |    |    |--> btr_search_drop_page_hash_index // 从 AHI 中删除\n|    |\n|    |--> buf_LRU_remove_pages\n|    |    |--> buf_LRU_remove_all_pages // 遍历 LRU\n|    |    |    |--> buf_LRU_block_remove_hashed // 从 LRU 和 page_hash 中删除\n|    |    |    |--> buf_LRU_block_free_hashed_page // 放回 free_list\n|    |    |\n|    |    |--> buf_flush_dirty_pages\n|    |    |    |--> buf_flush_or_remove_pages // 遍历 flush_list\n|    |    |    |    |--> buf_flush_or_remove_page\n|    |    |    |    |    |--> buf_flush_remove\n|    |    |    |    |    |\n|    |    |    |    |    |--> buf_flush_page\n```\n\n具体的过程在此不再赘述，大家可以自己去阅读相应的代码。需要注意的是：如果单个 session 中使用了临时表，那么在 session 退出的时候，也会进入到上述的刷脏流程，当 `LRU` 列表很大时，session 退出的性能将会受到很大的影响。\n\n### 异步刷脏\n\n除了同步刷脏之外，MySQL 中还引入单独的刷脏线程进行异步刷脏。刷脏线程按照功能划分包括两种：coordinator 线程和 cleaner 线程。coordinator 线程会计算最大的刷脏量，然后分配刷脏任务给 cleaner 线程，cleaner 线程进行实际的刷脏工作（coordinator 线程本身也会参与刷脏）。异步刷脏的入口函数为 `buf_flush_page_cleaner_init` ，基本流程如下：\n\n```c++\n|--> buf_flush_page_coordinator_thread\n|    |--> os_event_wait(buf_flush_event)\n|    \n|    /* loop */\n|    |--> page_cleaner_flush_pages_recommendation // 计算最大刷脏量\n|    |--> pc_request // 任务分发，slot 数目等于 bp_instance 数目\n|    |    |--> os_event_set(page_cleaner->is_requested)\n|    |--> pc_flush_slot // 参与刷脏\n|    |--> pc_wait_finished\n\n\n|--> buf_flush_page_cleaner_thread\n|    |--> os_event_wait(page_cleaner->is_requested)\n|    |--> pc_flush_slot // 1 个线程处理 1 个 bp_instance\n|    |    |--> buf_flush_LRU_list // 从 LRU 中刷脏\n|    |    |    |--> buf_flush_do_batch(BUF_FLUSH_LRU)\n|    |    |\n|    |    |--> buf_flush_do_batch(BUF_FLUSH_LIST) // 从 flush_list 刷脏\n|    |    |    |--> buf_flush_batch\n|    |    |    |    |--> buf_do_LRU_batch\n|    |    |    |    |    |--> buf_free_from_unzip_LRU_list_batch\n|    |    |    |    |    |--> buf_flush_LRU_list_batch\n|    |    |    |    |    |    |--> buf_LRU_free_page\n|    |    |    |    |    |    |--> buf_flush_page_and_try_neighbors\n|    |    |    |    |    |    |    |--> buf_flush_try_neighbors\n|    |    |    |    |    |    |    |    |--> buf_flush_page\n|    |    |    |    |\n|    |    |    |    |--> buf_do_flush_list_batch\n|    |    |    |    |    |--> buf_flush_page_and_try_neighbors\n```\n\n异步刷脏的具体过程可以参考[这篇文章](http://mysql.taobao.org/monthly/2018/09/02/)，异步刷脏过程中有一个非常重要的点就是 `page_cleaner_flush_pages_recommendation` 计算最大刷脏量，相关的细节在此不再展开，后面有机会再单独整理一篇各种后台线程的更新逻辑。\n\n## 总结\n\n本文从申请、管理、回收三部分对 InnoDB Buffer Page 的生命周期管理进行了介绍，文中的内容只是一个基本概要，更多的细节还需要读者在阅读代码的过程中慢慢发掘。","slug":"innodb/innodb-buffer-page","published":1,"updated":"2020-12-05T13:11:00.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4x6000agugmfa9z3gns","content":"<p>InnoDB 没有使用操作系统自己的 Page Cache 机制，而是自己设计了一套 Buffer Pool 来进行 Page 的管理，关于 InnoDB Buffer Pool 的介绍，可以参考<a href=\"http://mysql.taobao.org/monthly/2017/05/01/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，里面对 InnoDB Buffer Pool 作了比较深入的介绍。本文尝试从另外一个角度介绍一下一个 Buffer Page 的生命周期。本文给出的所有示例代码均基于 MySQL 8.0.18 版本。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"类图结构\"><a href=\"#类图结构\" class=\"headerlink\" title=\"类图结构\"></a>类图结构</h2><img src=\"/images/buffer-pool-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<h2 id=\"申请\"><a href=\"#申请\" class=\"headerlink\" title=\"申请\"></a>申请</h2><h3 id=\"Page-读取\"><a href=\"#Page-读取\" class=\"headerlink\" title=\"Page 读取\"></a>Page 读取</h3><p>Page 的读取有一个统一的入口函数 <code>buffer_page_get_gen</code> ，该方法的主要入参为 <code>page_id</code> ，即获取指定的页，MySQL 8.0 中的主要流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 以 Buf_fetch_normal 为例 */</span></span><br><span class=\"line\">|--&gt; fetch.single_page</span><br><span class=\"line\">|    |--&gt; <span class=\"built_in\">get</span>(block) <span class=\"comment\">// loop</span></span><br><span class=\"line\">|    |    |--&gt; lookup</span><br><span class=\"line\">|    |    |    |--&gt; buf_page_hash_get_low <span class=\"comment\">// 检查 page_hash 中是否存在</span></span><br><span class=\"line\">|    |    |--&gt; buf_block_fix <span class=\"comment\">// buf_fix_count 计数 +1</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; read_page</span><br><span class=\"line\">|    |    |    |--&gt; buf_read_page <span class=\"comment\">// 从文件中读取 page</span></span><br><span class=\"line\">|    |    |    |    |--&gt; buf_read_page_low</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_page_init_for_read</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_LRU_get_free_block <span class=\"comment\">// 申请 1 个 block</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_page_hash_get_low <span class=\"comment\">// 再次检查 page_hash 中是否存在</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_page_init</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; buf_block_init_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; buf_page_init_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; HASH_INSERT <span class=\"comment\">// 插入 page_hash</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_page_set_io_fix <span class=\"comment\">// io_fix 设置为 BUF_IO_READ</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_LRU_add_block <span class=\"comment\">// 添加到 LRU</span></span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; _fil_io <span class=\"comment\">// 读取文件</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_page_io_complete <span class=\"comment\">// 同步模式 IO 完成</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_page_set_io_fix <span class=\"comment\">// io_fix 设置为 BUF_IO_NONE</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_page_make_young_if_needed</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_read_ahead_linear</span><br></pre></td></tr></table></figure>\n\n<p>读取 1 个 Page 时，首先会检查 <code>page_hash</code> ，如果 <code>page_hash</code> 中存在，则直接读取并设置 <code>buf_fix_count</code> 后返回；否则需要从文件中读取 Page，从文件中读取 Page 时首先需要申请 1 个 Block（具体申请过程在后面介绍），然后添加到 <code>page_hash</code> 和 <code>LRU</code> 列表中，最后进行数据的读取。对于 1 个新的 Page 的创建过程，入口函数为 <code>buf_page_create</code> ，基本流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* buf_page_create */</span></span><br><span class=\"line\">|--&gt; buf_page_create</span><br><span class=\"line\">|    |--&gt; buf_LRU_get_free_block <span class=\"comment\">// 申请 1 个 block</span></span><br><span class=\"line\">|    |--&gt; buf_page_hash_get_low <span class=\"comment\">// 检查 page_hash 中是否存在</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_page_init</span><br><span class=\"line\">|    |    |--&gt; buf_block_init_low</span><br><span class=\"line\">|    |    |--&gt; buf_page_init_low</span><br><span class=\"line\">|    |    |--&gt; HASH_INSERT <span class=\"comment\">// 插入 page_hash</span></span><br><span class=\"line\">|    |--&gt; buf_block_buf_fix_inc <span class=\"comment\">// buf_fix_count 计数 +1</span></span><br><span class=\"line\">|    |--&gt; buf_LRU_add_block <span class=\"comment\">// 添加到 LRU</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Block-申请\"><a href=\"#Block-申请\" class=\"headerlink\" title=\"Block 申请\"></a>Block 申请</h3><p>Block 申请的入口函数为 <code>buf_LRU_get_free_block</code> ，该方法会从 Buffer Pool 中申请 1 个 Block 供后续的 Page 读取使用。Block 申请的主要流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_LRU_get_free_block <span class=\"comment\">// loop</span></span><br><span class=\"line\">|    |--&gt; buf_LRU_get_free_only <span class=\"comment\">// 从 free_list 分配</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_LRU_scan_and_free_block <span class=\"comment\">// 从 LRU 中回收</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_free_from_unzip_LRU_list</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |    |--&gt; buf_LRU_free_from_common_LRU_list</span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_ready_for_replace</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; os_event_set(buf_flush_event) <span class=\"comment\">// 唤醒刷脏线程</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_flush_single_page_from_LRU <span class=\"comment\">// 从 LRU 中刷脏</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |    |--&gt; buf_flush_page</span><br></pre></td></tr></table></figure>\n\n<p>Buffer Pool 中维护了三个列表：<code>free_list</code> 、<code>LRU</code> 、<code>flush_list</code> 。其中 <code>free_list</code> 列表是当前可供使用的 Block，<code>LRU</code> 列表中保存了当前所有已经使用的 Block，<code>flush_list</code> 列表中保存了所有脏页 Block。申请 1 个 Block 时：</p>\n<ol>\n<li>首先判断当前 <code>free_list</code> 列表是否为空，若 <code>free_list</code> 列表非空，则直接从 <code>free_list</code> 列表中进行分配。若无法直接从 <code>free_list</code> 列表分配，则会尝试从 <code>LRU</code> 列表中进行回收。</li>\n<li><code>LRU</code> 是一个非严格的最近使用列表，从 <code>LRU</code> 列表回收时会从列表尾部往前遍历（加入 <code>LRU</code> 列表时从头部加入），如果找到可回收的 Page（遇到脏页会跳过），则会释放 Page 并将对应的 Block 重新放入 <code>free_list</code> 列表中。<code>LRU</code> 列表的遍历过程并不是无限的，例如：在第一次遍历时，当检查的 Page 数目达到 <code>BUF_LRU_SEARCH_SCAN_THRESHOLD</code> 时会退出遍历过程。</li>\n<li>如果无法从 <code>LRU</code> 列表中回收 Block，则会唤醒刷脏线程，刷脏线程的处理流程在下面会做介绍。</li>\n<li>同时还会从 <code>LRU</code> 列表中进行刷脏，该过程是同步的，依然是遍历 <code>LRU</code> 列表，但此时不会跳过脏页，遇到脏页直接进行刷脏。</li>\n</ol>\n<h2 id=\"管理\"><a href=\"#管理\" class=\"headerlink\" title=\"管理\"></a>管理</h2><h3 id=\"加入-flush-list\"><a href=\"#加入-flush-list\" class=\"headerlink\" title=\"加入 flush_list\"></a>加入 flush_list</h3><p>前面提到过 <code>flush_list</code> 列表中保存的是所有脏页 Block，脏页在 mtr 提交时会加入 <code>flush_list</code> 中，基本过程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; <span class=\"keyword\">mtr_t</span>::Command::execute()</span><br><span class=\"line\">|    |--&gt; add_dirty_page_to_flush_list</span><br><span class=\"line\">|    |    |--&gt; buf_flush_note_modification</span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_insert_into_flush_list</span><br><span class=\"line\">|    |    |    |    |--&gt; UT_LIST_ADD_FIRST <span class=\"comment\">// 插入 flush_list 头部</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：<code>flush_list</code> 是一个非严格有序的列表（可以看做按照 <code>oldest_modification</code> 有序），脏页插入列表后位置不再修改，再次修改时仅修改 <code>newest_modification</code> 。</p>\n<h3 id=\"加入-LRU\"><a href=\"#加入-LRU\" class=\"headerlink\" title=\"加入 LRU\"></a>加入 LRU</h3><p><code>LRU</code> 列表中保存了当前所有已经使用的 Block，申请完 1 个 Block 并完成初始化后会加到 <code>LRU</code> 列表中（默认会加入到 old 区域头部），加入 <code>LRU</code> 列表的基本过程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_LRU_add_block</span><br><span class=\"line\">|    |--&gt; buf_LRU_add_block_low</span><br><span class=\"line\">|    |    |--&gt; UT_LIST_ADD_FIRST <span class=\"comment\">// 插入 young 区域头部</span></span><br><span class=\"line\">|    |    |--&gt; UT_LIST_INSERT_AFTER <span class=\"comment\">// 插入 old 区域头部</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; buf_LRU_old_adjust_len <span class=\"comment\">// 调整 LRU</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"管理-LRU\"><a href=\"#管理-LRU\" class=\"headerlink\" title=\"管理 LRU\"></a>管理 LRU</h3><p>前面提到 <code>LRU</code> 是一个非严格的最近使用列表，InnoDB 将 <code>LRU</code> 列表划分为两个区域：young 区域和 old 区域。<code>LRU</code> 列表的示意图如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** LRU 列表示意图</span></span><br><span class=\"line\"><span class=\"comment\">                                                LRU_old</span></span><br><span class=\"line\"><span class=\"comment\">                                                   |</span></span><br><span class=\"line\"><span class=\"comment\">**********************young************************|********old*********</span></span><br><span class=\"line\"><span class=\"comment\">|==================================================|===================|</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">几个主要的常量：</span></span><br><span class=\"line\"><span class=\"comment\">BUF_LRU_OLD_TOLERANCE      20</span></span><br><span class=\"line\"><span class=\"comment\">BUF_LRU_NON_OLD_MIN_LEN    5</span></span><br><span class=\"line\"><span class=\"comment\">BUF_LRU_OLD_MIN_LEN        512</span></span><br><span class=\"line\"><span class=\"comment\">BUF_LRU_OLD_RATIO_DIV      1024</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">参数控制：</span></span><br><span class=\"line\"><span class=\"comment\">innodb_old_block_pct       old 区域占比</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p><code>buf_LRU_old_adjust_len</code>  方法会根据 <code>innodb_old_block_pct</code> 参数，维护 young 区域和 old 区域的长度，主要逻辑如下：</p>\n<ol>\n<li>当 <code>LRU</code> 长度小于 <code>BUF_LRU_OLD_MIN_LEN</code> 时，不划分区域。</li>\n<li>不是每次操作 <code>LRU</code> 列表后都需要立即调整，<code>BUF_LRU_OLD_TOLERANCE</code>  可以看成是容忍范围。</li>\n<li>当 old 区域变大时，LRU_old 指针向前移动；反之向后移动。</li>\n</ol>\n<p>当 Block 被再次访问时，会触发 <code>buf_page_make_young_if_needed</code> 函数进行 Block 位置的调整，基本过程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_page_make_young_if_needed</span><br><span class=\"line\">|    |--&gt; buf_page_peek_if_too_old <span class=\"comment\">// 判断访问间隔</span></span><br><span class=\"line\">|    |    |--&gt; buf_page_peek_if_young <span class=\"comment\">// 判断 young 区域位置</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_page_make_young</span><br><span class=\"line\">|    |    |--&gt; buf_LRU_make_block_young</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_remove_block</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_add_block_low</span><br></pre></td></tr></table></figure>\n\n<p><code>buf_page_make_young_if_needed</code> 移动 Block 时需要考虑：</p>\n<ol>\n<li>访问间隔需要大于 <code>buf_LRU_old_threshold_ms</code> 。</li>\n<li>当 Block 在 young 区域前 1/4 时，不需要移动。</li>\n</ol>\n<p>InnoDB 中 <code>LRU</code> 列表的设计虽然简单，但是也有许多优化在里面，感兴趣的同学可以仔细研究，本文仅是一个简单的介绍。</p>\n<h2 id=\"回收\"><a href=\"#回收\" class=\"headerlink\" title=\"回收\"></a>回收</h2><h3 id=\"释放-Page\"><a href=\"#释放-Page\" class=\"headerlink\" title=\"释放 Page\"></a>释放 Page</h3><p>前面提到，当 <code>free_list</code> 列表为空时，会首先尝试从 <code>LRU</code> 列表中进行回收，Page 的释放入口函数为 <code>buf_LRU_free_page</code> ，该方法的主要处理流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |--&gt; buf_page_can_relocate <span class=\"comment\">// 检查 buf_fix_count 计数和 io_fix 状态</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_LRU_block_remove_hashed <span class=\"comment\">// 从 LRU 和 page_hash 中删除</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_remove_block</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_old_adjust_len</span><br><span class=\"line\">|    |    |--&gt; HASH_DELETE</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; btr_search_drop_page_hash_index <span class=\"comment\">// 从 AHI 中删除</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_LRU_block_free_hashed_page <span class=\"comment\">// 放回 free_list</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_block_free_non_file_page</span><br></pre></td></tr></table></figure>\n\n<p>释放 1 个 Page 时，首先需要检查 <code>io_fix</code> 状态和 <code>buf_fix_count</code> 计数，确保当前 Page 没有被使用，然后将 Block 从依次从 <code>LRU</code> 列表、<code>page_hash</code> 、<code>AHI</code> 中删除，最后将 Block 重新放入到 <code>free_list</code> 列表中。</p>\n<h3 id=\"同步刷脏\"><a href=\"#同步刷脏\" class=\"headerlink\" title=\"同步刷脏\"></a>同步刷脏</h3><p>同步刷脏的入口函数为 <code>buf_flush_page</code> ，同步刷脏过程仅会刷 1 个 Page，保证能够获取到 1 个可用的 Block，主要处理流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_flush_page <span class=\"comment\">// 刷单个 page</span></span><br><span class=\"line\">|    |--&gt; buf_page_set_io_fix <span class=\"comment\">// io_fix 设置为 BUF_IO_WRITE</span></span><br><span class=\"line\">|    |--&gt; buf_flush_write_block_low</span><br><span class=\"line\">|    |    |--&gt; log_write_up_to <span class=\"comment\">// 写 redo</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; fil_io</span><br><span class=\"line\">|    |    |--&gt; buf_dblwr_write_single_page <span class=\"comment\">// 写数据页</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; fil_flush</span><br><span class=\"line\">|    |    |--&gt; buf_page_io_complete</span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_write_complete</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_flush_remove</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_page_set_io_fix <span class=\"comment\">// io_fix 设置为 BUF_IO_NONE</span></span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_free_page</span><br></pre></td></tr></table></figure>\n\n<p>InnoDB 通过严格的 WAL 机制保证数据的一致性，刷脏过程同样如此。首先需要保证对应的日志文件落盘，然后再写入数据页。最后将 Block 从 <code>flush_list</code> 列表中移除，此时 Page 变成可回收状态，再次调用 <code>buf_LRU_free_page</code> 进行回收。</p>\n<p>同步刷脏的过程不仅在获取 Block 时会被调用，在表删除的时候同样会被调用，表删除时会根据 <code>space_id</code> 进行批量的刷脏，入口函数为 <code>buf_LRU_flush_or_remove_pages</code> ，处理流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_LRU_flush_or_remove_pages <span class=\"comment\">// 根据 space_id 刷脏</span></span><br><span class=\"line\">|    |--&gt; buf_LRU_drop_page_hash_for_tablespace <span class=\"comment\">// 遍历 LRU</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_drop_page_hash_batch</span><br><span class=\"line\">|    |    |    |--&gt; btr_search_drop_page_hash_when_freed</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_page_get_gen</span><br><span class=\"line\">|    |    |    |    |--&gt; btr_search_drop_page_hash_index <span class=\"comment\">// 从 AHI 中删除</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_LRU_remove_pages</span><br><span class=\"line\">|    |    |--&gt; buf_LRU_remove_all_pages <span class=\"comment\">// 遍历 LRU</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_block_remove_hashed <span class=\"comment\">// 从 LRU 和 page_hash 中删除</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_block_free_hashed_page <span class=\"comment\">// 放回 free_list</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; buf_flush_dirty_pages</span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_or_remove_pages <span class=\"comment\">// 遍历 flush_list</span></span><br><span class=\"line\">|    |    |    |    |--&gt; buf_flush_or_remove_page</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_flush_remove</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_flush_page</span><br></pre></td></tr></table></figure>\n\n<p>具体的过程在此不再赘述，大家可以自己去阅读相应的代码。需要注意的是：如果单个 session 中使用了临时表，那么在 session 退出的时候，也会进入到上述的刷脏流程，当 <code>LRU</code> 列表很大时，session 退出的性能将会受到很大的影响。</p>\n<h3 id=\"异步刷脏\"><a href=\"#异步刷脏\" class=\"headerlink\" title=\"异步刷脏\"></a>异步刷脏</h3><p>除了同步刷脏之外，MySQL 中还引入单独的刷脏线程进行异步刷脏。刷脏线程按照功能划分包括两种：coordinator 线程和 cleaner 线程。coordinator 线程会计算最大的刷脏量，然后分配刷脏任务给 cleaner 线程，cleaner 线程进行实际的刷脏工作（coordinator 线程本身也会参与刷脏）。异步刷脏的入口函数为 <code>buf_flush_page_cleaner_init</code> ，基本流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_flush_page_coordinator_thread</span><br><span class=\"line\">|    |--&gt; os_event_wait(buf_flush_event)</span><br><span class=\"line\">|    </span><br><span class=\"line\">|    <span class=\"comment\">/* loop */</span></span><br><span class=\"line\">|    |--&gt; page_cleaner_flush_pages_recommendation <span class=\"comment\">// 计算最大刷脏量</span></span><br><span class=\"line\">|    |--&gt; pc_request <span class=\"comment\">// 任务分发，slot 数目等于 bp_instance 数目</span></span><br><span class=\"line\">|    |    |--&gt; os_event_set(page_cleaner-&gt;is_requested)</span><br><span class=\"line\">|    |--&gt; pc_flush_slot <span class=\"comment\">// 参与刷脏</span></span><br><span class=\"line\">|    |--&gt; pc_wait_finished</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; buf_flush_page_cleaner_thread</span><br><span class=\"line\">|    |--&gt; os_event_wait(page_cleaner-&gt;is_requested)</span><br><span class=\"line\">|    |--&gt; pc_flush_slot <span class=\"comment\">// 1 个线程处理 1 个 bp_instance</span></span><br><span class=\"line\">|    |    |--&gt; buf_flush_LRU_list <span class=\"comment\">// 从 LRU 中刷脏</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_do_batch(BUF_FLUSH_LRU)</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; buf_flush_do_batch(BUF_FLUSH_LIST) <span class=\"comment\">// 从 flush_list 刷脏</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_batch</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_do_LRU_batch</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_free_from_unzip_LRU_list_batch</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_flush_LRU_list_batch</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_flush_page_and_try_neighbors</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; buf_flush_try_neighbors</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; buf_flush_page</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_do_flush_list_batch</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_flush_page_and_try_neighbors</span><br></pre></td></tr></table></figure>\n\n<p>异步刷脏的具体过程可以参考<a href=\"http://mysql.taobao.org/monthly/2018/09/02/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，异步刷脏过程中有一个非常重要的点就是 <code>page_cleaner_flush_pages_recommendation</code> 计算最大刷脏量，相关的细节在此不再展开，后面有机会再单独整理一篇各种后台线程的更新逻辑。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文从申请、管理、回收三部分对 InnoDB Buffer Page 的生命周期管理进行了介绍，文中的内容只是一个基本概要，更多的细节还需要读者在阅读代码的过程中慢慢发掘。</p>\n","site":{"data":{}},"excerpt":"<p>InnoDB 没有使用操作系统自己的 Page Cache 机制，而是自己设计了一套 Buffer Pool 来进行 Page 的管理，关于 InnoDB Buffer Pool 的介绍，可以参考<a href=\"http://mysql.taobao.org/monthly/2017/05/01/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，里面对 InnoDB Buffer Pool 作了比较深入的介绍。本文尝试从另外一个角度介绍一下一个 Buffer Page 的生命周期。本文给出的所有示例代码均基于 MySQL 8.0.18 版本。</p>","more":"<h2 id=\"类图结构\"><a href=\"#类图结构\" class=\"headerlink\" title=\"类图结构\"></a>类图结构</h2><img src=\"/images/buffer-pool-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<h2 id=\"申请\"><a href=\"#申请\" class=\"headerlink\" title=\"申请\"></a>申请</h2><h3 id=\"Page-读取\"><a href=\"#Page-读取\" class=\"headerlink\" title=\"Page 读取\"></a>Page 读取</h3><p>Page 的读取有一个统一的入口函数 <code>buffer_page_get_gen</code> ，该方法的主要入参为 <code>page_id</code> ，即获取指定的页，MySQL 8.0 中的主要流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 以 Buf_fetch_normal 为例 */</span></span><br><span class=\"line\">|--&gt; fetch.single_page</span><br><span class=\"line\">|    |--&gt; <span class=\"built_in\">get</span>(block) <span class=\"comment\">// loop</span></span><br><span class=\"line\">|    |    |--&gt; lookup</span><br><span class=\"line\">|    |    |    |--&gt; buf_page_hash_get_low <span class=\"comment\">// 检查 page_hash 中是否存在</span></span><br><span class=\"line\">|    |    |--&gt; buf_block_fix <span class=\"comment\">// buf_fix_count 计数 +1</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; read_page</span><br><span class=\"line\">|    |    |    |--&gt; buf_read_page <span class=\"comment\">// 从文件中读取 page</span></span><br><span class=\"line\">|    |    |    |    |--&gt; buf_read_page_low</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_page_init_for_read</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_LRU_get_free_block <span class=\"comment\">// 申请 1 个 block</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_page_hash_get_low <span class=\"comment\">// 再次检查 page_hash 中是否存在</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_page_init</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; buf_block_init_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; buf_page_init_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; HASH_INSERT <span class=\"comment\">// 插入 page_hash</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_page_set_io_fix <span class=\"comment\">// io_fix 设置为 BUF_IO_READ</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_LRU_add_block <span class=\"comment\">// 添加到 LRU</span></span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; _fil_io <span class=\"comment\">// 读取文件</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_page_io_complete <span class=\"comment\">// 同步模式 IO 完成</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_page_set_io_fix <span class=\"comment\">// io_fix 设置为 BUF_IO_NONE</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_page_make_young_if_needed</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_read_ahead_linear</span><br></pre></td></tr></table></figure>\n\n<p>读取 1 个 Page 时，首先会检查 <code>page_hash</code> ，如果 <code>page_hash</code> 中存在，则直接读取并设置 <code>buf_fix_count</code> 后返回；否则需要从文件中读取 Page，从文件中读取 Page 时首先需要申请 1 个 Block（具体申请过程在后面介绍），然后添加到 <code>page_hash</code> 和 <code>LRU</code> 列表中，最后进行数据的读取。对于 1 个新的 Page 的创建过程，入口函数为 <code>buf_page_create</code> ，基本流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* buf_page_create */</span></span><br><span class=\"line\">|--&gt; buf_page_create</span><br><span class=\"line\">|    |--&gt; buf_LRU_get_free_block <span class=\"comment\">// 申请 1 个 block</span></span><br><span class=\"line\">|    |--&gt; buf_page_hash_get_low <span class=\"comment\">// 检查 page_hash 中是否存在</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_page_init</span><br><span class=\"line\">|    |    |--&gt; buf_block_init_low</span><br><span class=\"line\">|    |    |--&gt; buf_page_init_low</span><br><span class=\"line\">|    |    |--&gt; HASH_INSERT <span class=\"comment\">// 插入 page_hash</span></span><br><span class=\"line\">|    |--&gt; buf_block_buf_fix_inc <span class=\"comment\">// buf_fix_count 计数 +1</span></span><br><span class=\"line\">|    |--&gt; buf_LRU_add_block <span class=\"comment\">// 添加到 LRU</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Block-申请\"><a href=\"#Block-申请\" class=\"headerlink\" title=\"Block 申请\"></a>Block 申请</h3><p>Block 申请的入口函数为 <code>buf_LRU_get_free_block</code> ，该方法会从 Buffer Pool 中申请 1 个 Block 供后续的 Page 读取使用。Block 申请的主要流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_LRU_get_free_block <span class=\"comment\">// loop</span></span><br><span class=\"line\">|    |--&gt; buf_LRU_get_free_only <span class=\"comment\">// 从 free_list 分配</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_LRU_scan_and_free_block <span class=\"comment\">// 从 LRU 中回收</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_free_from_unzip_LRU_list</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |    |--&gt; buf_LRU_free_from_common_LRU_list</span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_ready_for_replace</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; os_event_set(buf_flush_event) <span class=\"comment\">// 唤醒刷脏线程</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_flush_single_page_from_LRU <span class=\"comment\">// 从 LRU 中刷脏</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |    |--&gt; buf_flush_page</span><br></pre></td></tr></table></figure>\n\n<p>Buffer Pool 中维护了三个列表：<code>free_list</code> 、<code>LRU</code> 、<code>flush_list</code> 。其中 <code>free_list</code> 列表是当前可供使用的 Block，<code>LRU</code> 列表中保存了当前所有已经使用的 Block，<code>flush_list</code> 列表中保存了所有脏页 Block。申请 1 个 Block 时：</p>\n<ol>\n<li>首先判断当前 <code>free_list</code> 列表是否为空，若 <code>free_list</code> 列表非空，则直接从 <code>free_list</code> 列表中进行分配。若无法直接从 <code>free_list</code> 列表分配，则会尝试从 <code>LRU</code> 列表中进行回收。</li>\n<li><code>LRU</code> 是一个非严格的最近使用列表，从 <code>LRU</code> 列表回收时会从列表尾部往前遍历（加入 <code>LRU</code> 列表时从头部加入），如果找到可回收的 Page（遇到脏页会跳过），则会释放 Page 并将对应的 Block 重新放入 <code>free_list</code> 列表中。<code>LRU</code> 列表的遍历过程并不是无限的，例如：在第一次遍历时，当检查的 Page 数目达到 <code>BUF_LRU_SEARCH_SCAN_THRESHOLD</code> 时会退出遍历过程。</li>\n<li>如果无法从 <code>LRU</code> 列表中回收 Block，则会唤醒刷脏线程，刷脏线程的处理流程在下面会做介绍。</li>\n<li>同时还会从 <code>LRU</code> 列表中进行刷脏，该过程是同步的，依然是遍历 <code>LRU</code> 列表，但此时不会跳过脏页，遇到脏页直接进行刷脏。</li>\n</ol>\n<h2 id=\"管理\"><a href=\"#管理\" class=\"headerlink\" title=\"管理\"></a>管理</h2><h3 id=\"加入-flush-list\"><a href=\"#加入-flush-list\" class=\"headerlink\" title=\"加入 flush_list\"></a>加入 flush_list</h3><p>前面提到过 <code>flush_list</code> 列表中保存的是所有脏页 Block，脏页在 mtr 提交时会加入 <code>flush_list</code> 中，基本过程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; <span class=\"keyword\">mtr_t</span>::Command::execute()</span><br><span class=\"line\">|    |--&gt; add_dirty_page_to_flush_list</span><br><span class=\"line\">|    |    |--&gt; buf_flush_note_modification</span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_insert_into_flush_list</span><br><span class=\"line\">|    |    |    |    |--&gt; UT_LIST_ADD_FIRST <span class=\"comment\">// 插入 flush_list 头部</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：<code>flush_list</code> 是一个非严格有序的列表（可以看做按照 <code>oldest_modification</code> 有序），脏页插入列表后位置不再修改，再次修改时仅修改 <code>newest_modification</code> 。</p>\n<h3 id=\"加入-LRU\"><a href=\"#加入-LRU\" class=\"headerlink\" title=\"加入 LRU\"></a>加入 LRU</h3><p><code>LRU</code> 列表中保存了当前所有已经使用的 Block，申请完 1 个 Block 并完成初始化后会加到 <code>LRU</code> 列表中（默认会加入到 old 区域头部），加入 <code>LRU</code> 列表的基本过程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_LRU_add_block</span><br><span class=\"line\">|    |--&gt; buf_LRU_add_block_low</span><br><span class=\"line\">|    |    |--&gt; UT_LIST_ADD_FIRST <span class=\"comment\">// 插入 young 区域头部</span></span><br><span class=\"line\">|    |    |--&gt; UT_LIST_INSERT_AFTER <span class=\"comment\">// 插入 old 区域头部</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; buf_LRU_old_adjust_len <span class=\"comment\">// 调整 LRU</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"管理-LRU\"><a href=\"#管理-LRU\" class=\"headerlink\" title=\"管理 LRU\"></a>管理 LRU</h3><p>前面提到 <code>LRU</code> 是一个非严格的最近使用列表，InnoDB 将 <code>LRU</code> 列表划分为两个区域：young 区域和 old 区域。<code>LRU</code> 列表的示意图如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** LRU 列表示意图</span></span><br><span class=\"line\"><span class=\"comment\">                                                LRU_old</span></span><br><span class=\"line\"><span class=\"comment\">                                                   |</span></span><br><span class=\"line\"><span class=\"comment\">**********************young************************|********old*********</span></span><br><span class=\"line\"><span class=\"comment\">|==================================================|===================|</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">几个主要的常量：</span></span><br><span class=\"line\"><span class=\"comment\">BUF_LRU_OLD_TOLERANCE      20</span></span><br><span class=\"line\"><span class=\"comment\">BUF_LRU_NON_OLD_MIN_LEN    5</span></span><br><span class=\"line\"><span class=\"comment\">BUF_LRU_OLD_MIN_LEN        512</span></span><br><span class=\"line\"><span class=\"comment\">BUF_LRU_OLD_RATIO_DIV      1024</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">参数控制：</span></span><br><span class=\"line\"><span class=\"comment\">innodb_old_block_pct       old 区域占比</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p><code>buf_LRU_old_adjust_len</code>  方法会根据 <code>innodb_old_block_pct</code> 参数，维护 young 区域和 old 区域的长度，主要逻辑如下：</p>\n<ol>\n<li>当 <code>LRU</code> 长度小于 <code>BUF_LRU_OLD_MIN_LEN</code> 时，不划分区域。</li>\n<li>不是每次操作 <code>LRU</code> 列表后都需要立即调整，<code>BUF_LRU_OLD_TOLERANCE</code>  可以看成是容忍范围。</li>\n<li>当 old 区域变大时，LRU_old 指针向前移动；反之向后移动。</li>\n</ol>\n<p>当 Block 被再次访问时，会触发 <code>buf_page_make_young_if_needed</code> 函数进行 Block 位置的调整，基本过程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_page_make_young_if_needed</span><br><span class=\"line\">|    |--&gt; buf_page_peek_if_too_old <span class=\"comment\">// 判断访问间隔</span></span><br><span class=\"line\">|    |    |--&gt; buf_page_peek_if_young <span class=\"comment\">// 判断 young 区域位置</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_page_make_young</span><br><span class=\"line\">|    |    |--&gt; buf_LRU_make_block_young</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_remove_block</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_add_block_low</span><br></pre></td></tr></table></figure>\n\n<p><code>buf_page_make_young_if_needed</code> 移动 Block 时需要考虑：</p>\n<ol>\n<li>访问间隔需要大于 <code>buf_LRU_old_threshold_ms</code> 。</li>\n<li>当 Block 在 young 区域前 1/4 时，不需要移动。</li>\n</ol>\n<p>InnoDB 中 <code>LRU</code> 列表的设计虽然简单，但是也有许多优化在里面，感兴趣的同学可以仔细研究，本文仅是一个简单的介绍。</p>\n<h2 id=\"回收\"><a href=\"#回收\" class=\"headerlink\" title=\"回收\"></a>回收</h2><h3 id=\"释放-Page\"><a href=\"#释放-Page\" class=\"headerlink\" title=\"释放 Page\"></a>释放 Page</h3><p>前面提到，当 <code>free_list</code> 列表为空时，会首先尝试从 <code>LRU</code> 列表中进行回收，Page 的释放入口函数为 <code>buf_LRU_free_page</code> ，该方法的主要处理流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |--&gt; buf_page_can_relocate <span class=\"comment\">// 检查 buf_fix_count 计数和 io_fix 状态</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_LRU_block_remove_hashed <span class=\"comment\">// 从 LRU 和 page_hash 中删除</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_remove_block</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_old_adjust_len</span><br><span class=\"line\">|    |    |--&gt; HASH_DELETE</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; btr_search_drop_page_hash_index <span class=\"comment\">// 从 AHI 中删除</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_LRU_block_free_hashed_page <span class=\"comment\">// 放回 free_list</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_block_free_non_file_page</span><br></pre></td></tr></table></figure>\n\n<p>释放 1 个 Page 时，首先需要检查 <code>io_fix</code> 状态和 <code>buf_fix_count</code> 计数，确保当前 Page 没有被使用，然后将 Block 从依次从 <code>LRU</code> 列表、<code>page_hash</code> 、<code>AHI</code> 中删除，最后将 Block 重新放入到 <code>free_list</code> 列表中。</p>\n<h3 id=\"同步刷脏\"><a href=\"#同步刷脏\" class=\"headerlink\" title=\"同步刷脏\"></a>同步刷脏</h3><p>同步刷脏的入口函数为 <code>buf_flush_page</code> ，同步刷脏过程仅会刷 1 个 Page，保证能够获取到 1 个可用的 Block，主要处理流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_flush_page <span class=\"comment\">// 刷单个 page</span></span><br><span class=\"line\">|    |--&gt; buf_page_set_io_fix <span class=\"comment\">// io_fix 设置为 BUF_IO_WRITE</span></span><br><span class=\"line\">|    |--&gt; buf_flush_write_block_low</span><br><span class=\"line\">|    |    |--&gt; log_write_up_to <span class=\"comment\">// 写 redo</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; fil_io</span><br><span class=\"line\">|    |    |--&gt; buf_dblwr_write_single_page <span class=\"comment\">// 写数据页</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; fil_flush</span><br><span class=\"line\">|    |    |--&gt; buf_page_io_complete</span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_write_complete</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_flush_remove</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_page_set_io_fix <span class=\"comment\">// io_fix 设置为 BUF_IO_NONE</span></span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_free_page</span><br></pre></td></tr></table></figure>\n\n<p>InnoDB 通过严格的 WAL 机制保证数据的一致性，刷脏过程同样如此。首先需要保证对应的日志文件落盘，然后再写入数据页。最后将 Block 从 <code>flush_list</code> 列表中移除，此时 Page 变成可回收状态，再次调用 <code>buf_LRU_free_page</code> 进行回收。</p>\n<p>同步刷脏的过程不仅在获取 Block 时会被调用，在表删除的时候同样会被调用，表删除时会根据 <code>space_id</code> 进行批量的刷脏，入口函数为 <code>buf_LRU_flush_or_remove_pages</code> ，处理流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_LRU_flush_or_remove_pages <span class=\"comment\">// 根据 space_id 刷脏</span></span><br><span class=\"line\">|    |--&gt; buf_LRU_drop_page_hash_for_tablespace <span class=\"comment\">// 遍历 LRU</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_drop_page_hash_batch</span><br><span class=\"line\">|    |    |    |--&gt; btr_search_drop_page_hash_when_freed</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_page_get_gen</span><br><span class=\"line\">|    |    |    |    |--&gt; btr_search_drop_page_hash_index <span class=\"comment\">// 从 AHI 中删除</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_LRU_remove_pages</span><br><span class=\"line\">|    |    |--&gt; buf_LRU_remove_all_pages <span class=\"comment\">// 遍历 LRU</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_block_remove_hashed <span class=\"comment\">// 从 LRU 和 page_hash 中删除</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_block_free_hashed_page <span class=\"comment\">// 放回 free_list</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; buf_flush_dirty_pages</span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_or_remove_pages <span class=\"comment\">// 遍历 flush_list</span></span><br><span class=\"line\">|    |    |    |    |--&gt; buf_flush_or_remove_page</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_flush_remove</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_flush_page</span><br></pre></td></tr></table></figure>\n\n<p>具体的过程在此不再赘述，大家可以自己去阅读相应的代码。需要注意的是：如果单个 session 中使用了临时表，那么在 session 退出的时候，也会进入到上述的刷脏流程，当 <code>LRU</code> 列表很大时，session 退出的性能将会受到很大的影响。</p>\n<h3 id=\"异步刷脏\"><a href=\"#异步刷脏\" class=\"headerlink\" title=\"异步刷脏\"></a>异步刷脏</h3><p>除了同步刷脏之外，MySQL 中还引入单独的刷脏线程进行异步刷脏。刷脏线程按照功能划分包括两种：coordinator 线程和 cleaner 线程。coordinator 线程会计算最大的刷脏量，然后分配刷脏任务给 cleaner 线程，cleaner 线程进行实际的刷脏工作（coordinator 线程本身也会参与刷脏）。异步刷脏的入口函数为 <code>buf_flush_page_cleaner_init</code> ，基本流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_flush_page_coordinator_thread</span><br><span class=\"line\">|    |--&gt; os_event_wait(buf_flush_event)</span><br><span class=\"line\">|    </span><br><span class=\"line\">|    <span class=\"comment\">/* loop */</span></span><br><span class=\"line\">|    |--&gt; page_cleaner_flush_pages_recommendation <span class=\"comment\">// 计算最大刷脏量</span></span><br><span class=\"line\">|    |--&gt; pc_request <span class=\"comment\">// 任务分发，slot 数目等于 bp_instance 数目</span></span><br><span class=\"line\">|    |    |--&gt; os_event_set(page_cleaner-&gt;is_requested)</span><br><span class=\"line\">|    |--&gt; pc_flush_slot <span class=\"comment\">// 参与刷脏</span></span><br><span class=\"line\">|    |--&gt; pc_wait_finished</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; buf_flush_page_cleaner_thread</span><br><span class=\"line\">|    |--&gt; os_event_wait(page_cleaner-&gt;is_requested)</span><br><span class=\"line\">|    |--&gt; pc_flush_slot <span class=\"comment\">// 1 个线程处理 1 个 bp_instance</span></span><br><span class=\"line\">|    |    |--&gt; buf_flush_LRU_list <span class=\"comment\">// 从 LRU 中刷脏</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_do_batch(BUF_FLUSH_LRU)</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; buf_flush_do_batch(BUF_FLUSH_LIST) <span class=\"comment\">// 从 flush_list 刷脏</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_batch</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_do_LRU_batch</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_free_from_unzip_LRU_list_batch</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_flush_LRU_list_batch</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_flush_page_and_try_neighbors</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; buf_flush_try_neighbors</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; buf_flush_page</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_do_flush_list_batch</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_flush_page_and_try_neighbors</span><br></pre></td></tr></table></figure>\n\n<p>异步刷脏的具体过程可以参考<a href=\"http://mysql.taobao.org/monthly/2018/09/02/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，异步刷脏过程中有一个非常重要的点就是 <code>page_cleaner_flush_pages_recommendation</code> 计算最大刷脏量，相关的细节在此不再展开，后面有机会再单独整理一篇各种后台线程的更新逻辑。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文从申请、管理、回收三部分对 InnoDB Buffer Page 的生命周期管理进行了介绍，文中的内容只是一个基本概要，更多的细节还需要读者在阅读代码的过程中慢慢发掘。</p>"},{"title":"Undo Log 的一些基本概念","date":"2020-12-05T13:17:42.000Z","_content":"\n本文主要对 InnoDB 的 Undo Log 进行介绍。\n\n<!-- more -->\n\n## 逻辑结构\n\n<img src=\"/images/innodb-undo-log-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n## 物理结构\n\n### 回滚段\n\n<img src=\"/images/innodb-undo-log-2.png\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\nInnoDB会为每一个读写事务分配回滚段，临时表有单独的回滚段。每一个回滚段内有两个重要的数据结构：\n\n1. Undo slots, 可以理解为undo page的槽位，1个回滚段内部有1024个槽位，每个槽位可以指向`FIL_NULL`或者指向一个真实的undo page地址；回滚段为每个读写事务分配槽位时，只能分配指向`FIL_NULL`的槽位；\n2. TRX_RSEG_HISTORY，维护了一个undo log链表，与undo log中的TRX_UNDO_HISTORY_NODE关联，添加时加到头部；\n\n### undo page\n\n<img src=\"/images/innodb-undo-log-3.png\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n按照上文的描述，InnoDB为每1个读写事务分配一个undo slot槽位，对应的槽位会指向一个undo page。undo page可以分为两个部分：undo page header 和 undo log。undo page header是一个公共的区域，一个undo page内部可能会包含多个undo log，还可能出现undo page的复用。对于undo page header，主要的信息包括：\n\n1. TRX_UNDO_PAGE_FREE：指向当前page的空闲位置\n2. TRX_UNDO_LAST_LOG：指向上一个undo log的开始位置\n3. TRX_UNDO_STATE：当前undo page状态\n4. TRX_UNDO_PAGE_LIST：维护一个undo page的链表，与TRX_UNDO_PAGE_NODE关联，添加时加到尾部\n\n### undo log\n\n<img src=\"/images/innodb-undo-log-4.png\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\nundo内部包括两个部分：undo log header 和 undo  log record，其中undo log header主要信息包括：\n\n1. TRX_UNDO_LOG_START：当前undo log内容(不含header)的开始位置，undo->hdr_offset指向的是包含了header的开始位置，undo->top_offset指向的是log record(不含header)的开始位置\n\n## 生命周期\n\n在介绍undo log的生命周期前，先回答下面几个问题。\n\n1）什么时候申请回滚段？\n\nA：这个问题前面已经提到，当事务升级为读写事务时，会自动的为事务分配回滚段。\n\n2）undo log的写入过程？\n\nA：读写事务分配好回滚段只是相当于做了一个占位，当有IDU操作发生时，才会开始记录undo。记录undo前，首先需要为事务绑定undo slot，寻找undo slot前，首先会去查看回滚段上是否有被cached的undo page，如果有的话，则可以直接拿来使用；如果没有则需要找到一个指向`FIL_NULL`的，然后生成一个新的undo page。\n\n不管是cached的undo page还是新生成的undo page，在写入真实的undo log record前，会提前生成undo log header。然后根据具体的操作，记录相应的record。最后生成roll_ptr，最终绑定到数据行记录上。\n\n3）undo log的回收过程？\n\nA：对于undo log的回收，插入操作和非插入操作的处理流程不同，对于插入操作，可以在事务提交之后，直接清理掉undo log(或者进入cached队列)；对于更新/删除操作，需要后台的purge线程进行删除，事务提交时仅将undo log加入到回滚段的history列表中(或者进入cached队列)，并且会插入一个元素到purge_sys内的最小堆中。purge线程会异步的进行删除。\n\n### 初始化\n\nundo的初始化在innodb启动的时候进行，基本的入口在 srv_start() ：\n\n```c++\n|--> srv_start\n|    |    // Init\n|    |--> srv_undo_tablespaces_init  // create\n|    |    |--> srv_undo_tablespaces_create\n|    |    |    |--> srv_undo_tablespace_create\n|    |    |    |--> srv_undo_tablespace_open\n|    |--> trx_sys_create_sys_pages\n|    |--> trx_sys_init_at_db_start\n|    |    |--> trx_rsegs_init\n|    |    |    |--> trx_rseg_mem_create\n|    |--> trx_purge_sys_create\n|    |\n|    |    // Start\n|    |--> recv_recovery_from_checkpoint_start\n|    |--> recv_recovery_from_checkpoint_finish\n|    |--> srv_undo_tablespaces_init  // open\n|    |    |--> srv_undo_tablespaces_open\n|    |    |    |--> srv_undo_tablespace_open_by_num\n|    |    |    |    |--> srv_undo_tablespace_open\n|    |--> trx_sys_init_at_db_start  \n|    |--> trx_purge_sys_create\n|    |\n|    |--> trx_rseg_adjust_rollback_segments\n|    |    |--> trx_rseg_add_rollback_segments\n|    |    |    |--> trx_rseg_create\n|    |    |    |--> trx_rseg_mem_create\n  \n```\n\n### 数据写入\n\n主要代码入口如下：\n\n```c++\n// 申请回滚段\nvoid trx_assign_rseg_durable(trx_t *trx) {\n  ut_ad(trx->rsegs.m_redo.rseg == nullptr);\n\n  trx->rsegs.m_redo.rseg = srv_read_only_mode ? nullptr : get_next_redo_rseg();\n}\n\n\n|--> trx_set_rw_mode\n|    |--> trx_assign_rseg_durable\n|    |    |--> get_next_redo_rseg\n|    |    |    |--> get_next_redo_rseg_from_trx_sys  // 系统表空间\n|    |    |    |\n|    |    |    |--> get_next_redo_rseg_from_undo_spaces  // 独立 undo 表空间\n|    |\n|    |--> trx_sys_get_new_trx_id\n|    |--> trx_sys->rw_trx_ids.push_back\n|    |--> trx_sys->rw_trx_set.insert\n|    |--> UT_LIST_ADD_FIRST(trx_sys->rw_trx_list)\n```\n\n\n\n```c++\n// 写入undo log\ndberr_t trx_undo_report_row_operation(...) {\n  ...\n  err = trx_undo_assign_undo(trx, undo_ptr, TRX_UNDO_UPDATE);\n  \n  ...\n  offset = trx_undo_page_report_modify(undo_page, trx, index, rec, offsets,\n                                       update, cmpl_info, clust_entry, &mtr);\n  \n  ...\n  *roll_ptr = trx_undo_build_roll_ptr(op_type == TRX_UNDO_INSERT_OP,\n                                      undo_ptr->rseg->space_id, page_no, offset);\n  \n  ...\n}\n\n// 生成undo page\ndberr_t trx_undo_assign_undo(\n    trx_t *trx,               /*!< in: transaction */\n    trx_undo_ptr_t *undo_ptr, /*!< in: assign undo log from\n                              referred rollback segment. */\n    ulint type)               /*!< in: TRX_UNDO_INSERT or\n                              TRX_UNDO_UPDATE */\n{\n  ...\n  undo = trx_undo_reuse_cached(trx, rseg, type, trx->id, trx->xid, &mtr);\n    \n  ...\n  err = trx_undo_create(trx, rseg, type, trx->id, trx->xid, &undo, &mtr);\n}\n\nstatic MY_ATTRIBUTE((warn_unused_result)) dberr_t\n    trx_undo_create(trx_t *trx, trx_rseg_t *rseg, ulint type, trx_id_t trx_id,\n                    const XID *xid, trx_undo_t **undo, mtr_t *mtr) {\n  ...\n  rseg_header = trx_rsegf_get(rseg->space_id, rseg->page_no, rseg->page_size, mtr);\n\n  err = trx_undo_seg_create(rseg, rseg_header, type, &id, &undo_page, mtr);\n\n  ...\n  page_no = page_get_page_no(undo_page);\n\n  offset = trx_undo_header_create(undo_page, trx_id, mtr);\n\n  trx_undo_header_add_space_for_xid(undo_page, undo_page + offset, mtr);\n\n  *undo = trx_undo_mem_create(rseg, id, type, trx_id, xid, page_no, offset);\n  ...\n}\n```\n\n从 MySQL 5.6 开始，MySQL 引入了独立的 undo 表空间，可以通过参数 `innodb_undo_tablespaces` 参数配置独立的 undo 表空间的个数，undo 可以不再通过 ibdata 进行管理（这也极大的减小了 ibdata 的大小）。从 MySQL 5.7 开始支持 truncate undo 表空间，进一步解决了 undo 空间膨胀后无法回收的问题。\n\n在开启独立 undo 表空间的情况下，每个表空间内部包含了 128 个回滚段，读写事务在申请 undo 回滚段时，总是在不同的表空间交替进行分配。\n\n当写操作（插入+更新）操作需要记录 undo 时，会通过已经分配的回滚段找到一个可用的 undo 。在前面的类图中可以看到，每个回滚段上对于不同类型的 undo 保存了两个列表：正在使用的列表和 cached 列表。在分配 undo page 时，会优先从 cached 列表中寻找，如果找不到的话再去分配一个新的 undo 。\n\n前面也提到了，每个回滚段上都有一个 undo slots 数组，数组的长度为 1024，每个 slot 中保存的是一个 undo page 的地址，默认为空（FIL_NULL）。在分配一个新的 undo 时，首先需要找到一个为空的 slot，然后再去创建新的 page，并且将 slot 指向这个 page。结合代码分析一下：\n\n```c++\n|--> trx_undo_seg_create\n|    |--> trx_rsegf_undo_find_free  // 寻找一个 free 的 slot\n|    |\n|    |--> fsp_reserve_free_extents\n|    |--> fseg_create_general  // 创建一个新的 undo page\n|    |--> fil_space_release_free_extents\n|    |\n|    |--> trx_undo_page_init  // 初始化\n|    |--> flst_init  // 维护 TRX_UNDO_PAGE_LIST 列表\n|    |--> flst_add_last\n|    |\n|    |--> trx_rsegf_set_nth_undo  // 修改 slot 指针\n```\n\n### 事务提交\n\n事务提交过程中的undo处理过程可以简化为以下逻辑：\n\n```c++\n|--> ha_commit_trans\n|    |--> trx_prepare_for_mysql\n|    |    |--> trx_undo_set_state_at_prepare\n|    |\n|    |--> trx_commit_for_mysql\n|    |    |--> trx_write_serialisation_history\n|    |    |    |--> trx_serialisation_number_get\n|    |    |    |--> trx_undo_set_state_at_finish\n|    |    |    |--> trx_undo_update_clean\n|    |    |\n|    |    |--> trx_commit_in_memory\n|    |    |    |--> trx_undo_insert_clean\n```\n\n其中，在trx_serialisation_number_get步骤中，会生成TrxUndoRsegs对象，插入到purge_sys->purge_queue中：\n\n```c++\n  if ((redo_rseg != NULL && redo_rseg->last_page_no == FIL_NULL) ||\n      (temp_rseg != NULL && temp_rseg->last_page_no == FIL_NULL)) {\n    TrxUndoRsegs elem(trx->no);\n\n    if (redo_rseg != NULL && redo_rseg->last_page_no == FIL_NULL) {\n      elem.push_back(redo_rseg);\n    }\n\n    if (temp_rseg != NULL && temp_rseg->last_page_no == FIL_NULL) {\n      elem.push_back(temp_rseg);\n    }\n\n    mutex_enter(&purge_sys->pq_mutex);\n\n    trx_sys_mutex_exit();\n\n    purge_sys->purge_queue->push(elem);\n\n    mutex_exit(&purge_sys->pq_mutex);\n  }\n```\n\n在 trx_undo_set_state_at_finish 步骤时，会判断当前 undo 的状态：\n\n```c++\npage_t *trx_undo_set_state_at_finish(...) {\n  ...\n  undo_page = trx_undo_page_get(page_id_t(undo->space, undo->hdr_page_no),\n                                undo->page_size, mtr);\n\n  seg_hdr = undo_page + TRX_UNDO_SEG_HDR;\n  page_hdr = undo_page + TRX_UNDO_PAGE_HDR;\n\n  if (undo->size == 1 && mach_read_from_2(page_hdr + TRX_UNDO_PAGE_FREE) <\n                             TRX_UNDO_PAGE_REUSE_LIMIT) {\n    state = TRX_UNDO_CACHED;\n\n  } else if (undo->type == TRX_UNDO_INSERT) {\n    state = TRX_UNDO_TO_FREE;\n  } else {\n    state = TRX_UNDO_TO_PURGE;\n  }\n\n  undo->state = state;\n\n  mlog_write_ulint(seg_hdr + TRX_UNDO_STATE, state, MLOG_2BYTES, mtr);\n\n  return (undo_page);\n}\n```\n\n在trx_undo_update_clean步骤时，会将undo log加入到对应回滚段上的history列表：\n\n```c++\nvoid trx_undo_update_cleanup(...) {\n  ...\n  trx_purge_add_update_undo_to_history(\n      trx, undo_ptr, undo_page, update_rseg_history_len, n_added_logs, mtr);\n  \n  ...\n  if (undo->state == TRX_UNDO_CACHED) {\n    UT_LIST_ADD_FIRST(rseg->update_undo_cached, undo);\n\n    MONITOR_INC(MONITOR_NUM_UNDO_SLOT_CACHED);\n  } else {\n    ut_ad(undo->state == TRX_UNDO_TO_PURGE);\n\n    trx_undo_mem_free(undo);\n  }\n}\n\nvoid trx_purge_add_update_undo_to_history(...) {\n  ...\n  if (undo->state != TRX_UNDO_CACHED) {\n    ...\n    trx_rsegf_set_nth_undo(rseg_header, undo->id, FIL_NULL, mtr);\n\n    ...\n  }\n  \n  /* Add the log as the first in the history list */\n  flst_add_first(rseg_header + TRX_RSEG_HISTORY,\n                 undo_header + TRX_UNDO_HISTORY_NODE, mtr);\n  \n  ...\n  if (rseg->last_page_no == FIL_NULL) {\n    rseg->last_page_no = undo->hdr_page_no;\n    rseg->last_offset = undo->hdr_offset;\n    rseg->last_trx_no = trx->no;\n    rseg->last_del_marks = undo->del_marks;\n  }\n}\n```\n\n### 后台purge\n\n```c++\n/* srv_start_purge_threads */\n\n|--> srv_purge_coordinator_thread\n|--> srv_worker_thread\n\n\n/* srv_purge_coordinator_thread::trx_purge */\n\n|--> trx_purge_attach_undo_recs // 收集指定数据的 undo pages\n|    |--> trx_purge_fetch_next_rec // loop\n|    |    |--> trx_purge_choose_next_log // 寻找下一个 log\n|    |    |    |--> purge_sys->rseg_iter->set_next() // 更新 purge_sys->rseg 位置\n|    |    |    |--> trx_purge_read_undo_rec // 更新 purge_sys->iter 信息\n|    |    |    |    |--> trx_undo_get_first_rec\n|    |    |\n|    |    |--> trx_undo_build_roll_ptr\n|    |    |--> trx_purge_get_next_rec // 寻找下一个 record\n|    |    |    |--> trx_undo_page_get_next_rec // 从当前 page 寻找下一个 record\n|    |    |    |--> trx_undo_get_next_rec\n|    |    |    |    |--> trx_undo_page_get_next_rec\n|    |    |    |    |--> trx_undo_get_next_rec_from_next_page // 从下一个 page 寻找，TRX_UNDO_PAGE_NODE\n|    |    |    |--> trx_purge_rseg_get_next_history_log // 查找 TRX_UNDO_HISTORY_NODE, 找到下一个 hdr\n|\n|--> que_fork_scheduler_round_robin\n|--> srv_que_task_enqueue_low\n|\n|--> trx_purge_truncate // 清理 undo 文件\n|    |--> trx_purge_truncate_history // 遍历 rsegs\n|    |    |--> trx_purge_truncate_rseg_history // 遍历 TRX_RSEG_HISTORY\n\n\n/* srv_worker_thread::::row_purge_step */\n\n|--> row_purge\n|    |--> row_purge_parse_undo_rec\n|    |--> row_purge_record\n|    |    |--> row_purge_record_func\n|    |    |    |--> row_purge_del_mark\n|    |    |    |--> row_purge_upd_exist_or_extern\n```\n\nundo 的 purge 由后台线程完成，后台线程分为两类：coordinator 线程和 worker 线程。coordinator 线程负责收集和分发 undo log，worker 线程负责实际的 purge 工作（coordinator 线程本身也会参与 purge）。\n\npurge_sys 中维护了一个按照 trx_no 有序的小顶堆结构 purge_queue，在事务提交的过程中（commit阶段）会将事务对应的回滚段添加到 purge_queue 中。需要注意，并不是每次事务提交的时候都会将回滚段添加到 purge_queue 中，只有当 redo_rseg->last_page_no 为空时（即回滚段上之前不存在未 puge 的 undo），才会添加到 purge_queue 中。\n\n若 redo_rseg->last_page_no 非空，则说明该回滚段上存在未 purg 的 undo，此时只会更新回滚段的 TRX_RSEG_HISTORY 列表，将新的 undo 添加到 TRX_RSEG_HISTORY 列表的头部。\n\ncoordinator 线程按照以下的逻辑收集 undo：\n\n1. 从 purge_queue 里面弹出一个元素 TrxUndoRsegs，m_trx_undo_rsegs 指向弹出的元素；\n2. 继续从 purge_queue 弹出元素，若弹出元素的 trx_no 和 m_trx_undo_rsegs 的 trx_no 相同，则直接进行合并，否则退出循环；\n3. m_iter 指向 m_trx_undo_rsegs，开始遍历，purg_sys->rseg 指向待处理的回滚段；\n4. 从待处理的回滚段中依次取 undo_record，若无法取到下一个 undo_record，则需要根据TRX_UNDO_HISTORY 的 next 指针，取下一个 trx 的 undo，并将 trx_rseg_t 重新 放入 purge_queue 中；\n5. m_iter 正常遍历，当遍历到 m_trx_undo_rsegs 尾部时，重复 1；\n\n## 参考文献\n\n>http://mysql.taobao.org/monthly/2015/04/01/\n>\n>http://mysql.taobao.org/monthly/2018/03/01/\n>\n>http://mysql.taobao.org/monthly/2017/12/01/\n\n## 附：undo格式\n\n<img src=\"/images/innodb-undo-log-5.png\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>","source":"_posts/innodb/inndo-undo-log.md","raw":"---\ntitle: Undo Log 的一些基本概念\ndate: 2020-12-05 21:17:42\ncategories: \n- InnoDB\n\n---\n\n本文主要对 InnoDB 的 Undo Log 进行介绍。\n\n<!-- more -->\n\n## 逻辑结构\n\n<img src=\"/images/innodb-undo-log-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n## 物理结构\n\n### 回滚段\n\n<img src=\"/images/innodb-undo-log-2.png\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\nInnoDB会为每一个读写事务分配回滚段，临时表有单独的回滚段。每一个回滚段内有两个重要的数据结构：\n\n1. Undo slots, 可以理解为undo page的槽位，1个回滚段内部有1024个槽位，每个槽位可以指向`FIL_NULL`或者指向一个真实的undo page地址；回滚段为每个读写事务分配槽位时，只能分配指向`FIL_NULL`的槽位；\n2. TRX_RSEG_HISTORY，维护了一个undo log链表，与undo log中的TRX_UNDO_HISTORY_NODE关联，添加时加到头部；\n\n### undo page\n\n<img src=\"/images/innodb-undo-log-3.png\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n按照上文的描述，InnoDB为每1个读写事务分配一个undo slot槽位，对应的槽位会指向一个undo page。undo page可以分为两个部分：undo page header 和 undo log。undo page header是一个公共的区域，一个undo page内部可能会包含多个undo log，还可能出现undo page的复用。对于undo page header，主要的信息包括：\n\n1. TRX_UNDO_PAGE_FREE：指向当前page的空闲位置\n2. TRX_UNDO_LAST_LOG：指向上一个undo log的开始位置\n3. TRX_UNDO_STATE：当前undo page状态\n4. TRX_UNDO_PAGE_LIST：维护一个undo page的链表，与TRX_UNDO_PAGE_NODE关联，添加时加到尾部\n\n### undo log\n\n<img src=\"/images/innodb-undo-log-4.png\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\nundo内部包括两个部分：undo log header 和 undo  log record，其中undo log header主要信息包括：\n\n1. TRX_UNDO_LOG_START：当前undo log内容(不含header)的开始位置，undo->hdr_offset指向的是包含了header的开始位置，undo->top_offset指向的是log record(不含header)的开始位置\n\n## 生命周期\n\n在介绍undo log的生命周期前，先回答下面几个问题。\n\n1）什么时候申请回滚段？\n\nA：这个问题前面已经提到，当事务升级为读写事务时，会自动的为事务分配回滚段。\n\n2）undo log的写入过程？\n\nA：读写事务分配好回滚段只是相当于做了一个占位，当有IDU操作发生时，才会开始记录undo。记录undo前，首先需要为事务绑定undo slot，寻找undo slot前，首先会去查看回滚段上是否有被cached的undo page，如果有的话，则可以直接拿来使用；如果没有则需要找到一个指向`FIL_NULL`的，然后生成一个新的undo page。\n\n不管是cached的undo page还是新生成的undo page，在写入真实的undo log record前，会提前生成undo log header。然后根据具体的操作，记录相应的record。最后生成roll_ptr，最终绑定到数据行记录上。\n\n3）undo log的回收过程？\n\nA：对于undo log的回收，插入操作和非插入操作的处理流程不同，对于插入操作，可以在事务提交之后，直接清理掉undo log(或者进入cached队列)；对于更新/删除操作，需要后台的purge线程进行删除，事务提交时仅将undo log加入到回滚段的history列表中(或者进入cached队列)，并且会插入一个元素到purge_sys内的最小堆中。purge线程会异步的进行删除。\n\n### 初始化\n\nundo的初始化在innodb启动的时候进行，基本的入口在 srv_start() ：\n\n```c++\n|--> srv_start\n|    |    // Init\n|    |--> srv_undo_tablespaces_init  // create\n|    |    |--> srv_undo_tablespaces_create\n|    |    |    |--> srv_undo_tablespace_create\n|    |    |    |--> srv_undo_tablespace_open\n|    |--> trx_sys_create_sys_pages\n|    |--> trx_sys_init_at_db_start\n|    |    |--> trx_rsegs_init\n|    |    |    |--> trx_rseg_mem_create\n|    |--> trx_purge_sys_create\n|    |\n|    |    // Start\n|    |--> recv_recovery_from_checkpoint_start\n|    |--> recv_recovery_from_checkpoint_finish\n|    |--> srv_undo_tablespaces_init  // open\n|    |    |--> srv_undo_tablespaces_open\n|    |    |    |--> srv_undo_tablespace_open_by_num\n|    |    |    |    |--> srv_undo_tablespace_open\n|    |--> trx_sys_init_at_db_start  \n|    |--> trx_purge_sys_create\n|    |\n|    |--> trx_rseg_adjust_rollback_segments\n|    |    |--> trx_rseg_add_rollback_segments\n|    |    |    |--> trx_rseg_create\n|    |    |    |--> trx_rseg_mem_create\n  \n```\n\n### 数据写入\n\n主要代码入口如下：\n\n```c++\n// 申请回滚段\nvoid trx_assign_rseg_durable(trx_t *trx) {\n  ut_ad(trx->rsegs.m_redo.rseg == nullptr);\n\n  trx->rsegs.m_redo.rseg = srv_read_only_mode ? nullptr : get_next_redo_rseg();\n}\n\n\n|--> trx_set_rw_mode\n|    |--> trx_assign_rseg_durable\n|    |    |--> get_next_redo_rseg\n|    |    |    |--> get_next_redo_rseg_from_trx_sys  // 系统表空间\n|    |    |    |\n|    |    |    |--> get_next_redo_rseg_from_undo_spaces  // 独立 undo 表空间\n|    |\n|    |--> trx_sys_get_new_trx_id\n|    |--> trx_sys->rw_trx_ids.push_back\n|    |--> trx_sys->rw_trx_set.insert\n|    |--> UT_LIST_ADD_FIRST(trx_sys->rw_trx_list)\n```\n\n\n\n```c++\n// 写入undo log\ndberr_t trx_undo_report_row_operation(...) {\n  ...\n  err = trx_undo_assign_undo(trx, undo_ptr, TRX_UNDO_UPDATE);\n  \n  ...\n  offset = trx_undo_page_report_modify(undo_page, trx, index, rec, offsets,\n                                       update, cmpl_info, clust_entry, &mtr);\n  \n  ...\n  *roll_ptr = trx_undo_build_roll_ptr(op_type == TRX_UNDO_INSERT_OP,\n                                      undo_ptr->rseg->space_id, page_no, offset);\n  \n  ...\n}\n\n// 生成undo page\ndberr_t trx_undo_assign_undo(\n    trx_t *trx,               /*!< in: transaction */\n    trx_undo_ptr_t *undo_ptr, /*!< in: assign undo log from\n                              referred rollback segment. */\n    ulint type)               /*!< in: TRX_UNDO_INSERT or\n                              TRX_UNDO_UPDATE */\n{\n  ...\n  undo = trx_undo_reuse_cached(trx, rseg, type, trx->id, trx->xid, &mtr);\n    \n  ...\n  err = trx_undo_create(trx, rseg, type, trx->id, trx->xid, &undo, &mtr);\n}\n\nstatic MY_ATTRIBUTE((warn_unused_result)) dberr_t\n    trx_undo_create(trx_t *trx, trx_rseg_t *rseg, ulint type, trx_id_t trx_id,\n                    const XID *xid, trx_undo_t **undo, mtr_t *mtr) {\n  ...\n  rseg_header = trx_rsegf_get(rseg->space_id, rseg->page_no, rseg->page_size, mtr);\n\n  err = trx_undo_seg_create(rseg, rseg_header, type, &id, &undo_page, mtr);\n\n  ...\n  page_no = page_get_page_no(undo_page);\n\n  offset = trx_undo_header_create(undo_page, trx_id, mtr);\n\n  trx_undo_header_add_space_for_xid(undo_page, undo_page + offset, mtr);\n\n  *undo = trx_undo_mem_create(rseg, id, type, trx_id, xid, page_no, offset);\n  ...\n}\n```\n\n从 MySQL 5.6 开始，MySQL 引入了独立的 undo 表空间，可以通过参数 `innodb_undo_tablespaces` 参数配置独立的 undo 表空间的个数，undo 可以不再通过 ibdata 进行管理（这也极大的减小了 ibdata 的大小）。从 MySQL 5.7 开始支持 truncate undo 表空间，进一步解决了 undo 空间膨胀后无法回收的问题。\n\n在开启独立 undo 表空间的情况下，每个表空间内部包含了 128 个回滚段，读写事务在申请 undo 回滚段时，总是在不同的表空间交替进行分配。\n\n当写操作（插入+更新）操作需要记录 undo 时，会通过已经分配的回滚段找到一个可用的 undo 。在前面的类图中可以看到，每个回滚段上对于不同类型的 undo 保存了两个列表：正在使用的列表和 cached 列表。在分配 undo page 时，会优先从 cached 列表中寻找，如果找不到的话再去分配一个新的 undo 。\n\n前面也提到了，每个回滚段上都有一个 undo slots 数组，数组的长度为 1024，每个 slot 中保存的是一个 undo page 的地址，默认为空（FIL_NULL）。在分配一个新的 undo 时，首先需要找到一个为空的 slot，然后再去创建新的 page，并且将 slot 指向这个 page。结合代码分析一下：\n\n```c++\n|--> trx_undo_seg_create\n|    |--> trx_rsegf_undo_find_free  // 寻找一个 free 的 slot\n|    |\n|    |--> fsp_reserve_free_extents\n|    |--> fseg_create_general  // 创建一个新的 undo page\n|    |--> fil_space_release_free_extents\n|    |\n|    |--> trx_undo_page_init  // 初始化\n|    |--> flst_init  // 维护 TRX_UNDO_PAGE_LIST 列表\n|    |--> flst_add_last\n|    |\n|    |--> trx_rsegf_set_nth_undo  // 修改 slot 指针\n```\n\n### 事务提交\n\n事务提交过程中的undo处理过程可以简化为以下逻辑：\n\n```c++\n|--> ha_commit_trans\n|    |--> trx_prepare_for_mysql\n|    |    |--> trx_undo_set_state_at_prepare\n|    |\n|    |--> trx_commit_for_mysql\n|    |    |--> trx_write_serialisation_history\n|    |    |    |--> trx_serialisation_number_get\n|    |    |    |--> trx_undo_set_state_at_finish\n|    |    |    |--> trx_undo_update_clean\n|    |    |\n|    |    |--> trx_commit_in_memory\n|    |    |    |--> trx_undo_insert_clean\n```\n\n其中，在trx_serialisation_number_get步骤中，会生成TrxUndoRsegs对象，插入到purge_sys->purge_queue中：\n\n```c++\n  if ((redo_rseg != NULL && redo_rseg->last_page_no == FIL_NULL) ||\n      (temp_rseg != NULL && temp_rseg->last_page_no == FIL_NULL)) {\n    TrxUndoRsegs elem(trx->no);\n\n    if (redo_rseg != NULL && redo_rseg->last_page_no == FIL_NULL) {\n      elem.push_back(redo_rseg);\n    }\n\n    if (temp_rseg != NULL && temp_rseg->last_page_no == FIL_NULL) {\n      elem.push_back(temp_rseg);\n    }\n\n    mutex_enter(&purge_sys->pq_mutex);\n\n    trx_sys_mutex_exit();\n\n    purge_sys->purge_queue->push(elem);\n\n    mutex_exit(&purge_sys->pq_mutex);\n  }\n```\n\n在 trx_undo_set_state_at_finish 步骤时，会判断当前 undo 的状态：\n\n```c++\npage_t *trx_undo_set_state_at_finish(...) {\n  ...\n  undo_page = trx_undo_page_get(page_id_t(undo->space, undo->hdr_page_no),\n                                undo->page_size, mtr);\n\n  seg_hdr = undo_page + TRX_UNDO_SEG_HDR;\n  page_hdr = undo_page + TRX_UNDO_PAGE_HDR;\n\n  if (undo->size == 1 && mach_read_from_2(page_hdr + TRX_UNDO_PAGE_FREE) <\n                             TRX_UNDO_PAGE_REUSE_LIMIT) {\n    state = TRX_UNDO_CACHED;\n\n  } else if (undo->type == TRX_UNDO_INSERT) {\n    state = TRX_UNDO_TO_FREE;\n  } else {\n    state = TRX_UNDO_TO_PURGE;\n  }\n\n  undo->state = state;\n\n  mlog_write_ulint(seg_hdr + TRX_UNDO_STATE, state, MLOG_2BYTES, mtr);\n\n  return (undo_page);\n}\n```\n\n在trx_undo_update_clean步骤时，会将undo log加入到对应回滚段上的history列表：\n\n```c++\nvoid trx_undo_update_cleanup(...) {\n  ...\n  trx_purge_add_update_undo_to_history(\n      trx, undo_ptr, undo_page, update_rseg_history_len, n_added_logs, mtr);\n  \n  ...\n  if (undo->state == TRX_UNDO_CACHED) {\n    UT_LIST_ADD_FIRST(rseg->update_undo_cached, undo);\n\n    MONITOR_INC(MONITOR_NUM_UNDO_SLOT_CACHED);\n  } else {\n    ut_ad(undo->state == TRX_UNDO_TO_PURGE);\n\n    trx_undo_mem_free(undo);\n  }\n}\n\nvoid trx_purge_add_update_undo_to_history(...) {\n  ...\n  if (undo->state != TRX_UNDO_CACHED) {\n    ...\n    trx_rsegf_set_nth_undo(rseg_header, undo->id, FIL_NULL, mtr);\n\n    ...\n  }\n  \n  /* Add the log as the first in the history list */\n  flst_add_first(rseg_header + TRX_RSEG_HISTORY,\n                 undo_header + TRX_UNDO_HISTORY_NODE, mtr);\n  \n  ...\n  if (rseg->last_page_no == FIL_NULL) {\n    rseg->last_page_no = undo->hdr_page_no;\n    rseg->last_offset = undo->hdr_offset;\n    rseg->last_trx_no = trx->no;\n    rseg->last_del_marks = undo->del_marks;\n  }\n}\n```\n\n### 后台purge\n\n```c++\n/* srv_start_purge_threads */\n\n|--> srv_purge_coordinator_thread\n|--> srv_worker_thread\n\n\n/* srv_purge_coordinator_thread::trx_purge */\n\n|--> trx_purge_attach_undo_recs // 收集指定数据的 undo pages\n|    |--> trx_purge_fetch_next_rec // loop\n|    |    |--> trx_purge_choose_next_log // 寻找下一个 log\n|    |    |    |--> purge_sys->rseg_iter->set_next() // 更新 purge_sys->rseg 位置\n|    |    |    |--> trx_purge_read_undo_rec // 更新 purge_sys->iter 信息\n|    |    |    |    |--> trx_undo_get_first_rec\n|    |    |\n|    |    |--> trx_undo_build_roll_ptr\n|    |    |--> trx_purge_get_next_rec // 寻找下一个 record\n|    |    |    |--> trx_undo_page_get_next_rec // 从当前 page 寻找下一个 record\n|    |    |    |--> trx_undo_get_next_rec\n|    |    |    |    |--> trx_undo_page_get_next_rec\n|    |    |    |    |--> trx_undo_get_next_rec_from_next_page // 从下一个 page 寻找，TRX_UNDO_PAGE_NODE\n|    |    |    |--> trx_purge_rseg_get_next_history_log // 查找 TRX_UNDO_HISTORY_NODE, 找到下一个 hdr\n|\n|--> que_fork_scheduler_round_robin\n|--> srv_que_task_enqueue_low\n|\n|--> trx_purge_truncate // 清理 undo 文件\n|    |--> trx_purge_truncate_history // 遍历 rsegs\n|    |    |--> trx_purge_truncate_rseg_history // 遍历 TRX_RSEG_HISTORY\n\n\n/* srv_worker_thread::::row_purge_step */\n\n|--> row_purge\n|    |--> row_purge_parse_undo_rec\n|    |--> row_purge_record\n|    |    |--> row_purge_record_func\n|    |    |    |--> row_purge_del_mark\n|    |    |    |--> row_purge_upd_exist_or_extern\n```\n\nundo 的 purge 由后台线程完成，后台线程分为两类：coordinator 线程和 worker 线程。coordinator 线程负责收集和分发 undo log，worker 线程负责实际的 purge 工作（coordinator 线程本身也会参与 purge）。\n\npurge_sys 中维护了一个按照 trx_no 有序的小顶堆结构 purge_queue，在事务提交的过程中（commit阶段）会将事务对应的回滚段添加到 purge_queue 中。需要注意，并不是每次事务提交的时候都会将回滚段添加到 purge_queue 中，只有当 redo_rseg->last_page_no 为空时（即回滚段上之前不存在未 puge 的 undo），才会添加到 purge_queue 中。\n\n若 redo_rseg->last_page_no 非空，则说明该回滚段上存在未 purg 的 undo，此时只会更新回滚段的 TRX_RSEG_HISTORY 列表，将新的 undo 添加到 TRX_RSEG_HISTORY 列表的头部。\n\ncoordinator 线程按照以下的逻辑收集 undo：\n\n1. 从 purge_queue 里面弹出一个元素 TrxUndoRsegs，m_trx_undo_rsegs 指向弹出的元素；\n2. 继续从 purge_queue 弹出元素，若弹出元素的 trx_no 和 m_trx_undo_rsegs 的 trx_no 相同，则直接进行合并，否则退出循环；\n3. m_iter 指向 m_trx_undo_rsegs，开始遍历，purg_sys->rseg 指向待处理的回滚段；\n4. 从待处理的回滚段中依次取 undo_record，若无法取到下一个 undo_record，则需要根据TRX_UNDO_HISTORY 的 next 指针，取下一个 trx 的 undo，并将 trx_rseg_t 重新 放入 purge_queue 中；\n5. m_iter 正常遍历，当遍历到 m_trx_undo_rsegs 尾部时，重复 1；\n\n## 参考文献\n\n>http://mysql.taobao.org/monthly/2015/04/01/\n>\n>http://mysql.taobao.org/monthly/2018/03/01/\n>\n>http://mysql.taobao.org/monthly/2017/12/01/\n\n## 附：undo格式\n\n<img src=\"/images/innodb-undo-log-5.png\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>","slug":"innodb/inndo-undo-log","published":1,"updated":"2020-12-05T13:27:49.594Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4x8000cgugm3znafcla","content":"<p>本文主要对 InnoDB 的 Undo Log 进行介绍。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"逻辑结构\"><a href=\"#逻辑结构\" class=\"headerlink\" title=\"逻辑结构\"></a>逻辑结构</h2><img src=\"/images/innodb-undo-log-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<h2 id=\"物理结构\"><a href=\"#物理结构\" class=\"headerlink\" title=\"物理结构\"></a>物理结构</h2><h3 id=\"回滚段\"><a href=\"#回滚段\" class=\"headerlink\" title=\"回滚段\"></a>回滚段</h3><img src=\"/images/innodb-undo-log-2.png\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>InnoDB会为每一个读写事务分配回滚段，临时表有单独的回滚段。每一个回滚段内有两个重要的数据结构：</p>\n<ol>\n<li>Undo slots, 可以理解为undo page的槽位，1个回滚段内部有1024个槽位，每个槽位可以指向<code>FIL_NULL</code>或者指向一个真实的undo page地址；回滚段为每个读写事务分配槽位时，只能分配指向<code>FIL_NULL</code>的槽位；</li>\n<li>TRX_RSEG_HISTORY，维护了一个undo log链表，与undo log中的TRX_UNDO_HISTORY_NODE关联，添加时加到头部；</li>\n</ol>\n<h3 id=\"undo-page\"><a href=\"#undo-page\" class=\"headerlink\" title=\"undo page\"></a>undo page</h3><img src=\"/images/innodb-undo-log-3.png\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>按照上文的描述，InnoDB为每1个读写事务分配一个undo slot槽位，对应的槽位会指向一个undo page。undo page可以分为两个部分：undo page header 和 undo log。undo page header是一个公共的区域，一个undo page内部可能会包含多个undo log，还可能出现undo page的复用。对于undo page header，主要的信息包括：</p>\n<ol>\n<li>TRX_UNDO_PAGE_FREE：指向当前page的空闲位置</li>\n<li>TRX_UNDO_LAST_LOG：指向上一个undo log的开始位置</li>\n<li>TRX_UNDO_STATE：当前undo page状态</li>\n<li>TRX_UNDO_PAGE_LIST：维护一个undo page的链表，与TRX_UNDO_PAGE_NODE关联，添加时加到尾部</li>\n</ol>\n<h3 id=\"undo-log\"><a href=\"#undo-log\" class=\"headerlink\" title=\"undo log\"></a>undo log</h3><img src=\"/images/innodb-undo-log-4.png\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>undo内部包括两个部分：undo log header 和 undo  log record，其中undo log header主要信息包括：</p>\n<ol>\n<li>TRX_UNDO_LOG_START：当前undo log内容(不含header)的开始位置，undo-&gt;hdr_offset指向的是包含了header的开始位置，undo-&gt;top_offset指向的是log record(不含header)的开始位置</li>\n</ol>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>在介绍undo log的生命周期前，先回答下面几个问题。</p>\n<p>1）什么时候申请回滚段？</p>\n<p>A：这个问题前面已经提到，当事务升级为读写事务时，会自动的为事务分配回滚段。</p>\n<p>2）undo log的写入过程？</p>\n<p>A：读写事务分配好回滚段只是相当于做了一个占位，当有IDU操作发生时，才会开始记录undo。记录undo前，首先需要为事务绑定undo slot，寻找undo slot前，首先会去查看回滚段上是否有被cached的undo page，如果有的话，则可以直接拿来使用；如果没有则需要找到一个指向<code>FIL_NULL</code>的，然后生成一个新的undo page。</p>\n<p>不管是cached的undo page还是新生成的undo page，在写入真实的undo log record前，会提前生成undo log header。然后根据具体的操作，记录相应的record。最后生成roll_ptr，最终绑定到数据行记录上。</p>\n<p>3）undo log的回收过程？</p>\n<p>A：对于undo log的回收，插入操作和非插入操作的处理流程不同，对于插入操作，可以在事务提交之后，直接清理掉undo log(或者进入cached队列)；对于更新/删除操作，需要后台的purge线程进行删除，事务提交时仅将undo log加入到回滚段的history列表中(或者进入cached队列)，并且会插入一个元素到purge_sys内的最小堆中。purge线程会异步的进行删除。</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>undo的初始化在innodb启动的时候进行，基本的入口在 srv_start() ：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; srv_start</span><br><span class=\"line\">|    |    <span class=\"comment\">// Init</span></span><br><span class=\"line\">|    |--&gt; srv_undo_tablespaces_init  <span class=\"comment\">// create</span></span><br><span class=\"line\">|    |    |--&gt; srv_undo_tablespaces_create</span><br><span class=\"line\">|    |    |    |--&gt; srv_undo_tablespace_create</span><br><span class=\"line\">|    |    |    |--&gt; srv_undo_tablespace_open</span><br><span class=\"line\">|    |--&gt; trx_sys_create_sys_pages</span><br><span class=\"line\">|    |--&gt; trx_sys_init_at_db_start</span><br><span class=\"line\">|    |    |--&gt; trx_rsegs_init</span><br><span class=\"line\">|    |    |    |--&gt; trx_rseg_mem_create</span><br><span class=\"line\">|    |--&gt; trx_purge_sys_create</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |    <span class=\"comment\">// Start</span></span><br><span class=\"line\">|    |--&gt; recv_recovery_from_checkpoint_start</span><br><span class=\"line\">|    |--&gt; recv_recovery_from_checkpoint_finish</span><br><span class=\"line\">|    |--&gt; srv_undo_tablespaces_init  <span class=\"comment\">// open</span></span><br><span class=\"line\">|    |    |--&gt; srv_undo_tablespaces_open</span><br><span class=\"line\">|    |    |    |--&gt; srv_undo_tablespace_open_by_num</span><br><span class=\"line\">|    |    |    |    |--&gt; srv_undo_tablespace_open</span><br><span class=\"line\">|    |--&gt; trx_sys_init_at_db_start  </span><br><span class=\"line\">|    |--&gt; trx_purge_sys_create</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; trx_rseg_adjust_rollback_segments</span><br><span class=\"line\">|    |    |--&gt; trx_rseg_add_rollback_segments</span><br><span class=\"line\">|    |    |    |--&gt; trx_rseg_create</span><br><span class=\"line\">|    |    |    |--&gt; trx_rseg_mem_create</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据写入\"><a href=\"#数据写入\" class=\"headerlink\" title=\"数据写入\"></a>数据写入</h3><p>主要代码入口如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 申请回滚段</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">trx_assign_rseg_durable</span><span class=\"params\">(<span class=\"keyword\">trx_t</span> *trx)</span> </span>&#123;</span><br><span class=\"line\">  ut_ad(trx-&gt;rsegs.m_redo.rseg == <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  trx-&gt;rsegs.m_redo.rseg = srv_read_only_mode ? <span class=\"literal\">nullptr</span> : get_next_redo_rseg();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; trx_set_rw_mode</span><br><span class=\"line\">|    |--&gt; trx_assign_rseg_durable</span><br><span class=\"line\">|    |    |--&gt; get_next_redo_rseg</span><br><span class=\"line\">|    |    |    |--&gt; get_next_redo_rseg_from_trx_sys  <span class=\"comment\">// 系统表空间</span></span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; get_next_redo_rseg_from_undo_spaces  <span class=\"comment\">// 独立 undo 表空间</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; trx_sys_get_new_trx_id</span><br><span class=\"line\">|    |--&gt; trx_sys-&gt;rw_trx_ids.push_back</span><br><span class=\"line\">|    |--&gt; trx_sys-&gt;rw_trx_set.insert</span><br><span class=\"line\">|    |--&gt; UT_LIST_ADD_FIRST(trx_sys-&gt;rw_trx_list)</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 写入undo log</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">dberr_t</span> <span class=\"title\">trx_undo_report_row_operation</span><span class=\"params\">(...)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  err = trx_undo_assign_undo(trx, undo_ptr, TRX_UNDO_UPDATE);</span><br><span class=\"line\">  </span><br><span class=\"line\">  ...</span><br><span class=\"line\">  offset = trx_undo_page_report_modify(undo_page, trx, index, rec, offsets,</span><br><span class=\"line\">                                       update, cmpl_info, clust_entry, &amp;mtr);</span><br><span class=\"line\">  </span><br><span class=\"line\">  ...</span><br><span class=\"line\">  *roll_ptr = trx_undo_build_roll_ptr(op_type == TRX_UNDO_INSERT_OP,</span><br><span class=\"line\">                                      undo_ptr-&gt;rseg-&gt;space_id, page_no, offset);</span><br><span class=\"line\">  </span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成undo page</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">dberr_t</span> <span class=\"title\">trx_undo_assign_undo</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">trx_t</span> *trx,               <span class=\"comment\">/*!&lt; in: transaction */</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">trx_undo_ptr_t</span> *undo_ptr, <span class=\"comment\">/*!&lt; in: assign undo log from</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"comment\">                              referred rollback segment. */</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    ulint type)</span>               <span class=\"comment\">/*!&lt; in: TRX_UNDO_INSERT or</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">                              TRX_UNDO_UPDATE */</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  undo = trx_undo_reuse_cached(trx, rseg, type, trx-&gt;id, trx-&gt;xid, &amp;mtr);</span><br><span class=\"line\">    </span><br><span class=\"line\">  ...</span><br><span class=\"line\">  err = trx_undo_create(trx, rseg, type, trx-&gt;id, trx-&gt;xid, &amp;undo, &amp;mtr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"title\">MY_ATTRIBUTE</span><span class=\"params\">((warn_unused_result))</span> <span class=\"keyword\">dberr_t</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">trx_undo_create</span><span class=\"params\">(<span class=\"keyword\">trx_t</span> *trx, <span class=\"keyword\">trx_rseg_t</span> *rseg, ulint type, <span class=\"keyword\">trx_id_t</span> trx_id,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    <span class=\"keyword\">const</span> XID *xid, <span class=\"keyword\">trx_undo_t</span> **undo, <span class=\"keyword\">mtr_t</span> *mtr)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  rseg_header = trx_rsegf_get(rseg-&gt;space_id, rseg-&gt;page_no, rseg-&gt;page_size, mtr);</span><br><span class=\"line\"></span><br><span class=\"line\">  err = trx_undo_seg_create(rseg, rseg_header, type, &amp;id, &amp;undo_page, mtr);</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  page_no = page_get_page_no(undo_page);</span><br><span class=\"line\"></span><br><span class=\"line\">  offset = trx_undo_header_create(undo_page, trx_id, mtr);</span><br><span class=\"line\"></span><br><span class=\"line\">  trx_undo_header_add_space_for_xid(undo_page, undo_page + offset, mtr);</span><br><span class=\"line\"></span><br><span class=\"line\">  *undo = trx_undo_mem_create(rseg, id, type, trx_id, xid, page_no, offset);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从 MySQL 5.6 开始，MySQL 引入了独立的 undo 表空间，可以通过参数 <code>innodb_undo_tablespaces</code> 参数配置独立的 undo 表空间的个数，undo 可以不再通过 ibdata 进行管理（这也极大的减小了 ibdata 的大小）。从 MySQL 5.7 开始支持 truncate undo 表空间，进一步解决了 undo 空间膨胀后无法回收的问题。</p>\n<p>在开启独立 undo 表空间的情况下，每个表空间内部包含了 128 个回滚段，读写事务在申请 undo 回滚段时，总是在不同的表空间交替进行分配。</p>\n<p>当写操作（插入+更新）操作需要记录 undo 时，会通过已经分配的回滚段找到一个可用的 undo 。在前面的类图中可以看到，每个回滚段上对于不同类型的 undo 保存了两个列表：正在使用的列表和 cached 列表。在分配 undo page 时，会优先从 cached 列表中寻找，如果找不到的话再去分配一个新的 undo 。</p>\n<p>前面也提到了，每个回滚段上都有一个 undo slots 数组，数组的长度为 1024，每个 slot 中保存的是一个 undo page 的地址，默认为空（FIL_NULL）。在分配一个新的 undo 时，首先需要找到一个为空的 slot，然后再去创建新的 page，并且将 slot 指向这个 page。结合代码分析一下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; trx_undo_seg_create</span><br><span class=\"line\">|    |--&gt; trx_rsegf_undo_find_free  <span class=\"comment\">// 寻找一个 free 的 slot</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; fsp_reserve_free_extents</span><br><span class=\"line\">|    |--&gt; fseg_create_general  <span class=\"comment\">// 创建一个新的 undo page</span></span><br><span class=\"line\">|    |--&gt; fil_space_release_free_extents</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; trx_undo_page_init  <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">|    |--&gt; flst_init  <span class=\"comment\">// 维护 TRX_UNDO_PAGE_LIST 列表</span></span><br><span class=\"line\">|    |--&gt; flst_add_last</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; trx_rsegf_set_nth_undo  <span class=\"comment\">// 修改 slot 指针</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"事务提交\"><a href=\"#事务提交\" class=\"headerlink\" title=\"事务提交\"></a>事务提交</h3><p>事务提交过程中的undo处理过程可以简化为以下逻辑：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; ha_commit_trans</span><br><span class=\"line\">|    |--&gt; trx_prepare_for_mysql</span><br><span class=\"line\">|    |    |--&gt; trx_undo_set_state_at_prepare</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; trx_commit_for_mysql</span><br><span class=\"line\">|    |    |--&gt; trx_write_serialisation_history</span><br><span class=\"line\">|    |    |    |--&gt; trx_serialisation_number_get</span><br><span class=\"line\">|    |    |    |--&gt; trx_undo_set_state_at_finish</span><br><span class=\"line\">|    |    |    |--&gt; trx_undo_update_clean</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; trx_commit_in_memory</span><br><span class=\"line\">|    |    |    |--&gt; trx_undo_insert_clean</span><br></pre></td></tr></table></figure>\n\n<p>其中，在trx_serialisation_number_get步骤中，会生成TrxUndoRsegs对象，插入到purge_sys-&gt;purge_queue中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((redo_rseg != <span class=\"literal\">NULL</span> &amp;&amp; redo_rseg-&gt;last_page_no == FIL_NULL) ||</span><br><span class=\"line\">    (temp_rseg != <span class=\"literal\">NULL</span> &amp;&amp; temp_rseg-&gt;last_page_no == FIL_NULL)) &#123;</span><br><span class=\"line\">  <span class=\"function\">TrxUndoRsegs <span class=\"title\">elem</span><span class=\"params\">(trx-&gt;no)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (redo_rseg != <span class=\"literal\">NULL</span> &amp;&amp; redo_rseg-&gt;last_page_no == FIL_NULL) &#123;</span><br><span class=\"line\">    elem.push_back(redo_rseg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (temp_rseg != <span class=\"literal\">NULL</span> &amp;&amp; temp_rseg-&gt;last_page_no == FIL_NULL) &#123;</span><br><span class=\"line\">    elem.push_back(temp_rseg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  mutex_enter(&amp;purge_sys-&gt;pq_mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">  trx_sys_mutex_exit();</span><br><span class=\"line\"></span><br><span class=\"line\">  purge_sys-&gt;purge_queue-&gt;push(elem);</span><br><span class=\"line\"></span><br><span class=\"line\">  mutex_exit(&amp;purge_sys-&gt;pq_mutex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 trx_undo_set_state_at_finish 步骤时，会判断当前 undo 的状态：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">page_t</span> *<span class=\"title\">trx_undo_set_state_at_finish</span><span class=\"params\">(...)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  undo_page = trx_undo_page_get(<span class=\"keyword\">page_id_t</span>(undo-&gt;space, undo-&gt;hdr_page_no),</span><br><span class=\"line\">                                undo-&gt;page_size, mtr);</span><br><span class=\"line\"></span><br><span class=\"line\">  seg_hdr = undo_page + TRX_UNDO_SEG_HDR;</span><br><span class=\"line\">  page_hdr = undo_page + TRX_UNDO_PAGE_HDR;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (undo-&gt;<span class=\"built_in\">size</span> == <span class=\"number\">1</span> &amp;&amp; mach_read_from_2(page_hdr + TRX_UNDO_PAGE_FREE) &lt;</span><br><span class=\"line\">                             TRX_UNDO_PAGE_REUSE_LIMIT) &#123;</span><br><span class=\"line\">    state = TRX_UNDO_CACHED;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (undo-&gt;type == TRX_UNDO_INSERT) &#123;</span><br><span class=\"line\">    state = TRX_UNDO_TO_FREE;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    state = TRX_UNDO_TO_PURGE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  undo-&gt;state = state;</span><br><span class=\"line\"></span><br><span class=\"line\">  mlog_write_ulint(seg_hdr + TRX_UNDO_STATE, state, MLOG_2BYTES, mtr);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (undo_page);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在trx_undo_update_clean步骤时，会将undo log加入到对应回滚段上的history列表：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">trx_undo_update_cleanup</span><span class=\"params\">(...)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  trx_purge_add_update_undo_to_history(</span><br><span class=\"line\">      trx, undo_ptr, undo_page, update_rseg_history_len, n_added_logs, mtr);</span><br><span class=\"line\">  </span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (undo-&gt;state == TRX_UNDO_CACHED) &#123;</span><br><span class=\"line\">    UT_LIST_ADD_FIRST(rseg-&gt;update_undo_cached, undo);</span><br><span class=\"line\"></span><br><span class=\"line\">    MONITOR_INC(MONITOR_NUM_UNDO_SLOT_CACHED);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ut_ad(undo-&gt;state == TRX_UNDO_TO_PURGE);</span><br><span class=\"line\"></span><br><span class=\"line\">    trx_undo_mem_free(undo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">trx_purge_add_update_undo_to_history</span><span class=\"params\">(...)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (undo-&gt;state != TRX_UNDO_CACHED) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    trx_rsegf_set_nth_undo(rseg_header, undo-&gt;id, FIL_NULL, mtr);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Add the log as the first in the history list */</span></span><br><span class=\"line\">  flst_add_first(rseg_header + TRX_RSEG_HISTORY,</span><br><span class=\"line\">                 undo_header + TRX_UNDO_HISTORY_NODE, mtr);</span><br><span class=\"line\">  </span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (rseg-&gt;last_page_no == FIL_NULL) &#123;</span><br><span class=\"line\">    rseg-&gt;last_page_no = undo-&gt;hdr_page_no;</span><br><span class=\"line\">    rseg-&gt;last_offset = undo-&gt;hdr_offset;</span><br><span class=\"line\">    rseg-&gt;last_trx_no = trx-&gt;no;</span><br><span class=\"line\">    rseg-&gt;last_del_marks = undo-&gt;del_marks;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"后台purge\"><a href=\"#后台purge\" class=\"headerlink\" title=\"后台purge\"></a>后台purge</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* srv_start_purge_threads */</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; srv_purge_coordinator_thread</span><br><span class=\"line\">|--&gt; srv_worker_thread</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* srv_purge_coordinator_thread::trx_purge */</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; trx_purge_attach_undo_recs <span class=\"comment\">// 收集指定数据的 undo pages</span></span><br><span class=\"line\">|    |--&gt; trx_purge_fetch_next_rec <span class=\"comment\">// loop</span></span><br><span class=\"line\">|    |    |--&gt; trx_purge_choose_next_log <span class=\"comment\">// 寻找下一个 log</span></span><br><span class=\"line\">|    |    |    |--&gt; purge_sys-&gt;rseg_iter-&gt;set_next() <span class=\"comment\">// 更新 purge_sys-&gt;rseg 位置</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_purge_read_undo_rec <span class=\"comment\">// 更新 purge_sys-&gt;iter 信息</span></span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_get_first_rec</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; trx_undo_build_roll_ptr</span><br><span class=\"line\">|    |    |--&gt; trx_purge_get_next_rec <span class=\"comment\">// 寻找下一个 record</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_undo_page_get_next_rec <span class=\"comment\">// 从当前 page 寻找下一个 record</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_undo_get_next_rec</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_page_get_next_rec</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_get_next_rec_from_next_page <span class=\"comment\">// 从下一个 page 寻找，TRX_UNDO_PAGE_NODE</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_purge_rseg_get_next_history_log <span class=\"comment\">// 查找 TRX_UNDO_HISTORY_NODE, 找到下一个 hdr</span></span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; que_fork_scheduler_round_robin</span><br><span class=\"line\">|--&gt; srv_que_task_enqueue_low</span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; trx_purge_truncate <span class=\"comment\">// 清理 undo 文件</span></span><br><span class=\"line\">|    |--&gt; trx_purge_truncate_history <span class=\"comment\">// 遍历 rsegs</span></span><br><span class=\"line\">|    |    |--&gt; trx_purge_truncate_rseg_history <span class=\"comment\">// 遍历 TRX_RSEG_HISTORY</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* srv_worker_thread::::row_purge_step */</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; row_purge</span><br><span class=\"line\">|    |--&gt; row_purge_parse_undo_rec</span><br><span class=\"line\">|    |--&gt; row_purge_record</span><br><span class=\"line\">|    |    |--&gt; row_purge_record_func</span><br><span class=\"line\">|    |    |    |--&gt; row_purge_del_mark</span><br><span class=\"line\">|    |    |    |--&gt; row_purge_upd_exist_or_extern</span><br></pre></td></tr></table></figure>\n\n<p>undo 的 purge 由后台线程完成，后台线程分为两类：coordinator 线程和 worker 线程。coordinator 线程负责收集和分发 undo log，worker 线程负责实际的 purge 工作（coordinator 线程本身也会参与 purge）。</p>\n<p>purge_sys 中维护了一个按照 trx_no 有序的小顶堆结构 purge_queue，在事务提交的过程中（commit阶段）会将事务对应的回滚段添加到 purge_queue 中。需要注意，并不是每次事务提交的时候都会将回滚段添加到 purge_queue 中，只有当 redo_rseg-&gt;last_page_no 为空时（即回滚段上之前不存在未 puge 的 undo），才会添加到 purge_queue 中。</p>\n<p>若 redo_rseg-&gt;last_page_no 非空，则说明该回滚段上存在未 purg 的 undo，此时只会更新回滚段的 TRX_RSEG_HISTORY 列表，将新的 undo 添加到 TRX_RSEG_HISTORY 列表的头部。</p>\n<p>coordinator 线程按照以下的逻辑收集 undo：</p>\n<ol>\n<li>从 purge_queue 里面弹出一个元素 TrxUndoRsegs，m_trx_undo_rsegs 指向弹出的元素；</li>\n<li>继续从 purge_queue 弹出元素，若弹出元素的 trx_no 和 m_trx_undo_rsegs 的 trx_no 相同，则直接进行合并，否则退出循环；</li>\n<li>m_iter 指向 m_trx_undo_rsegs，开始遍历，purg_sys-&gt;rseg 指向待处理的回滚段；</li>\n<li>从待处理的回滚段中依次取 undo_record，若无法取到下一个 undo_record，则需要根据TRX_UNDO_HISTORY 的 next 指针，取下一个 trx 的 undo，并将 trx_rseg_t 重新 放入 purge_queue 中；</li>\n<li>m_iter 正常遍历，当遍历到 m_trx_undo_rsegs 尾部时，重复 1；</li>\n</ol>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p><a href=\"http://mysql.taobao.org/monthly/2015/04/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2015/04/01/</a></p>\n<p><a href=\"http://mysql.taobao.org/monthly/2018/03/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2018/03/01/</a></p>\n<p><a href=\"http://mysql.taobao.org/monthly/2017/12/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2017/12/01/</a></p>\n</blockquote>\n<h2 id=\"附：undo格式\"><a href=\"#附：undo格式\" class=\"headerlink\" title=\"附：undo格式\"></a>附：undo格式</h2><img src=\"/images/innodb-undo-log-5.png\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>","site":{"data":{}},"excerpt":"<p>本文主要对 InnoDB 的 Undo Log 进行介绍。</p>","more":"<h2 id=\"逻辑结构\"><a href=\"#逻辑结构\" class=\"headerlink\" title=\"逻辑结构\"></a>逻辑结构</h2><img src=\"/images/innodb-undo-log-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<h2 id=\"物理结构\"><a href=\"#物理结构\" class=\"headerlink\" title=\"物理结构\"></a>物理结构</h2><h3 id=\"回滚段\"><a href=\"#回滚段\" class=\"headerlink\" title=\"回滚段\"></a>回滚段</h3><img src=\"/images/innodb-undo-log-2.png\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>InnoDB会为每一个读写事务分配回滚段，临时表有单独的回滚段。每一个回滚段内有两个重要的数据结构：</p>\n<ol>\n<li>Undo slots, 可以理解为undo page的槽位，1个回滚段内部有1024个槽位，每个槽位可以指向<code>FIL_NULL</code>或者指向一个真实的undo page地址；回滚段为每个读写事务分配槽位时，只能分配指向<code>FIL_NULL</code>的槽位；</li>\n<li>TRX_RSEG_HISTORY，维护了一个undo log链表，与undo log中的TRX_UNDO_HISTORY_NODE关联，添加时加到头部；</li>\n</ol>\n<h3 id=\"undo-page\"><a href=\"#undo-page\" class=\"headerlink\" title=\"undo page\"></a>undo page</h3><img src=\"/images/innodb-undo-log-3.png\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>按照上文的描述，InnoDB为每1个读写事务分配一个undo slot槽位，对应的槽位会指向一个undo page。undo page可以分为两个部分：undo page header 和 undo log。undo page header是一个公共的区域，一个undo page内部可能会包含多个undo log，还可能出现undo page的复用。对于undo page header，主要的信息包括：</p>\n<ol>\n<li>TRX_UNDO_PAGE_FREE：指向当前page的空闲位置</li>\n<li>TRX_UNDO_LAST_LOG：指向上一个undo log的开始位置</li>\n<li>TRX_UNDO_STATE：当前undo page状态</li>\n<li>TRX_UNDO_PAGE_LIST：维护一个undo page的链表，与TRX_UNDO_PAGE_NODE关联，添加时加到尾部</li>\n</ol>\n<h3 id=\"undo-log\"><a href=\"#undo-log\" class=\"headerlink\" title=\"undo log\"></a>undo log</h3><img src=\"/images/innodb-undo-log-4.png\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>undo内部包括两个部分：undo log header 和 undo  log record，其中undo log header主要信息包括：</p>\n<ol>\n<li>TRX_UNDO_LOG_START：当前undo log内容(不含header)的开始位置，undo-&gt;hdr_offset指向的是包含了header的开始位置，undo-&gt;top_offset指向的是log record(不含header)的开始位置</li>\n</ol>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>在介绍undo log的生命周期前，先回答下面几个问题。</p>\n<p>1）什么时候申请回滚段？</p>\n<p>A：这个问题前面已经提到，当事务升级为读写事务时，会自动的为事务分配回滚段。</p>\n<p>2）undo log的写入过程？</p>\n<p>A：读写事务分配好回滚段只是相当于做了一个占位，当有IDU操作发生时，才会开始记录undo。记录undo前，首先需要为事务绑定undo slot，寻找undo slot前，首先会去查看回滚段上是否有被cached的undo page，如果有的话，则可以直接拿来使用；如果没有则需要找到一个指向<code>FIL_NULL</code>的，然后生成一个新的undo page。</p>\n<p>不管是cached的undo page还是新生成的undo page，在写入真实的undo log record前，会提前生成undo log header。然后根据具体的操作，记录相应的record。最后生成roll_ptr，最终绑定到数据行记录上。</p>\n<p>3）undo log的回收过程？</p>\n<p>A：对于undo log的回收，插入操作和非插入操作的处理流程不同，对于插入操作，可以在事务提交之后，直接清理掉undo log(或者进入cached队列)；对于更新/删除操作，需要后台的purge线程进行删除，事务提交时仅将undo log加入到回滚段的history列表中(或者进入cached队列)，并且会插入一个元素到purge_sys内的最小堆中。purge线程会异步的进行删除。</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>undo的初始化在innodb启动的时候进行，基本的入口在 srv_start() ：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; srv_start</span><br><span class=\"line\">|    |    <span class=\"comment\">// Init</span></span><br><span class=\"line\">|    |--&gt; srv_undo_tablespaces_init  <span class=\"comment\">// create</span></span><br><span class=\"line\">|    |    |--&gt; srv_undo_tablespaces_create</span><br><span class=\"line\">|    |    |    |--&gt; srv_undo_tablespace_create</span><br><span class=\"line\">|    |    |    |--&gt; srv_undo_tablespace_open</span><br><span class=\"line\">|    |--&gt; trx_sys_create_sys_pages</span><br><span class=\"line\">|    |--&gt; trx_sys_init_at_db_start</span><br><span class=\"line\">|    |    |--&gt; trx_rsegs_init</span><br><span class=\"line\">|    |    |    |--&gt; trx_rseg_mem_create</span><br><span class=\"line\">|    |--&gt; trx_purge_sys_create</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |    <span class=\"comment\">// Start</span></span><br><span class=\"line\">|    |--&gt; recv_recovery_from_checkpoint_start</span><br><span class=\"line\">|    |--&gt; recv_recovery_from_checkpoint_finish</span><br><span class=\"line\">|    |--&gt; srv_undo_tablespaces_init  <span class=\"comment\">// open</span></span><br><span class=\"line\">|    |    |--&gt; srv_undo_tablespaces_open</span><br><span class=\"line\">|    |    |    |--&gt; srv_undo_tablespace_open_by_num</span><br><span class=\"line\">|    |    |    |    |--&gt; srv_undo_tablespace_open</span><br><span class=\"line\">|    |--&gt; trx_sys_init_at_db_start  </span><br><span class=\"line\">|    |--&gt; trx_purge_sys_create</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; trx_rseg_adjust_rollback_segments</span><br><span class=\"line\">|    |    |--&gt; trx_rseg_add_rollback_segments</span><br><span class=\"line\">|    |    |    |--&gt; trx_rseg_create</span><br><span class=\"line\">|    |    |    |--&gt; trx_rseg_mem_create</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据写入\"><a href=\"#数据写入\" class=\"headerlink\" title=\"数据写入\"></a>数据写入</h3><p>主要代码入口如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 申请回滚段</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">trx_assign_rseg_durable</span><span class=\"params\">(<span class=\"keyword\">trx_t</span> *trx)</span> </span>&#123;</span><br><span class=\"line\">  ut_ad(trx-&gt;rsegs.m_redo.rseg == <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  trx-&gt;rsegs.m_redo.rseg = srv_read_only_mode ? <span class=\"literal\">nullptr</span> : get_next_redo_rseg();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; trx_set_rw_mode</span><br><span class=\"line\">|    |--&gt; trx_assign_rseg_durable</span><br><span class=\"line\">|    |    |--&gt; get_next_redo_rseg</span><br><span class=\"line\">|    |    |    |--&gt; get_next_redo_rseg_from_trx_sys  <span class=\"comment\">// 系统表空间</span></span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; get_next_redo_rseg_from_undo_spaces  <span class=\"comment\">// 独立 undo 表空间</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; trx_sys_get_new_trx_id</span><br><span class=\"line\">|    |--&gt; trx_sys-&gt;rw_trx_ids.push_back</span><br><span class=\"line\">|    |--&gt; trx_sys-&gt;rw_trx_set.insert</span><br><span class=\"line\">|    |--&gt; UT_LIST_ADD_FIRST(trx_sys-&gt;rw_trx_list)</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 写入undo log</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">dberr_t</span> <span class=\"title\">trx_undo_report_row_operation</span><span class=\"params\">(...)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  err = trx_undo_assign_undo(trx, undo_ptr, TRX_UNDO_UPDATE);</span><br><span class=\"line\">  </span><br><span class=\"line\">  ...</span><br><span class=\"line\">  offset = trx_undo_page_report_modify(undo_page, trx, index, rec, offsets,</span><br><span class=\"line\">                                       update, cmpl_info, clust_entry, &amp;mtr);</span><br><span class=\"line\">  </span><br><span class=\"line\">  ...</span><br><span class=\"line\">  *roll_ptr = trx_undo_build_roll_ptr(op_type == TRX_UNDO_INSERT_OP,</span><br><span class=\"line\">                                      undo_ptr-&gt;rseg-&gt;space_id, page_no, offset);</span><br><span class=\"line\">  </span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成undo page</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">dberr_t</span> <span class=\"title\">trx_undo_assign_undo</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">trx_t</span> *trx,               <span class=\"comment\">/*!&lt; in: transaction */</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">trx_undo_ptr_t</span> *undo_ptr, <span class=\"comment\">/*!&lt; in: assign undo log from</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"comment\">                              referred rollback segment. */</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    ulint type)</span>               <span class=\"comment\">/*!&lt; in: TRX_UNDO_INSERT or</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">                              TRX_UNDO_UPDATE */</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  undo = trx_undo_reuse_cached(trx, rseg, type, trx-&gt;id, trx-&gt;xid, &amp;mtr);</span><br><span class=\"line\">    </span><br><span class=\"line\">  ...</span><br><span class=\"line\">  err = trx_undo_create(trx, rseg, type, trx-&gt;id, trx-&gt;xid, &amp;undo, &amp;mtr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"title\">MY_ATTRIBUTE</span><span class=\"params\">((warn_unused_result))</span> <span class=\"keyword\">dberr_t</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">trx_undo_create</span><span class=\"params\">(<span class=\"keyword\">trx_t</span> *trx, <span class=\"keyword\">trx_rseg_t</span> *rseg, ulint type, <span class=\"keyword\">trx_id_t</span> trx_id,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    <span class=\"keyword\">const</span> XID *xid, <span class=\"keyword\">trx_undo_t</span> **undo, <span class=\"keyword\">mtr_t</span> *mtr)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  rseg_header = trx_rsegf_get(rseg-&gt;space_id, rseg-&gt;page_no, rseg-&gt;page_size, mtr);</span><br><span class=\"line\"></span><br><span class=\"line\">  err = trx_undo_seg_create(rseg, rseg_header, type, &amp;id, &amp;undo_page, mtr);</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  page_no = page_get_page_no(undo_page);</span><br><span class=\"line\"></span><br><span class=\"line\">  offset = trx_undo_header_create(undo_page, trx_id, mtr);</span><br><span class=\"line\"></span><br><span class=\"line\">  trx_undo_header_add_space_for_xid(undo_page, undo_page + offset, mtr);</span><br><span class=\"line\"></span><br><span class=\"line\">  *undo = trx_undo_mem_create(rseg, id, type, trx_id, xid, page_no, offset);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从 MySQL 5.6 开始，MySQL 引入了独立的 undo 表空间，可以通过参数 <code>innodb_undo_tablespaces</code> 参数配置独立的 undo 表空间的个数，undo 可以不再通过 ibdata 进行管理（这也极大的减小了 ibdata 的大小）。从 MySQL 5.7 开始支持 truncate undo 表空间，进一步解决了 undo 空间膨胀后无法回收的问题。</p>\n<p>在开启独立 undo 表空间的情况下，每个表空间内部包含了 128 个回滚段，读写事务在申请 undo 回滚段时，总是在不同的表空间交替进行分配。</p>\n<p>当写操作（插入+更新）操作需要记录 undo 时，会通过已经分配的回滚段找到一个可用的 undo 。在前面的类图中可以看到，每个回滚段上对于不同类型的 undo 保存了两个列表：正在使用的列表和 cached 列表。在分配 undo page 时，会优先从 cached 列表中寻找，如果找不到的话再去分配一个新的 undo 。</p>\n<p>前面也提到了，每个回滚段上都有一个 undo slots 数组，数组的长度为 1024，每个 slot 中保存的是一个 undo page 的地址，默认为空（FIL_NULL）。在分配一个新的 undo 时，首先需要找到一个为空的 slot，然后再去创建新的 page，并且将 slot 指向这个 page。结合代码分析一下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; trx_undo_seg_create</span><br><span class=\"line\">|    |--&gt; trx_rsegf_undo_find_free  <span class=\"comment\">// 寻找一个 free 的 slot</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; fsp_reserve_free_extents</span><br><span class=\"line\">|    |--&gt; fseg_create_general  <span class=\"comment\">// 创建一个新的 undo page</span></span><br><span class=\"line\">|    |--&gt; fil_space_release_free_extents</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; trx_undo_page_init  <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">|    |--&gt; flst_init  <span class=\"comment\">// 维护 TRX_UNDO_PAGE_LIST 列表</span></span><br><span class=\"line\">|    |--&gt; flst_add_last</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; trx_rsegf_set_nth_undo  <span class=\"comment\">// 修改 slot 指针</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"事务提交\"><a href=\"#事务提交\" class=\"headerlink\" title=\"事务提交\"></a>事务提交</h3><p>事务提交过程中的undo处理过程可以简化为以下逻辑：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; ha_commit_trans</span><br><span class=\"line\">|    |--&gt; trx_prepare_for_mysql</span><br><span class=\"line\">|    |    |--&gt; trx_undo_set_state_at_prepare</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; trx_commit_for_mysql</span><br><span class=\"line\">|    |    |--&gt; trx_write_serialisation_history</span><br><span class=\"line\">|    |    |    |--&gt; trx_serialisation_number_get</span><br><span class=\"line\">|    |    |    |--&gt; trx_undo_set_state_at_finish</span><br><span class=\"line\">|    |    |    |--&gt; trx_undo_update_clean</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; trx_commit_in_memory</span><br><span class=\"line\">|    |    |    |--&gt; trx_undo_insert_clean</span><br></pre></td></tr></table></figure>\n\n<p>其中，在trx_serialisation_number_get步骤中，会生成TrxUndoRsegs对象，插入到purge_sys-&gt;purge_queue中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((redo_rseg != <span class=\"literal\">NULL</span> &amp;&amp; redo_rseg-&gt;last_page_no == FIL_NULL) ||</span><br><span class=\"line\">    (temp_rseg != <span class=\"literal\">NULL</span> &amp;&amp; temp_rseg-&gt;last_page_no == FIL_NULL)) &#123;</span><br><span class=\"line\">  <span class=\"function\">TrxUndoRsegs <span class=\"title\">elem</span><span class=\"params\">(trx-&gt;no)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (redo_rseg != <span class=\"literal\">NULL</span> &amp;&amp; redo_rseg-&gt;last_page_no == FIL_NULL) &#123;</span><br><span class=\"line\">    elem.push_back(redo_rseg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (temp_rseg != <span class=\"literal\">NULL</span> &amp;&amp; temp_rseg-&gt;last_page_no == FIL_NULL) &#123;</span><br><span class=\"line\">    elem.push_back(temp_rseg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  mutex_enter(&amp;purge_sys-&gt;pq_mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">  trx_sys_mutex_exit();</span><br><span class=\"line\"></span><br><span class=\"line\">  purge_sys-&gt;purge_queue-&gt;push(elem);</span><br><span class=\"line\"></span><br><span class=\"line\">  mutex_exit(&amp;purge_sys-&gt;pq_mutex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 trx_undo_set_state_at_finish 步骤时，会判断当前 undo 的状态：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">page_t</span> *<span class=\"title\">trx_undo_set_state_at_finish</span><span class=\"params\">(...)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  undo_page = trx_undo_page_get(<span class=\"keyword\">page_id_t</span>(undo-&gt;space, undo-&gt;hdr_page_no),</span><br><span class=\"line\">                                undo-&gt;page_size, mtr);</span><br><span class=\"line\"></span><br><span class=\"line\">  seg_hdr = undo_page + TRX_UNDO_SEG_HDR;</span><br><span class=\"line\">  page_hdr = undo_page + TRX_UNDO_PAGE_HDR;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (undo-&gt;<span class=\"built_in\">size</span> == <span class=\"number\">1</span> &amp;&amp; mach_read_from_2(page_hdr + TRX_UNDO_PAGE_FREE) &lt;</span><br><span class=\"line\">                             TRX_UNDO_PAGE_REUSE_LIMIT) &#123;</span><br><span class=\"line\">    state = TRX_UNDO_CACHED;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (undo-&gt;type == TRX_UNDO_INSERT) &#123;</span><br><span class=\"line\">    state = TRX_UNDO_TO_FREE;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    state = TRX_UNDO_TO_PURGE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  undo-&gt;state = state;</span><br><span class=\"line\"></span><br><span class=\"line\">  mlog_write_ulint(seg_hdr + TRX_UNDO_STATE, state, MLOG_2BYTES, mtr);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (undo_page);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在trx_undo_update_clean步骤时，会将undo log加入到对应回滚段上的history列表：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">trx_undo_update_cleanup</span><span class=\"params\">(...)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  trx_purge_add_update_undo_to_history(</span><br><span class=\"line\">      trx, undo_ptr, undo_page, update_rseg_history_len, n_added_logs, mtr);</span><br><span class=\"line\">  </span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (undo-&gt;state == TRX_UNDO_CACHED) &#123;</span><br><span class=\"line\">    UT_LIST_ADD_FIRST(rseg-&gt;update_undo_cached, undo);</span><br><span class=\"line\"></span><br><span class=\"line\">    MONITOR_INC(MONITOR_NUM_UNDO_SLOT_CACHED);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ut_ad(undo-&gt;state == TRX_UNDO_TO_PURGE);</span><br><span class=\"line\"></span><br><span class=\"line\">    trx_undo_mem_free(undo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">trx_purge_add_update_undo_to_history</span><span class=\"params\">(...)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (undo-&gt;state != TRX_UNDO_CACHED) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    trx_rsegf_set_nth_undo(rseg_header, undo-&gt;id, FIL_NULL, mtr);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/* Add the log as the first in the history list */</span></span><br><span class=\"line\">  flst_add_first(rseg_header + TRX_RSEG_HISTORY,</span><br><span class=\"line\">                 undo_header + TRX_UNDO_HISTORY_NODE, mtr);</span><br><span class=\"line\">  </span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (rseg-&gt;last_page_no == FIL_NULL) &#123;</span><br><span class=\"line\">    rseg-&gt;last_page_no = undo-&gt;hdr_page_no;</span><br><span class=\"line\">    rseg-&gt;last_offset = undo-&gt;hdr_offset;</span><br><span class=\"line\">    rseg-&gt;last_trx_no = trx-&gt;no;</span><br><span class=\"line\">    rseg-&gt;last_del_marks = undo-&gt;del_marks;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"后台purge\"><a href=\"#后台purge\" class=\"headerlink\" title=\"后台purge\"></a>后台purge</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* srv_start_purge_threads */</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; srv_purge_coordinator_thread</span><br><span class=\"line\">|--&gt; srv_worker_thread</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* srv_purge_coordinator_thread::trx_purge */</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; trx_purge_attach_undo_recs <span class=\"comment\">// 收集指定数据的 undo pages</span></span><br><span class=\"line\">|    |--&gt; trx_purge_fetch_next_rec <span class=\"comment\">// loop</span></span><br><span class=\"line\">|    |    |--&gt; trx_purge_choose_next_log <span class=\"comment\">// 寻找下一个 log</span></span><br><span class=\"line\">|    |    |    |--&gt; purge_sys-&gt;rseg_iter-&gt;set_next() <span class=\"comment\">// 更新 purge_sys-&gt;rseg 位置</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_purge_read_undo_rec <span class=\"comment\">// 更新 purge_sys-&gt;iter 信息</span></span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_get_first_rec</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; trx_undo_build_roll_ptr</span><br><span class=\"line\">|    |    |--&gt; trx_purge_get_next_rec <span class=\"comment\">// 寻找下一个 record</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_undo_page_get_next_rec <span class=\"comment\">// 从当前 page 寻找下一个 record</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_undo_get_next_rec</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_page_get_next_rec</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_get_next_rec_from_next_page <span class=\"comment\">// 从下一个 page 寻找，TRX_UNDO_PAGE_NODE</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_purge_rseg_get_next_history_log <span class=\"comment\">// 查找 TRX_UNDO_HISTORY_NODE, 找到下一个 hdr</span></span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; que_fork_scheduler_round_robin</span><br><span class=\"line\">|--&gt; srv_que_task_enqueue_low</span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; trx_purge_truncate <span class=\"comment\">// 清理 undo 文件</span></span><br><span class=\"line\">|    |--&gt; trx_purge_truncate_history <span class=\"comment\">// 遍历 rsegs</span></span><br><span class=\"line\">|    |    |--&gt; trx_purge_truncate_rseg_history <span class=\"comment\">// 遍历 TRX_RSEG_HISTORY</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* srv_worker_thread::::row_purge_step */</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; row_purge</span><br><span class=\"line\">|    |--&gt; row_purge_parse_undo_rec</span><br><span class=\"line\">|    |--&gt; row_purge_record</span><br><span class=\"line\">|    |    |--&gt; row_purge_record_func</span><br><span class=\"line\">|    |    |    |--&gt; row_purge_del_mark</span><br><span class=\"line\">|    |    |    |--&gt; row_purge_upd_exist_or_extern</span><br></pre></td></tr></table></figure>\n\n<p>undo 的 purge 由后台线程完成，后台线程分为两类：coordinator 线程和 worker 线程。coordinator 线程负责收集和分发 undo log，worker 线程负责实际的 purge 工作（coordinator 线程本身也会参与 purge）。</p>\n<p>purge_sys 中维护了一个按照 trx_no 有序的小顶堆结构 purge_queue，在事务提交的过程中（commit阶段）会将事务对应的回滚段添加到 purge_queue 中。需要注意，并不是每次事务提交的时候都会将回滚段添加到 purge_queue 中，只有当 redo_rseg-&gt;last_page_no 为空时（即回滚段上之前不存在未 puge 的 undo），才会添加到 purge_queue 中。</p>\n<p>若 redo_rseg-&gt;last_page_no 非空，则说明该回滚段上存在未 purg 的 undo，此时只会更新回滚段的 TRX_RSEG_HISTORY 列表，将新的 undo 添加到 TRX_RSEG_HISTORY 列表的头部。</p>\n<p>coordinator 线程按照以下的逻辑收集 undo：</p>\n<ol>\n<li>从 purge_queue 里面弹出一个元素 TrxUndoRsegs，m_trx_undo_rsegs 指向弹出的元素；</li>\n<li>继续从 purge_queue 弹出元素，若弹出元素的 trx_no 和 m_trx_undo_rsegs 的 trx_no 相同，则直接进行合并，否则退出循环；</li>\n<li>m_iter 指向 m_trx_undo_rsegs，开始遍历，purg_sys-&gt;rseg 指向待处理的回滚段；</li>\n<li>从待处理的回滚段中依次取 undo_record，若无法取到下一个 undo_record，则需要根据TRX_UNDO_HISTORY 的 next 指针，取下一个 trx 的 undo，并将 trx_rseg_t 重新 放入 purge_queue 中；</li>\n<li>m_iter 正常遍历，当遍历到 m_trx_undo_rsegs 尾部时，重复 1；</li>\n</ol>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p><a href=\"http://mysql.taobao.org/monthly/2015/04/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2015/04/01/</a></p>\n<p><a href=\"http://mysql.taobao.org/monthly/2018/03/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2018/03/01/</a></p>\n<p><a href=\"http://mysql.taobao.org/monthly/2017/12/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2017/12/01/</a></p>\n</blockquote>\n<h2 id=\"附：undo格式\"><a href=\"#附：undo格式\" class=\"headerlink\" title=\"附：undo格式\"></a>附：undo格式</h2><img src=\"/images/innodb-undo-log-5.png\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>"},{"title":"InnoDB 中 SQL 执行过程","date":"2020-12-05T13:06:52.000Z","_content":"\n前面 MySQL 中的 SQL 执行过程中，已经简单介绍了 1 条 SQL 在 MySQL Server 层的执行路径，本文继续介绍 1 条 SQL 在 InnoDB 层的执行路径。\n\n<!-- more -->\n\n## 读操作\n\n对于读操作，InnnoDB 的主要处理逻辑在 row_search_for_mysql (row_search_mvcc) 方法中，基本的步骤整理如下（基于 5.6 版本）：\n\n```c++\n|--> row_search_mvcc\n|    // 1. check prefetch cache\n|    |--> row_sel_dequeue_cached_row_for_mysql\n|    \n|    // 2. check AHI\n|    |--> row_sel_try_search_shortcut_for_mysql\n|    |    |--> btr_pcur_open_with_no_init\n|    |    |    |--> btr_cur_search_to_nth_level\n|    |    |    |    |--> btr_search_guess_on_hash\n|    |    |    |    |--> ...\n|    \n|    // 3. open/restore index\n|    |--> sel_restore_position_for_mysql\n|    |    |--> btr_pcur_restore_position\n|    |\n|    |--> btr_pcur_open_with_no_init\n|    |    |--> btr_cur_search_to_nth_level\n|    |    |    |--> btr_search_guess_on_hash\n|    |    |    |--> buf_page_get_gen\n|    |    |    |--> page_cur_search_with_match\n|    |    |    |    |--> page_dir_get_nth_slot\n|    |    |    |    |--> page_dir_slot_get_rec\n|    |    |    |    |--> cmp_dtuple_rec_with_match\n|    |\n|    |--> btr_pcur_open_at_index_side\n|    |    |--> btr_cur_open_at_index_side\n|    |    |    |--> buf_page_get_gen\n|    \n|    // 4. match record (mvcc check)\n|    |--> lock_clust_rec_cons_read_sees\n|    |    |--> view->changes_visible\n|    |--> row_sel_build_prev_vers_for_mysql\n|    |    |--> row_vers_build_for_consistent_read // loop\n|    |    |    |--> trx_undo_prev_version_build\n|    |    |    |    |--> trx_undo_get_undo_rec\n|    |    |    |    |--> trx_undo_update_rec_get_update\n|    |    |    |    |--> row_upd_rec_in_place\n|    |    |    |--> /* modifications_visible */\n|    |\n|    |--> lock_sec_rec_cons_read_sees\n|    |--> row_sel_get_clust_rec_for_mysql\n|    |    |--> lock_clust_rec_cons_read_sees\n|    |    |--> row_sel_build_prev_vers_for_mysql\n|    |\n|    |--> row_sel_store_mysql_rec\n|    \n|    // 5. move cousor to next index record\n```\n\n其中：\n\n1. btr_search_guess_on_hash 方法会从 AHI 中进行查询\n\n2. buf_page_get_gen 方法会从指定的 (space, offset) 获取1个page，并放入 BP 中，基本步骤如下：\n\n```c++\n/* buf_page_get_gen */\n\n|--> buf_page_hash_get_low // 1. 查看 page 是否在 page_hash 中\n|\n|--> buf_page_read // 2. 从文件中读取 page\n|    |--> buf_page_read_low\n|    |    |--> buf_page_init_for_read\n|    |    |    |--> buf_LRU_get_free_block // 获取1个新的block\n|    |    |    |--> buf_page_hash_get_low // 再次检查 page_hash 中是否存在\n|    |    |    |--> fil_tablespace_deleted_or_being_deleted_in_mem // 检查tablespace是否删除\n|    |    |    |--> buf_page_init\n|    |    |    |    |--> buf_block_init_low\n|    |    |    |    |--> buf_page_init_low\n|    |    |    |    |--> HASH_INSERT\n|    |    |    |--> buf_page_set_io_fix\n|    |    |    |--> buf_LRU_add_block\n|    |    |\n|    |    |--> _fil_io\n|    |    |\n|    |    |--> buf_page_io_complete\n|    |    |    |--> ibuf_merge_or_delete_for_page\n|\n|--> buf_block_fix\n|\n|--> buf_page_make_young_if_needed\n|\n|--> mtr_memo_push / mtr_add_page\n|\n|--> buf_read_ahead_linear\n```\n\n以上只是 InnoDB 读操作的一个基本流程，具体内容待后续继续分析。\n\n## 写操作\n\n基于 8.0 版本\n\n### 更新操作\n\n```c++\n|--> row_update_for_mysql\n|    |--> row_update_for_mysql_using_upd_graph\n|    |    |--> row_upd_step\n|    |    |    |--> row_upd\n|    |    |    |    |--> row_upd_clust_step // 更新主键\n|    |    |    |    |    |--> btr_pcur_restore_position // 恢复cursor，找到待更新的页，记录到mtr\n|    |    |    |    |    |    |--> btr_cur_optimistic_latch_leaves\n|    |    |    |    |    |    |--> dict_index_build_data_tuple\n|    |    |    |    |    |    |--> open_no_init\n|    |    |    |    |    |    |    |--> btr_cur_search_to_nth_level\n|    |    |    |    |    |\n|    |    |    |    |    |--> row_upd_del_mark_clust_rec // 标记删除\n|    |    |    |    |    |    |--> btr_cur_del_mark_set_clust_rec\n|    |    |    |    |    |    |    |--> trx_undo_report_row_operation\n|    |    |    |    |    |    |    |--> btr_rec_set_deleted_flag // 修改记录\n|    |    |    |    |    |    |    |--> row_upd_rec_sys_fields\n|    |    |    |    |    |  \n|    |    |    |    |    |--> row_upd_clust_rec // 原地更新\n|    |    |    |    |    |    |--> btr_cur_update_in_place\n|    |    |    |    |    |    |    |--> btr_cur_upd_lock_and_undo\n|    |    |    |    |    |    |    |    |--> trx_undo_report_row_operation\n|    |    |    |    |    |    |    |\n|    |    |    |    |    |    |    |--> row_upd_rec_sys_fields\n|    |    |    |    |    |    |    |--> row_upd_rec_in_place // 修改记录\n|    |    |    |    |    |    |    |--> btr_cur_update_in_place_log\n|    |    |    |    |    |    |    |    |--> row_upd_write_sys_vals_to_log\n|    |    |    |    |    |    |\n|    |    |    |    |    |    |--> btr_cur_optimistic_update\n|    |    |    |    |    |    |    |--> btr_cur_update_in_place\n|    |    |    |    |    |    |    |\n|    |    |    |    |    |    |    |--> page_cur_delete_rec\n|    |    |    |    |    |    |    |--> row_upd_index_entry_sys_field\n|    |    |    |    |    |    |    |--> btr_cur_insert_if_possible\n|    |    |    |    |    |    |\n|    |    |    |    |    |    |--> btr_cur_pessimistic_update\n|    |    |    |    |    |\n|    |    |    |    |    |--> row_upd_clust_rec_by_insert // 删除 + 插入\n|    |    |    |    |    |    |--> btr_cur_del_mark_set_clust_rec\n|    |    |    |    |    |    |    |--> trx_undo_report_row_operation\n|    |    |    |    |    |    |--> row_ins_clust_index_entry\n|    |    |    |    |    |    |    |--> row_ins_clust_index_entry_low\n|    |    |    |    |    |    |    |    |--> btr_cur_optimistic_insert\n|    |    |    |    |    |    |    |    |    |--> btr_cur_ins_lock_and_undo\n|    |    |    |    |    |    |    |    |    |    |--> trx_undo_report_row_operation\n|    |    |    |    |\n|    |    |    |    |--> row_upd_sec_step // 更新二级索引\n|    |    |    |    |    |--> row_upd_del_multi_sec_index_entry\n|    |    |    |    |    |--> row_upd_multi_sec_index_entry\n|    |    |    |    |    |--> row_upd_sec_index_entry\n|    |    |    |    |    |    |-->row_upd_sec_index_entry_low // 删除 + 插入\n|    |    |    |    |    |    |    |--> row_build_index_entry\n|    |    |    |    |    |    |    |--> row_search_index_entry\n|    |    |    |    |    |    |    |--> btr_cur_del_mark_set_sec_rec\n|    |    |    |    |    |    |    |--> row_build_index_entry\n|    |    |    |    |    |    |    |--> row_ins_sec_index_entry\n```\n\n### 插入操作\n\n```c++\n|--> row_insert_for_mysql\n|    |--> row_insert_for_mysql_using_ins_graph\n|    |    |--> row_get_prebuilt_insert_row\n|    |    |    |--> ins_node_set_new_row\n|    |    |    |    |--> row_ins_alloc_sys_fields\n|    |    |\n|    |    |--> row_mysql_convert_row_to_innobase\n|    |    |\n|    |    |--> row_ins_step\n|    |    |    |--> row_ins\n|    |    |    |    |--> row_ins_index_entry_step\n|    |    |    |    |    |--> row_ins_index_entry\n|    |    |    |    |    |    |--> row_ins_clust_index_entry // 插入主键\n|    |    |    |    |    |    |    |--> row_ins_clust_index_entry_low\n|    |    |    |    |    |    |    |    |--> row_ins_clust_index_entry_by_modify // 可以复用\n|    |    |    |    |    |    |    |    |--> btr_cur_optimistic_insert // 乐观插入\n|    |    |    |    |    |    |    |    |    |--> btr_cur_ins_lock_and_undo\n|    |    |    |    |    |    |    |    |    |    |--> trx_undo_report_row_operation\n|    |    |    |    |    |    |    |    |    |    |--> row_upd_index_entry_sys_field\n|    |    |    |    |    |    |    |    |    |--> page_cur_tuple_insert // 插入记录\n|    |    |    |    |    |    |    |    |    |    |--> page_cur_insert_rec_low\n|    |    |    |    |    |    |    |    |--> btr_cur_pessimistic_insert // 悲观插入\n|    |    |    |    |    |    |\n|    |    |    |    |    |    |--> row_ins_sec_index_multi_value_entry\n|    |    |    |    |    |    |\n|    |    |    |    |    |    |--> row_ins_sec_index_entry // 插入二级索引\n|    |    |    |    |    |    |    |--> row_ins_sec_index_entry_low\n|    |    |    |    |    |    |    |    |--> btr_cur_search_to_nth_level // 查找插入的位置\n|    |    |    |    |    |    |    |    |--> btr_cur_optimistic_insert\n```\n\n其中：\n\ntrx_undo_report_row_operation 会进行 undo 的记录和数据的修改，基本步骤如下：\n\n```c++\n/* trx_undo_report_row_operation */\n\n|--> trx_undo_assign_undo // 1. 分配 undo 空间\n\n|--> buf_page_get_gen  // 2. 获取 undo page\n\n|--> trx_undo_page_report_insert\n|--> trx_undo_page_report_modify\n```\n\n","source":"_posts/innodb/innodb-sql-execute.md","raw":"---\ntitle: InnoDB 中 SQL 执行过程\ndate: 2020-12-05 21:06:52\ncategories: \n- InnoDB\n\n---\n\n前面 MySQL 中的 SQL 执行过程中，已经简单介绍了 1 条 SQL 在 MySQL Server 层的执行路径，本文继续介绍 1 条 SQL 在 InnoDB 层的执行路径。\n\n<!-- more -->\n\n## 读操作\n\n对于读操作，InnnoDB 的主要处理逻辑在 row_search_for_mysql (row_search_mvcc) 方法中，基本的步骤整理如下（基于 5.6 版本）：\n\n```c++\n|--> row_search_mvcc\n|    // 1. check prefetch cache\n|    |--> row_sel_dequeue_cached_row_for_mysql\n|    \n|    // 2. check AHI\n|    |--> row_sel_try_search_shortcut_for_mysql\n|    |    |--> btr_pcur_open_with_no_init\n|    |    |    |--> btr_cur_search_to_nth_level\n|    |    |    |    |--> btr_search_guess_on_hash\n|    |    |    |    |--> ...\n|    \n|    // 3. open/restore index\n|    |--> sel_restore_position_for_mysql\n|    |    |--> btr_pcur_restore_position\n|    |\n|    |--> btr_pcur_open_with_no_init\n|    |    |--> btr_cur_search_to_nth_level\n|    |    |    |--> btr_search_guess_on_hash\n|    |    |    |--> buf_page_get_gen\n|    |    |    |--> page_cur_search_with_match\n|    |    |    |    |--> page_dir_get_nth_slot\n|    |    |    |    |--> page_dir_slot_get_rec\n|    |    |    |    |--> cmp_dtuple_rec_with_match\n|    |\n|    |--> btr_pcur_open_at_index_side\n|    |    |--> btr_cur_open_at_index_side\n|    |    |    |--> buf_page_get_gen\n|    \n|    // 4. match record (mvcc check)\n|    |--> lock_clust_rec_cons_read_sees\n|    |    |--> view->changes_visible\n|    |--> row_sel_build_prev_vers_for_mysql\n|    |    |--> row_vers_build_for_consistent_read // loop\n|    |    |    |--> trx_undo_prev_version_build\n|    |    |    |    |--> trx_undo_get_undo_rec\n|    |    |    |    |--> trx_undo_update_rec_get_update\n|    |    |    |    |--> row_upd_rec_in_place\n|    |    |    |--> /* modifications_visible */\n|    |\n|    |--> lock_sec_rec_cons_read_sees\n|    |--> row_sel_get_clust_rec_for_mysql\n|    |    |--> lock_clust_rec_cons_read_sees\n|    |    |--> row_sel_build_prev_vers_for_mysql\n|    |\n|    |--> row_sel_store_mysql_rec\n|    \n|    // 5. move cousor to next index record\n```\n\n其中：\n\n1. btr_search_guess_on_hash 方法会从 AHI 中进行查询\n\n2. buf_page_get_gen 方法会从指定的 (space, offset) 获取1个page，并放入 BP 中，基本步骤如下：\n\n```c++\n/* buf_page_get_gen */\n\n|--> buf_page_hash_get_low // 1. 查看 page 是否在 page_hash 中\n|\n|--> buf_page_read // 2. 从文件中读取 page\n|    |--> buf_page_read_low\n|    |    |--> buf_page_init_for_read\n|    |    |    |--> buf_LRU_get_free_block // 获取1个新的block\n|    |    |    |--> buf_page_hash_get_low // 再次检查 page_hash 中是否存在\n|    |    |    |--> fil_tablespace_deleted_or_being_deleted_in_mem // 检查tablespace是否删除\n|    |    |    |--> buf_page_init\n|    |    |    |    |--> buf_block_init_low\n|    |    |    |    |--> buf_page_init_low\n|    |    |    |    |--> HASH_INSERT\n|    |    |    |--> buf_page_set_io_fix\n|    |    |    |--> buf_LRU_add_block\n|    |    |\n|    |    |--> _fil_io\n|    |    |\n|    |    |--> buf_page_io_complete\n|    |    |    |--> ibuf_merge_or_delete_for_page\n|\n|--> buf_block_fix\n|\n|--> buf_page_make_young_if_needed\n|\n|--> mtr_memo_push / mtr_add_page\n|\n|--> buf_read_ahead_linear\n```\n\n以上只是 InnoDB 读操作的一个基本流程，具体内容待后续继续分析。\n\n## 写操作\n\n基于 8.0 版本\n\n### 更新操作\n\n```c++\n|--> row_update_for_mysql\n|    |--> row_update_for_mysql_using_upd_graph\n|    |    |--> row_upd_step\n|    |    |    |--> row_upd\n|    |    |    |    |--> row_upd_clust_step // 更新主键\n|    |    |    |    |    |--> btr_pcur_restore_position // 恢复cursor，找到待更新的页，记录到mtr\n|    |    |    |    |    |    |--> btr_cur_optimistic_latch_leaves\n|    |    |    |    |    |    |--> dict_index_build_data_tuple\n|    |    |    |    |    |    |--> open_no_init\n|    |    |    |    |    |    |    |--> btr_cur_search_to_nth_level\n|    |    |    |    |    |\n|    |    |    |    |    |--> row_upd_del_mark_clust_rec // 标记删除\n|    |    |    |    |    |    |--> btr_cur_del_mark_set_clust_rec\n|    |    |    |    |    |    |    |--> trx_undo_report_row_operation\n|    |    |    |    |    |    |    |--> btr_rec_set_deleted_flag // 修改记录\n|    |    |    |    |    |    |    |--> row_upd_rec_sys_fields\n|    |    |    |    |    |  \n|    |    |    |    |    |--> row_upd_clust_rec // 原地更新\n|    |    |    |    |    |    |--> btr_cur_update_in_place\n|    |    |    |    |    |    |    |--> btr_cur_upd_lock_and_undo\n|    |    |    |    |    |    |    |    |--> trx_undo_report_row_operation\n|    |    |    |    |    |    |    |\n|    |    |    |    |    |    |    |--> row_upd_rec_sys_fields\n|    |    |    |    |    |    |    |--> row_upd_rec_in_place // 修改记录\n|    |    |    |    |    |    |    |--> btr_cur_update_in_place_log\n|    |    |    |    |    |    |    |    |--> row_upd_write_sys_vals_to_log\n|    |    |    |    |    |    |\n|    |    |    |    |    |    |--> btr_cur_optimistic_update\n|    |    |    |    |    |    |    |--> btr_cur_update_in_place\n|    |    |    |    |    |    |    |\n|    |    |    |    |    |    |    |--> page_cur_delete_rec\n|    |    |    |    |    |    |    |--> row_upd_index_entry_sys_field\n|    |    |    |    |    |    |    |--> btr_cur_insert_if_possible\n|    |    |    |    |    |    |\n|    |    |    |    |    |    |--> btr_cur_pessimistic_update\n|    |    |    |    |    |\n|    |    |    |    |    |--> row_upd_clust_rec_by_insert // 删除 + 插入\n|    |    |    |    |    |    |--> btr_cur_del_mark_set_clust_rec\n|    |    |    |    |    |    |    |--> trx_undo_report_row_operation\n|    |    |    |    |    |    |--> row_ins_clust_index_entry\n|    |    |    |    |    |    |    |--> row_ins_clust_index_entry_low\n|    |    |    |    |    |    |    |    |--> btr_cur_optimistic_insert\n|    |    |    |    |    |    |    |    |    |--> btr_cur_ins_lock_and_undo\n|    |    |    |    |    |    |    |    |    |    |--> trx_undo_report_row_operation\n|    |    |    |    |\n|    |    |    |    |--> row_upd_sec_step // 更新二级索引\n|    |    |    |    |    |--> row_upd_del_multi_sec_index_entry\n|    |    |    |    |    |--> row_upd_multi_sec_index_entry\n|    |    |    |    |    |--> row_upd_sec_index_entry\n|    |    |    |    |    |    |-->row_upd_sec_index_entry_low // 删除 + 插入\n|    |    |    |    |    |    |    |--> row_build_index_entry\n|    |    |    |    |    |    |    |--> row_search_index_entry\n|    |    |    |    |    |    |    |--> btr_cur_del_mark_set_sec_rec\n|    |    |    |    |    |    |    |--> row_build_index_entry\n|    |    |    |    |    |    |    |--> row_ins_sec_index_entry\n```\n\n### 插入操作\n\n```c++\n|--> row_insert_for_mysql\n|    |--> row_insert_for_mysql_using_ins_graph\n|    |    |--> row_get_prebuilt_insert_row\n|    |    |    |--> ins_node_set_new_row\n|    |    |    |    |--> row_ins_alloc_sys_fields\n|    |    |\n|    |    |--> row_mysql_convert_row_to_innobase\n|    |    |\n|    |    |--> row_ins_step\n|    |    |    |--> row_ins\n|    |    |    |    |--> row_ins_index_entry_step\n|    |    |    |    |    |--> row_ins_index_entry\n|    |    |    |    |    |    |--> row_ins_clust_index_entry // 插入主键\n|    |    |    |    |    |    |    |--> row_ins_clust_index_entry_low\n|    |    |    |    |    |    |    |    |--> row_ins_clust_index_entry_by_modify // 可以复用\n|    |    |    |    |    |    |    |    |--> btr_cur_optimistic_insert // 乐观插入\n|    |    |    |    |    |    |    |    |    |--> btr_cur_ins_lock_and_undo\n|    |    |    |    |    |    |    |    |    |    |--> trx_undo_report_row_operation\n|    |    |    |    |    |    |    |    |    |    |--> row_upd_index_entry_sys_field\n|    |    |    |    |    |    |    |    |    |--> page_cur_tuple_insert // 插入记录\n|    |    |    |    |    |    |    |    |    |    |--> page_cur_insert_rec_low\n|    |    |    |    |    |    |    |    |--> btr_cur_pessimistic_insert // 悲观插入\n|    |    |    |    |    |    |\n|    |    |    |    |    |    |--> row_ins_sec_index_multi_value_entry\n|    |    |    |    |    |    |\n|    |    |    |    |    |    |--> row_ins_sec_index_entry // 插入二级索引\n|    |    |    |    |    |    |    |--> row_ins_sec_index_entry_low\n|    |    |    |    |    |    |    |    |--> btr_cur_search_to_nth_level // 查找插入的位置\n|    |    |    |    |    |    |    |    |--> btr_cur_optimistic_insert\n```\n\n其中：\n\ntrx_undo_report_row_operation 会进行 undo 的记录和数据的修改，基本步骤如下：\n\n```c++\n/* trx_undo_report_row_operation */\n\n|--> trx_undo_assign_undo // 1. 分配 undo 空间\n\n|--> buf_page_get_gen  // 2. 获取 undo page\n\n|--> trx_undo_page_report_insert\n|--> trx_undo_page_report_modify\n```\n\n","slug":"innodb/innodb-sql-execute","published":1,"updated":"2020-12-05T13:17:35.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4xa000fgugmgztv87j5","content":"<p>前面 MySQL 中的 SQL 执行过程中，已经简单介绍了 1 条 SQL 在 MySQL Server 层的执行路径，本文继续介绍 1 条 SQL 在 InnoDB 层的执行路径。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"读操作\"><a href=\"#读操作\" class=\"headerlink\" title=\"读操作\"></a>读操作</h2><p>对于读操作，InnnoDB 的主要处理逻辑在 row_search_for_mysql (row_search_mvcc) 方法中，基本的步骤整理如下（基于 5.6 版本）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; row_search_mvcc</span><br><span class=\"line\">|    <span class=\"comment\">// 1. check prefetch cache</span></span><br><span class=\"line\">|    |--&gt; row_sel_dequeue_cached_row_for_mysql</span><br><span class=\"line\">|    </span><br><span class=\"line\">|    <span class=\"comment\">// 2. check AHI</span></span><br><span class=\"line\">|    |--&gt; row_sel_try_search_shortcut_for_mysql</span><br><span class=\"line\">|    |    |--&gt; btr_pcur_open_with_no_init</span><br><span class=\"line\">|    |    |    |--&gt; btr_cur_search_to_nth_level</span><br><span class=\"line\">|    |    |    |    |--&gt; btr_search_guess_on_hash</span><br><span class=\"line\">|    |    |    |    |--&gt; ...</span><br><span class=\"line\">|    </span><br><span class=\"line\">|    <span class=\"comment\">// 3. open/restore index</span></span><br><span class=\"line\">|    |--&gt; sel_restore_position_for_mysql</span><br><span class=\"line\">|    |    |--&gt; btr_pcur_restore_position</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; btr_pcur_open_with_no_init</span><br><span class=\"line\">|    |    |--&gt; btr_cur_search_to_nth_level</span><br><span class=\"line\">|    |    |    |--&gt; btr_search_guess_on_hash</span><br><span class=\"line\">|    |    |    |--&gt; buf_page_get_gen</span><br><span class=\"line\">|    |    |    |--&gt; page_cur_search_with_match</span><br><span class=\"line\">|    |    |    |    |--&gt; page_dir_get_nth_slot</span><br><span class=\"line\">|    |    |    |    |--&gt; page_dir_slot_get_rec</span><br><span class=\"line\">|    |    |    |    |--&gt; cmp_dtuple_rec_with_match</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; btr_pcur_open_at_index_side</span><br><span class=\"line\">|    |    |--&gt; btr_cur_open_at_index_side</span><br><span class=\"line\">|    |    |    |--&gt; buf_page_get_gen</span><br><span class=\"line\">|    </span><br><span class=\"line\">|    <span class=\"comment\">// 4. match record (mvcc check)</span></span><br><span class=\"line\">|    |--&gt; lock_clust_rec_cons_read_sees</span><br><span class=\"line\">|    |    |--&gt; view-&gt;changes_visible</span><br><span class=\"line\">|    |--&gt; row_sel_build_prev_vers_for_mysql</span><br><span class=\"line\">|    |    |--&gt; row_vers_build_for_consistent_read <span class=\"comment\">// loop</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_undo_prev_version_build</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_get_undo_rec</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_update_rec_get_update</span><br><span class=\"line\">|    |    |    |    |--&gt; row_upd_rec_in_place</span><br><span class=\"line\">|    |    |    |--&gt; <span class=\"comment\">/* modifications_visible */</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; lock_sec_rec_cons_read_sees</span><br><span class=\"line\">|    |--&gt; row_sel_get_clust_rec_for_mysql</span><br><span class=\"line\">|    |    |--&gt; lock_clust_rec_cons_read_sees</span><br><span class=\"line\">|    |    |--&gt; row_sel_build_prev_vers_for_mysql</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; row_sel_store_mysql_rec</span><br><span class=\"line\">|    </span><br><span class=\"line\">|    <span class=\"comment\">// 5. move cousor to next index record</span></span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<ol>\n<li><p>btr_search_guess_on_hash 方法会从 AHI 中进行查询</p>\n</li>\n<li><p>buf_page_get_gen 方法会从指定的 (space, offset) 获取1个page，并放入 BP 中，基本步骤如下：</p>\n</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* buf_page_get_gen */</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; buf_page_hash_get_low <span class=\"comment\">// 1. 查看 page 是否在 page_hash 中</span></span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; buf_page_read <span class=\"comment\">// 2. 从文件中读取 page</span></span><br><span class=\"line\">|    |--&gt; buf_page_read_low</span><br><span class=\"line\">|    |    |--&gt; buf_page_init_for_read</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_get_free_block <span class=\"comment\">// 获取1个新的block</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_page_hash_get_low <span class=\"comment\">// 再次检查 page_hash 中是否存在</span></span><br><span class=\"line\">|    |    |    |--&gt; fil_tablespace_deleted_or_being_deleted_in_mem <span class=\"comment\">// 检查tablespace是否删除</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_page_init</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_block_init_low</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_page_init_low</span><br><span class=\"line\">|    |    |    |    |--&gt; HASH_INSERT</span><br><span class=\"line\">|    |    |    |--&gt; buf_page_set_io_fix</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_add_block</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; _fil_io</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; buf_page_io_complete</span><br><span class=\"line\">|    |    |    |--&gt; ibuf_merge_or_delete_for_page</span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; buf_block_fix</span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; buf_page_make_young_if_needed</span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; mtr_memo_push / mtr_add_page</span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; buf_read_ahead_linear</span><br></pre></td></tr></table></figure>\n\n<p>以上只是 InnoDB 读操作的一个基本流程，具体内容待后续继续分析。</p>\n<h2 id=\"写操作\"><a href=\"#写操作\" class=\"headerlink\" title=\"写操作\"></a>写操作</h2><p>基于 8.0 版本</p>\n<h3 id=\"更新操作\"><a href=\"#更新操作\" class=\"headerlink\" title=\"更新操作\"></a>更新操作</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; row_update_for_mysql</span><br><span class=\"line\">|    |--&gt; row_update_for_mysql_using_upd_graph</span><br><span class=\"line\">|    |    |--&gt; row_upd_step</span><br><span class=\"line\">|    |    |    |--&gt; row_upd</span><br><span class=\"line\">|    |    |    |    |--&gt; row_upd_clust_step <span class=\"comment\">// 更新主键</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; btr_pcur_restore_position <span class=\"comment\">// 恢复cursor，找到待更新的页，记录到mtr</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; btr_cur_optimistic_latch_leaves</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; dict_index_build_data_tuple</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; open_no_init</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; btr_cur_search_to_nth_level</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; row_upd_del_mark_clust_rec <span class=\"comment\">// 标记删除</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; btr_cur_del_mark_set_clust_rec</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; trx_undo_report_row_operation</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; btr_rec_set_deleted_flag <span class=\"comment\">// 修改记录</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_upd_rec_sys_fields</span><br><span class=\"line\">|    |    |    |    |    |  </span><br><span class=\"line\">|    |    |    |    |    |--&gt; row_upd_clust_rec <span class=\"comment\">// 原地更新</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; btr_cur_update_in_place</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; btr_cur_upd_lock_and_undo</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; trx_undo_report_row_operation</span><br><span class=\"line\">|    |    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_upd_rec_sys_fields</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_upd_rec_in_place <span class=\"comment\">// 修改记录</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; btr_cur_update_in_place_log</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; row_upd_write_sys_vals_to_log</span><br><span class=\"line\">|    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; btr_cur_optimistic_update</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; btr_cur_update_in_place</span><br><span class=\"line\">|    |    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; page_cur_delete_rec</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_upd_index_entry_sys_field</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; btr_cur_insert_if_possible</span><br><span class=\"line\">|    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; btr_cur_pessimistic_update</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; row_upd_clust_rec_by_insert <span class=\"comment\">// 删除 + 插入</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; btr_cur_del_mark_set_clust_rec</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; trx_undo_report_row_operation</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; row_ins_clust_index_entry</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_ins_clust_index_entry_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; btr_cur_optimistic_insert</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; btr_cur_ins_lock_and_undo</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |--&gt; trx_undo_report_row_operation</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; row_upd_sec_step <span class=\"comment\">// 更新二级索引</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; row_upd_del_multi_sec_index_entry</span><br><span class=\"line\">|    |    |    |    |    |--&gt; row_upd_multi_sec_index_entry</span><br><span class=\"line\">|    |    |    |    |    |--&gt; row_upd_sec_index_entry</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt;row_upd_sec_index_entry_low <span class=\"comment\">// 删除 + 插入</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_build_index_entry</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_search_index_entry</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; btr_cur_del_mark_set_sec_rec</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_build_index_entry</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_ins_sec_index_entry</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"插入操作\"><a href=\"#插入操作\" class=\"headerlink\" title=\"插入操作\"></a>插入操作</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; row_insert_for_mysql</span><br><span class=\"line\">|    |--&gt; row_insert_for_mysql_using_ins_graph</span><br><span class=\"line\">|    |    |--&gt; row_get_prebuilt_insert_row</span><br><span class=\"line\">|    |    |    |--&gt; ins_node_set_new_row</span><br><span class=\"line\">|    |    |    |    |--&gt; row_ins_alloc_sys_fields</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; row_mysql_convert_row_to_innobase</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; row_ins_step</span><br><span class=\"line\">|    |    |    |--&gt; row_ins</span><br><span class=\"line\">|    |    |    |    |--&gt; row_ins_index_entry_step</span><br><span class=\"line\">|    |    |    |    |    |--&gt; row_ins_index_entry</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; row_ins_clust_index_entry <span class=\"comment\">// 插入主键</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_ins_clust_index_entry_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; row_ins_clust_index_entry_by_modify <span class=\"comment\">// 可以复用</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; btr_cur_optimistic_insert <span class=\"comment\">// 乐观插入</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; btr_cur_ins_lock_and_undo</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |--&gt; trx_undo_report_row_operation</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |--&gt; row_upd_index_entry_sys_field</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; page_cur_tuple_insert <span class=\"comment\">// 插入记录</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |--&gt; page_cur_insert_rec_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; btr_cur_pessimistic_insert <span class=\"comment\">// 悲观插入</span></span><br><span class=\"line\">|    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; row_ins_sec_index_multi_value_entry</span><br><span class=\"line\">|    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; row_ins_sec_index_entry <span class=\"comment\">// 插入二级索引</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_ins_sec_index_entry_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; btr_cur_search_to_nth_level <span class=\"comment\">// 查找插入的位置</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; btr_cur_optimistic_insert</span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<p>trx_undo_report_row_operation 会进行 undo 的记录和数据的修改，基本步骤如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* trx_undo_report_row_operation */</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; trx_undo_assign_undo <span class=\"comment\">// 1. 分配 undo 空间</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; buf_page_get_gen  <span class=\"comment\">// 2. 获取 undo page</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; trx_undo_page_report_insert</span><br><span class=\"line\">|--&gt; trx_undo_page_report_modify</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>前面 MySQL 中的 SQL 执行过程中，已经简单介绍了 1 条 SQL 在 MySQL Server 层的执行路径，本文继续介绍 1 条 SQL 在 InnoDB 层的执行路径。</p>","more":"<h2 id=\"读操作\"><a href=\"#读操作\" class=\"headerlink\" title=\"读操作\"></a>读操作</h2><p>对于读操作，InnnoDB 的主要处理逻辑在 row_search_for_mysql (row_search_mvcc) 方法中，基本的步骤整理如下（基于 5.6 版本）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; row_search_mvcc</span><br><span class=\"line\">|    <span class=\"comment\">// 1. check prefetch cache</span></span><br><span class=\"line\">|    |--&gt; row_sel_dequeue_cached_row_for_mysql</span><br><span class=\"line\">|    </span><br><span class=\"line\">|    <span class=\"comment\">// 2. check AHI</span></span><br><span class=\"line\">|    |--&gt; row_sel_try_search_shortcut_for_mysql</span><br><span class=\"line\">|    |    |--&gt; btr_pcur_open_with_no_init</span><br><span class=\"line\">|    |    |    |--&gt; btr_cur_search_to_nth_level</span><br><span class=\"line\">|    |    |    |    |--&gt; btr_search_guess_on_hash</span><br><span class=\"line\">|    |    |    |    |--&gt; ...</span><br><span class=\"line\">|    </span><br><span class=\"line\">|    <span class=\"comment\">// 3. open/restore index</span></span><br><span class=\"line\">|    |--&gt; sel_restore_position_for_mysql</span><br><span class=\"line\">|    |    |--&gt; btr_pcur_restore_position</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; btr_pcur_open_with_no_init</span><br><span class=\"line\">|    |    |--&gt; btr_cur_search_to_nth_level</span><br><span class=\"line\">|    |    |    |--&gt; btr_search_guess_on_hash</span><br><span class=\"line\">|    |    |    |--&gt; buf_page_get_gen</span><br><span class=\"line\">|    |    |    |--&gt; page_cur_search_with_match</span><br><span class=\"line\">|    |    |    |    |--&gt; page_dir_get_nth_slot</span><br><span class=\"line\">|    |    |    |    |--&gt; page_dir_slot_get_rec</span><br><span class=\"line\">|    |    |    |    |--&gt; cmp_dtuple_rec_with_match</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; btr_pcur_open_at_index_side</span><br><span class=\"line\">|    |    |--&gt; btr_cur_open_at_index_side</span><br><span class=\"line\">|    |    |    |--&gt; buf_page_get_gen</span><br><span class=\"line\">|    </span><br><span class=\"line\">|    <span class=\"comment\">// 4. match record (mvcc check)</span></span><br><span class=\"line\">|    |--&gt; lock_clust_rec_cons_read_sees</span><br><span class=\"line\">|    |    |--&gt; view-&gt;changes_visible</span><br><span class=\"line\">|    |--&gt; row_sel_build_prev_vers_for_mysql</span><br><span class=\"line\">|    |    |--&gt; row_vers_build_for_consistent_read <span class=\"comment\">// loop</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_undo_prev_version_build</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_get_undo_rec</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_update_rec_get_update</span><br><span class=\"line\">|    |    |    |    |--&gt; row_upd_rec_in_place</span><br><span class=\"line\">|    |    |    |--&gt; <span class=\"comment\">/* modifications_visible */</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; lock_sec_rec_cons_read_sees</span><br><span class=\"line\">|    |--&gt; row_sel_get_clust_rec_for_mysql</span><br><span class=\"line\">|    |    |--&gt; lock_clust_rec_cons_read_sees</span><br><span class=\"line\">|    |    |--&gt; row_sel_build_prev_vers_for_mysql</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; row_sel_store_mysql_rec</span><br><span class=\"line\">|    </span><br><span class=\"line\">|    <span class=\"comment\">// 5. move cousor to next index record</span></span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<ol>\n<li><p>btr_search_guess_on_hash 方法会从 AHI 中进行查询</p>\n</li>\n<li><p>buf_page_get_gen 方法会从指定的 (space, offset) 获取1个page，并放入 BP 中，基本步骤如下：</p>\n</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* buf_page_get_gen */</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; buf_page_hash_get_low <span class=\"comment\">// 1. 查看 page 是否在 page_hash 中</span></span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; buf_page_read <span class=\"comment\">// 2. 从文件中读取 page</span></span><br><span class=\"line\">|    |--&gt; buf_page_read_low</span><br><span class=\"line\">|    |    |--&gt; buf_page_init_for_read</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_get_free_block <span class=\"comment\">// 获取1个新的block</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_page_hash_get_low <span class=\"comment\">// 再次检查 page_hash 中是否存在</span></span><br><span class=\"line\">|    |    |    |--&gt; fil_tablespace_deleted_or_being_deleted_in_mem <span class=\"comment\">// 检查tablespace是否删除</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_page_init</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_block_init_low</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_page_init_low</span><br><span class=\"line\">|    |    |    |    |--&gt; HASH_INSERT</span><br><span class=\"line\">|    |    |    |--&gt; buf_page_set_io_fix</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_add_block</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; _fil_io</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; buf_page_io_complete</span><br><span class=\"line\">|    |    |    |--&gt; ibuf_merge_or_delete_for_page</span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; buf_block_fix</span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; buf_page_make_young_if_needed</span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; mtr_memo_push / mtr_add_page</span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; buf_read_ahead_linear</span><br></pre></td></tr></table></figure>\n\n<p>以上只是 InnoDB 读操作的一个基本流程，具体内容待后续继续分析。</p>\n<h2 id=\"写操作\"><a href=\"#写操作\" class=\"headerlink\" title=\"写操作\"></a>写操作</h2><p>基于 8.0 版本</p>\n<h3 id=\"更新操作\"><a href=\"#更新操作\" class=\"headerlink\" title=\"更新操作\"></a>更新操作</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; row_update_for_mysql</span><br><span class=\"line\">|    |--&gt; row_update_for_mysql_using_upd_graph</span><br><span class=\"line\">|    |    |--&gt; row_upd_step</span><br><span class=\"line\">|    |    |    |--&gt; row_upd</span><br><span class=\"line\">|    |    |    |    |--&gt; row_upd_clust_step <span class=\"comment\">// 更新主键</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; btr_pcur_restore_position <span class=\"comment\">// 恢复cursor，找到待更新的页，记录到mtr</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; btr_cur_optimistic_latch_leaves</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; dict_index_build_data_tuple</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; open_no_init</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; btr_cur_search_to_nth_level</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; row_upd_del_mark_clust_rec <span class=\"comment\">// 标记删除</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; btr_cur_del_mark_set_clust_rec</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; trx_undo_report_row_operation</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; btr_rec_set_deleted_flag <span class=\"comment\">// 修改记录</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_upd_rec_sys_fields</span><br><span class=\"line\">|    |    |    |    |    |  </span><br><span class=\"line\">|    |    |    |    |    |--&gt; row_upd_clust_rec <span class=\"comment\">// 原地更新</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; btr_cur_update_in_place</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; btr_cur_upd_lock_and_undo</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; trx_undo_report_row_operation</span><br><span class=\"line\">|    |    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_upd_rec_sys_fields</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_upd_rec_in_place <span class=\"comment\">// 修改记录</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; btr_cur_update_in_place_log</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; row_upd_write_sys_vals_to_log</span><br><span class=\"line\">|    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; btr_cur_optimistic_update</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; btr_cur_update_in_place</span><br><span class=\"line\">|    |    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; page_cur_delete_rec</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_upd_index_entry_sys_field</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; btr_cur_insert_if_possible</span><br><span class=\"line\">|    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; btr_cur_pessimistic_update</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; row_upd_clust_rec_by_insert <span class=\"comment\">// 删除 + 插入</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; btr_cur_del_mark_set_clust_rec</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; trx_undo_report_row_operation</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; row_ins_clust_index_entry</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_ins_clust_index_entry_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; btr_cur_optimistic_insert</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; btr_cur_ins_lock_and_undo</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |--&gt; trx_undo_report_row_operation</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; row_upd_sec_step <span class=\"comment\">// 更新二级索引</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; row_upd_del_multi_sec_index_entry</span><br><span class=\"line\">|    |    |    |    |    |--&gt; row_upd_multi_sec_index_entry</span><br><span class=\"line\">|    |    |    |    |    |--&gt; row_upd_sec_index_entry</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt;row_upd_sec_index_entry_low <span class=\"comment\">// 删除 + 插入</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_build_index_entry</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_search_index_entry</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; btr_cur_del_mark_set_sec_rec</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_build_index_entry</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_ins_sec_index_entry</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"插入操作\"><a href=\"#插入操作\" class=\"headerlink\" title=\"插入操作\"></a>插入操作</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; row_insert_for_mysql</span><br><span class=\"line\">|    |--&gt; row_insert_for_mysql_using_ins_graph</span><br><span class=\"line\">|    |    |--&gt; row_get_prebuilt_insert_row</span><br><span class=\"line\">|    |    |    |--&gt; ins_node_set_new_row</span><br><span class=\"line\">|    |    |    |    |--&gt; row_ins_alloc_sys_fields</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; row_mysql_convert_row_to_innobase</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; row_ins_step</span><br><span class=\"line\">|    |    |    |--&gt; row_ins</span><br><span class=\"line\">|    |    |    |    |--&gt; row_ins_index_entry_step</span><br><span class=\"line\">|    |    |    |    |    |--&gt; row_ins_index_entry</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; row_ins_clust_index_entry <span class=\"comment\">// 插入主键</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_ins_clust_index_entry_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; row_ins_clust_index_entry_by_modify <span class=\"comment\">// 可以复用</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; btr_cur_optimistic_insert <span class=\"comment\">// 乐观插入</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; btr_cur_ins_lock_and_undo</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |--&gt; trx_undo_report_row_operation</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |--&gt; row_upd_index_entry_sys_field</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; page_cur_tuple_insert <span class=\"comment\">// 插入记录</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |--&gt; page_cur_insert_rec_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; btr_cur_pessimistic_insert <span class=\"comment\">// 悲观插入</span></span><br><span class=\"line\">|    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; row_ins_sec_index_multi_value_entry</span><br><span class=\"line\">|    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; row_ins_sec_index_entry <span class=\"comment\">// 插入二级索引</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_ins_sec_index_entry_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; btr_cur_search_to_nth_level <span class=\"comment\">// 查找插入的位置</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; btr_cur_optimistic_insert</span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<p>trx_undo_report_row_operation 会进行 undo 的记录和数据的修改，基本步骤如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* trx_undo_report_row_operation */</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; trx_undo_assign_undo <span class=\"comment\">// 1. 分配 undo 空间</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; buf_page_get_gen  <span class=\"comment\">// 2. 获取 undo page</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; trx_undo_page_report_insert</span><br><span class=\"line\">|--&gt; trx_undo_page_report_modify</span><br></pre></td></tr></table></figure>"},{"title":"InnoDB 简介","date":"2020-07-18T12:02:35.000Z","_content":"\n最近在 Percona 的网站上看到了一张介绍 InnoDB 整体架构的图片，觉得总结的非常好，引用如下。\n\n<!-- more -->\n\n## InnoDB 整体架构\n\n<img src=\"/images/innodb-intro-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>","source":"_posts/innodb/innodb-intro.md","raw":"---\ntitle: InnoDB 简介\ndate: 2020-07-18 20:02:35\ntags:\n- 架构\ncategories: \n- InnoDB\n\n---\n\n最近在 Percona 的网站上看到了一张介绍 InnoDB 整体架构的图片，觉得总结的非常好，引用如下。\n\n<!-- more -->\n\n## InnoDB 整体架构\n\n<img src=\"/images/innodb-intro-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>","slug":"innodb/innodb-intro","published":1,"updated":"2020-12-05T13:17:45.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4xc000igugma0j72lke","content":"<p>最近在 Percona 的网站上看到了一张介绍 InnoDB 整体架构的图片，觉得总结的非常好，引用如下。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"InnoDB-整体架构\"><a href=\"#InnoDB-整体架构\" class=\"headerlink\" title=\"InnoDB 整体架构\"></a>InnoDB 整体架构</h2><img src=\"/images/innodb-intro-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>","site":{"data":{}},"excerpt":"<p>最近在 Percona 的网站上看到了一张介绍 InnoDB 整体架构的图片，觉得总结的非常好，引用如下。</p>","more":"<h2 id=\"InnoDB-整体架构\"><a href=\"#InnoDB-整体架构\" class=\"headerlink\" title=\"InnoDB 整体架构\"></a>InnoDB 整体架构</h2><img src=\"/images/innodb-intro-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>"},{"title":"InnoDB 锁机制","date":"2020-12-05T13:11:33.000Z","_content":"\n本文主要对 InnoDB 层的锁机制进行说明。\n\n<!-- more -->\n\n## 行级锁的基本概念\n\n### 数据结构\n\n<img src=\"/images/innodb-lock-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n注释：\n\n1. lock_t 是一个内存结构，内存从 trx_lock_t 上进行分配，也可以理解为在 trx 上进行分配\n2. lock_sys_t 是一个全局的数据结构，通过 hash_table_t 保存了所有分配的 lock_t\n3. 锁等待借助于 srv_slot_t 中的 os_event_t 来实现，lock_sys_t 中也保存了所有使用的 srv_slot_t\n4. trx_lock_t 的 blocking_trx 中保存了 trx 间的锁等待关系，标记当前 trx 在等待另外一个 trx 分配的锁\n5. trx_lock_t 的 wait_thr 字段标记了等待当前锁的线程\n\n### 行级锁类型\n\n```bash\n// 1. LOCK_REC_NOT_GAP : 记录锁\n\n// 2. LOCK_GAP : 区间锁\n\n// 3. LOCK_ORDINARY(Next-Key Lock) : 包含记录本身及记录之前的 GAP\n```\n\n### 源码分析\n\n加行锁的入口包含 sel_set_rec_lock 和 row_ins_set_rec_lock，基本调用路径如下：\n\n```c++\n|--> sel_set_rec_lock\n|    |--> btr_pcur_get_block\n|    |\n|    |--> lock_clust_rec_read_check_and_lock\n|    |    |--> page_rec_get_heap_no\n|    |    |--> lock_rec_convert_impl_to_expl  // 隐式锁升级\n|    |    |    |--> lock_clust_rec_some_has_impl\n|    |    |    |--> trx_rw_is_active\n|    |    |    |--> lock_rec_convert_impl_to_expl_for_trx\n|    |    |    |    |--> lock_rec_add_to_queue\n|    |    |    |    |    |--> rec_lock.create\n|    |    |    |    |    |    |--> lock_alloc\n|    |    |    |    |    |    |--> lock_add // 维护 hash + trx->lock->trx_locks 列表\n|    |    |\n|    |    |--> lock_rec_lock\n|    |    |    |--> lock_rec_lock_fast\n|    |    |    |    |--> lock_rec_get_first_on_page\n|    |    |    |\n|    |    |    |--> lock_rec_lock_slow\n|    |    |    |    |--> lock_rec_has_expl\n|    |    |    |    |--> lock_rec_other_has_conflicting  // 锁冲突检查\n|    |    |    |    |    |--> lock_rec_has_to_wait  // Lock_iter::for_each(rec_id, ...) 按照 rec_id 遍历 hash, 检查是否需要等待锁\n|    |    |    |    |\n|    |    |    |    |--> rec_lock.add_to_waitq  // 创建锁等待关系\n|    |    |    |    |    |--> create\n|    |    |    |    |    |--> lock_create_wait_for_edge\n|    |    |    |    |    |--> set_wait_state\n|    |    |    |    |    |    |--> que_thr_stop\n|    |    |    |    |\n|    |    |    |    |--> lock_rec_add_to_queue\n|    |\n|    |--> lock_sec_rec_read_check_and_lock\n|    |    |--> page_rec_get_heap_no\n|    |    |--> lock_rec_convert_impl_to_expl\n|    |    |--> lock_rec_lock\n\n\n\n|--> row_ins_set_rec_lock\n|    |--> lock_clust_rec_read_check_and_lock\n|    |\n|    |--> lock_sec_rec_read_check_and_lock\n\n\n\n|--> lock_clust_rec_modify_check_and_lock\n|    |--> lock_rec_convert_impl_to_expl\n|    |\n|    |--> lock_rec_lock\n```\n\n锁等待判断：\n\n```c++\n|--> lock_rec_has_to_wait\n```\n\n锁等待处理入口：\n\n```c++\n|--> lock_wait_suspend_thread\n|    |--> trx_lock_wait_timeout_get\n|    |\n|    |--> lock_wait_table_reserve_slot  // slot 绑定到 thr\n|    |--> os_event_wait(slot->event)\n|    |--> lock_wait_table_release_slot\n```\n\n锁释放入口：\n\n```c++\n|--> trx_commit_in_memory\n|    |--> trx_release_impl_and_expl_locks\n|    |    |--> lock_trx_release_locks\n|    |    |    |--> lock_release\n|    |    |    |    |--> lock_rec_dequeue_from_page\n|    |    |    |    |    |--> lock_rec_discard\n|    |    |    |    |    |--> lock_rec_grant // 遍历 page，查看是否有需要唤醒的锁等待\n|    |    |    |    |    |    |--> lock_grant_or_update_wait_for_edge_if_waiting\n|    |    |    |    |    |    |    |--> lock_grant_or_update_wait_for_edge\n|    |    |    |    |    |    |    |    |--> lock_has_to_wait_in_queue // 检查是否需要继续等待\n|    |    |    |    |    |    |    |    |--> lock_grant // 解锁，唤醒 trx->lock->wait_thr\n|    |    |    |    |    |    |    |    |    |--> lock_reset_wait_and_release_thread_if_suspended\n|    |    |    |    |    |    |    |    |    |    |--> lock_reset_lock_and_trx_wait\n|    |    |    |    |    |    |    |    |    |    |--> lock_wait_release_thread_if_suspended\n|    |    |    |    |    |    |    |    |    |    |    |--> que_thr_end_lock_wait\n|    |    |    |    |    |    |    |    |    |    |    |--> os_event_set(thr->slot->event)\n|    |    |    |    |    |    |    |    |--> lock_update_wait_for_edge \n|    |    |    |    |    |    |\n|    |    |    |    |    |    |--> lock_grant_cats\n|    |    |    |    |\n|    |    |    |    |--> lock_table_dequeue\n```\n\n## 参考文献\n\n> InnoDB 事务锁系统简介：http://mysql.taobao.org/monthly/2016/01/01/\n>\n> InnoDB 锁子系统浅析：http://mysql.taobao.org/monthly/2017/12/02/\n>\n> InnoDB 行锁分析：http://mysql.taobao.org/monthly/2018/05/04/\n>\n> https://time.geekbang.org/column/article/75659","source":"_posts/innodb/innodb-lock.md","raw":"---\ntitle: InnoDB 锁机制\ndate: 2020-12-05 21:11:33\ncategories: \n- InnoDB\n\n---\n\n本文主要对 InnoDB 层的锁机制进行说明。\n\n<!-- more -->\n\n## 行级锁的基本概念\n\n### 数据结构\n\n<img src=\"/images/innodb-lock-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n注释：\n\n1. lock_t 是一个内存结构，内存从 trx_lock_t 上进行分配，也可以理解为在 trx 上进行分配\n2. lock_sys_t 是一个全局的数据结构，通过 hash_table_t 保存了所有分配的 lock_t\n3. 锁等待借助于 srv_slot_t 中的 os_event_t 来实现，lock_sys_t 中也保存了所有使用的 srv_slot_t\n4. trx_lock_t 的 blocking_trx 中保存了 trx 间的锁等待关系，标记当前 trx 在等待另外一个 trx 分配的锁\n5. trx_lock_t 的 wait_thr 字段标记了等待当前锁的线程\n\n### 行级锁类型\n\n```bash\n// 1. LOCK_REC_NOT_GAP : 记录锁\n\n// 2. LOCK_GAP : 区间锁\n\n// 3. LOCK_ORDINARY(Next-Key Lock) : 包含记录本身及记录之前的 GAP\n```\n\n### 源码分析\n\n加行锁的入口包含 sel_set_rec_lock 和 row_ins_set_rec_lock，基本调用路径如下：\n\n```c++\n|--> sel_set_rec_lock\n|    |--> btr_pcur_get_block\n|    |\n|    |--> lock_clust_rec_read_check_and_lock\n|    |    |--> page_rec_get_heap_no\n|    |    |--> lock_rec_convert_impl_to_expl  // 隐式锁升级\n|    |    |    |--> lock_clust_rec_some_has_impl\n|    |    |    |--> trx_rw_is_active\n|    |    |    |--> lock_rec_convert_impl_to_expl_for_trx\n|    |    |    |    |--> lock_rec_add_to_queue\n|    |    |    |    |    |--> rec_lock.create\n|    |    |    |    |    |    |--> lock_alloc\n|    |    |    |    |    |    |--> lock_add // 维护 hash + trx->lock->trx_locks 列表\n|    |    |\n|    |    |--> lock_rec_lock\n|    |    |    |--> lock_rec_lock_fast\n|    |    |    |    |--> lock_rec_get_first_on_page\n|    |    |    |\n|    |    |    |--> lock_rec_lock_slow\n|    |    |    |    |--> lock_rec_has_expl\n|    |    |    |    |--> lock_rec_other_has_conflicting  // 锁冲突检查\n|    |    |    |    |    |--> lock_rec_has_to_wait  // Lock_iter::for_each(rec_id, ...) 按照 rec_id 遍历 hash, 检查是否需要等待锁\n|    |    |    |    |\n|    |    |    |    |--> rec_lock.add_to_waitq  // 创建锁等待关系\n|    |    |    |    |    |--> create\n|    |    |    |    |    |--> lock_create_wait_for_edge\n|    |    |    |    |    |--> set_wait_state\n|    |    |    |    |    |    |--> que_thr_stop\n|    |    |    |    |\n|    |    |    |    |--> lock_rec_add_to_queue\n|    |\n|    |--> lock_sec_rec_read_check_and_lock\n|    |    |--> page_rec_get_heap_no\n|    |    |--> lock_rec_convert_impl_to_expl\n|    |    |--> lock_rec_lock\n\n\n\n|--> row_ins_set_rec_lock\n|    |--> lock_clust_rec_read_check_and_lock\n|    |\n|    |--> lock_sec_rec_read_check_and_lock\n\n\n\n|--> lock_clust_rec_modify_check_and_lock\n|    |--> lock_rec_convert_impl_to_expl\n|    |\n|    |--> lock_rec_lock\n```\n\n锁等待判断：\n\n```c++\n|--> lock_rec_has_to_wait\n```\n\n锁等待处理入口：\n\n```c++\n|--> lock_wait_suspend_thread\n|    |--> trx_lock_wait_timeout_get\n|    |\n|    |--> lock_wait_table_reserve_slot  // slot 绑定到 thr\n|    |--> os_event_wait(slot->event)\n|    |--> lock_wait_table_release_slot\n```\n\n锁释放入口：\n\n```c++\n|--> trx_commit_in_memory\n|    |--> trx_release_impl_and_expl_locks\n|    |    |--> lock_trx_release_locks\n|    |    |    |--> lock_release\n|    |    |    |    |--> lock_rec_dequeue_from_page\n|    |    |    |    |    |--> lock_rec_discard\n|    |    |    |    |    |--> lock_rec_grant // 遍历 page，查看是否有需要唤醒的锁等待\n|    |    |    |    |    |    |--> lock_grant_or_update_wait_for_edge_if_waiting\n|    |    |    |    |    |    |    |--> lock_grant_or_update_wait_for_edge\n|    |    |    |    |    |    |    |    |--> lock_has_to_wait_in_queue // 检查是否需要继续等待\n|    |    |    |    |    |    |    |    |--> lock_grant // 解锁，唤醒 trx->lock->wait_thr\n|    |    |    |    |    |    |    |    |    |--> lock_reset_wait_and_release_thread_if_suspended\n|    |    |    |    |    |    |    |    |    |    |--> lock_reset_lock_and_trx_wait\n|    |    |    |    |    |    |    |    |    |    |--> lock_wait_release_thread_if_suspended\n|    |    |    |    |    |    |    |    |    |    |    |--> que_thr_end_lock_wait\n|    |    |    |    |    |    |    |    |    |    |    |--> os_event_set(thr->slot->event)\n|    |    |    |    |    |    |    |    |--> lock_update_wait_for_edge \n|    |    |    |    |    |    |\n|    |    |    |    |    |    |--> lock_grant_cats\n|    |    |    |    |\n|    |    |    |    |--> lock_table_dequeue\n```\n\n## 参考文献\n\n> InnoDB 事务锁系统简介：http://mysql.taobao.org/monthly/2016/01/01/\n>\n> InnoDB 锁子系统浅析：http://mysql.taobao.org/monthly/2017/12/02/\n>\n> InnoDB 行锁分析：http://mysql.taobao.org/monthly/2018/05/04/\n>\n> https://time.geekbang.org/column/article/75659","slug":"innodb/innodb-lock","published":1,"updated":"2020-12-05T13:52:21.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4xe000lgugm2uxy2d1c","content":"<p>本文主要对 InnoDB 层的锁机制进行说明。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"行级锁的基本概念\"><a href=\"#行级锁的基本概念\" class=\"headerlink\" title=\"行级锁的基本概念\"></a>行级锁的基本概念</h2><h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><img src=\"/images/innodb-lock-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>注释：</p>\n<ol>\n<li>lock_t 是一个内存结构，内存从 trx_lock_t 上进行分配，也可以理解为在 trx 上进行分配</li>\n<li>lock_sys_t 是一个全局的数据结构，通过 hash_table_t 保存了所有分配的 lock_t</li>\n<li>锁等待借助于 srv_slot_t 中的 os_event_t 来实现，lock_sys_t 中也保存了所有使用的 srv_slot_t</li>\n<li>trx_lock_t 的 blocking_trx 中保存了 trx 间的锁等待关系，标记当前 trx 在等待另外一个 trx 分配的锁</li>\n<li>trx_lock_t 的 wait_thr 字段标记了等待当前锁的线程</li>\n</ol>\n<h3 id=\"行级锁类型\"><a href=\"#行级锁类型\" class=\"headerlink\" title=\"行级锁类型\"></a>行级锁类型</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1. LOCK_REC_NOT_GAP : 记录锁</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. LOCK_GAP : 区间锁</span><br><span class=\"line\"></span><br><span class=\"line\">// 3. LOCK_ORDINARY(Next-Key Lock) : 包含记录本身及记录之前的 GAP</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p>加行锁的入口包含 sel_set_rec_lock 和 row_ins_set_rec_lock，基本调用路径如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; sel_set_rec_lock</span><br><span class=\"line\">|    |--&gt; btr_pcur_get_block</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; lock_clust_rec_read_check_and_lock</span><br><span class=\"line\">|    |    |--&gt; page_rec_get_heap_no</span><br><span class=\"line\">|    |    |--&gt; lock_rec_convert_impl_to_expl  <span class=\"comment\">// 隐式锁升级</span></span><br><span class=\"line\">|    |    |    |--&gt; lock_clust_rec_some_has_impl</span><br><span class=\"line\">|    |    |    |--&gt; trx_rw_is_active</span><br><span class=\"line\">|    |    |    |--&gt; lock_rec_convert_impl_to_expl_for_trx</span><br><span class=\"line\">|    |    |    |    |--&gt; lock_rec_add_to_queue</span><br><span class=\"line\">|    |    |    |    |    |--&gt; rec_lock.create</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; lock_alloc</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; lock_add <span class=\"comment\">// 维护 hash + trx-&gt;lock-&gt;trx_locks 列表</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; lock_rec_lock</span><br><span class=\"line\">|    |    |    |--&gt; lock_rec_lock_fast</span><br><span class=\"line\">|    |    |    |    |--&gt; lock_rec_get_first_on_page</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; lock_rec_lock_slow</span><br><span class=\"line\">|    |    |    |    |--&gt; lock_rec_has_expl</span><br><span class=\"line\">|    |    |    |    |--&gt; lock_rec_other_has_conflicting  <span class=\"comment\">// 锁冲突检查</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; lock_rec_has_to_wait  <span class=\"comment\">// Lock_iter::for_each(rec_id, ...) 按照 rec_id 遍历 hash, 检查是否需要等待锁</span></span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; rec_lock.add_to_waitq  <span class=\"comment\">// 创建锁等待关系</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; create</span><br><span class=\"line\">|    |    |    |    |    |--&gt; lock_create_wait_for_edge</span><br><span class=\"line\">|    |    |    |    |    |--&gt; set_wait_state</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; que_thr_stop</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; lock_rec_add_to_queue</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; lock_sec_rec_read_check_and_lock</span><br><span class=\"line\">|    |    |--&gt; page_rec_get_heap_no</span><br><span class=\"line\">|    |    |--&gt; lock_rec_convert_impl_to_expl</span><br><span class=\"line\">|    |    |--&gt; lock_rec_lock</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; row_ins_set_rec_lock</span><br><span class=\"line\">|    |--&gt; lock_clust_rec_read_check_and_lock</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; lock_sec_rec_read_check_and_lock</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; lock_clust_rec_modify_check_and_lock</span><br><span class=\"line\">|    |--&gt; lock_rec_convert_impl_to_expl</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; lock_rec_lock</span><br></pre></td></tr></table></figure>\n\n<p>锁等待判断：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; lock_rec_has_to_wait</span><br></pre></td></tr></table></figure>\n\n<p>锁等待处理入口：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; lock_wait_suspend_thread</span><br><span class=\"line\">|    |--&gt; trx_lock_wait_timeout_get</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; lock_wait_table_reserve_slot  <span class=\"comment\">// slot 绑定到 thr</span></span><br><span class=\"line\">|    |--&gt; os_event_wait(slot-&gt;event)</span><br><span class=\"line\">|    |--&gt; lock_wait_table_release_slot</span><br></pre></td></tr></table></figure>\n\n<p>锁释放入口：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; trx_commit_in_memory</span><br><span class=\"line\">|    |--&gt; trx_release_impl_and_expl_locks</span><br><span class=\"line\">|    |    |--&gt; lock_trx_release_locks</span><br><span class=\"line\">|    |    |    |--&gt; lock_release</span><br><span class=\"line\">|    |    |    |    |--&gt; lock_rec_dequeue_from_page</span><br><span class=\"line\">|    |    |    |    |    |--&gt; lock_rec_discard</span><br><span class=\"line\">|    |    |    |    |    |--&gt; lock_rec_grant <span class=\"comment\">// 遍历 page，查看是否有需要唤醒的锁等待</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; lock_grant_or_update_wait_for_edge_if_waiting</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; lock_grant_or_update_wait_for_edge</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; lock_has_to_wait_in_queue <span class=\"comment\">// 检查是否需要继续等待</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; lock_grant <span class=\"comment\">// 解锁，唤醒 trx-&gt;lock-&gt;wait_thr</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; lock_reset_wait_and_release_thread_if_suspended</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |--&gt; lock_reset_lock_and_trx_wait</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |--&gt; lock_wait_release_thread_if_suspended</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |    |--&gt; que_thr_end_lock_wait</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |    |--&gt; os_event_set(thr-&gt;slot-&gt;event)</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; lock_update_wait_for_edge </span><br><span class=\"line\">|    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; lock_grant_cats</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; lock_table_dequeue</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>InnoDB 事务锁系统简介：<a href=\"http://mysql.taobao.org/monthly/2016/01/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2016/01/01/</a></p>\n<p>InnoDB 锁子系统浅析：<a href=\"http://mysql.taobao.org/monthly/2017/12/02/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2017/12/02/</a></p>\n<p>InnoDB 行锁分析：<a href=\"http://mysql.taobao.org/monthly/2018/05/04/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2018/05/04/</a></p>\n<p><a href=\"https://time.geekbang.org/column/article/75659\" target=\"_blank\" rel=\"noopener\">https://time.geekbang.org/column/article/75659</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>本文主要对 InnoDB 层的锁机制进行说明。</p>","more":"<h2 id=\"行级锁的基本概念\"><a href=\"#行级锁的基本概念\" class=\"headerlink\" title=\"行级锁的基本概念\"></a>行级锁的基本概念</h2><h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><img src=\"/images/innodb-lock-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>注释：</p>\n<ol>\n<li>lock_t 是一个内存结构，内存从 trx_lock_t 上进行分配，也可以理解为在 trx 上进行分配</li>\n<li>lock_sys_t 是一个全局的数据结构，通过 hash_table_t 保存了所有分配的 lock_t</li>\n<li>锁等待借助于 srv_slot_t 中的 os_event_t 来实现，lock_sys_t 中也保存了所有使用的 srv_slot_t</li>\n<li>trx_lock_t 的 blocking_trx 中保存了 trx 间的锁等待关系，标记当前 trx 在等待另外一个 trx 分配的锁</li>\n<li>trx_lock_t 的 wait_thr 字段标记了等待当前锁的线程</li>\n</ol>\n<h3 id=\"行级锁类型\"><a href=\"#行级锁类型\" class=\"headerlink\" title=\"行级锁类型\"></a>行级锁类型</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1. LOCK_REC_NOT_GAP : 记录锁</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. LOCK_GAP : 区间锁</span><br><span class=\"line\"></span><br><span class=\"line\">// 3. LOCK_ORDINARY(Next-Key Lock) : 包含记录本身及记录之前的 GAP</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p>加行锁的入口包含 sel_set_rec_lock 和 row_ins_set_rec_lock，基本调用路径如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; sel_set_rec_lock</span><br><span class=\"line\">|    |--&gt; btr_pcur_get_block</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; lock_clust_rec_read_check_and_lock</span><br><span class=\"line\">|    |    |--&gt; page_rec_get_heap_no</span><br><span class=\"line\">|    |    |--&gt; lock_rec_convert_impl_to_expl  <span class=\"comment\">// 隐式锁升级</span></span><br><span class=\"line\">|    |    |    |--&gt; lock_clust_rec_some_has_impl</span><br><span class=\"line\">|    |    |    |--&gt; trx_rw_is_active</span><br><span class=\"line\">|    |    |    |--&gt; lock_rec_convert_impl_to_expl_for_trx</span><br><span class=\"line\">|    |    |    |    |--&gt; lock_rec_add_to_queue</span><br><span class=\"line\">|    |    |    |    |    |--&gt; rec_lock.create</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; lock_alloc</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; lock_add <span class=\"comment\">// 维护 hash + trx-&gt;lock-&gt;trx_locks 列表</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; lock_rec_lock</span><br><span class=\"line\">|    |    |    |--&gt; lock_rec_lock_fast</span><br><span class=\"line\">|    |    |    |    |--&gt; lock_rec_get_first_on_page</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; lock_rec_lock_slow</span><br><span class=\"line\">|    |    |    |    |--&gt; lock_rec_has_expl</span><br><span class=\"line\">|    |    |    |    |--&gt; lock_rec_other_has_conflicting  <span class=\"comment\">// 锁冲突检查</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; lock_rec_has_to_wait  <span class=\"comment\">// Lock_iter::for_each(rec_id, ...) 按照 rec_id 遍历 hash, 检查是否需要等待锁</span></span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; rec_lock.add_to_waitq  <span class=\"comment\">// 创建锁等待关系</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; create</span><br><span class=\"line\">|    |    |    |    |    |--&gt; lock_create_wait_for_edge</span><br><span class=\"line\">|    |    |    |    |    |--&gt; set_wait_state</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; que_thr_stop</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; lock_rec_add_to_queue</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; lock_sec_rec_read_check_and_lock</span><br><span class=\"line\">|    |    |--&gt; page_rec_get_heap_no</span><br><span class=\"line\">|    |    |--&gt; lock_rec_convert_impl_to_expl</span><br><span class=\"line\">|    |    |--&gt; lock_rec_lock</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; row_ins_set_rec_lock</span><br><span class=\"line\">|    |--&gt; lock_clust_rec_read_check_and_lock</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; lock_sec_rec_read_check_and_lock</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; lock_clust_rec_modify_check_and_lock</span><br><span class=\"line\">|    |--&gt; lock_rec_convert_impl_to_expl</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; lock_rec_lock</span><br></pre></td></tr></table></figure>\n\n<p>锁等待判断：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; lock_rec_has_to_wait</span><br></pre></td></tr></table></figure>\n\n<p>锁等待处理入口：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; lock_wait_suspend_thread</span><br><span class=\"line\">|    |--&gt; trx_lock_wait_timeout_get</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; lock_wait_table_reserve_slot  <span class=\"comment\">// slot 绑定到 thr</span></span><br><span class=\"line\">|    |--&gt; os_event_wait(slot-&gt;event)</span><br><span class=\"line\">|    |--&gt; lock_wait_table_release_slot</span><br></pre></td></tr></table></figure>\n\n<p>锁释放入口：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; trx_commit_in_memory</span><br><span class=\"line\">|    |--&gt; trx_release_impl_and_expl_locks</span><br><span class=\"line\">|    |    |--&gt; lock_trx_release_locks</span><br><span class=\"line\">|    |    |    |--&gt; lock_release</span><br><span class=\"line\">|    |    |    |    |--&gt; lock_rec_dequeue_from_page</span><br><span class=\"line\">|    |    |    |    |    |--&gt; lock_rec_discard</span><br><span class=\"line\">|    |    |    |    |    |--&gt; lock_rec_grant <span class=\"comment\">// 遍历 page，查看是否有需要唤醒的锁等待</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; lock_grant_or_update_wait_for_edge_if_waiting</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; lock_grant_or_update_wait_for_edge</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; lock_has_to_wait_in_queue <span class=\"comment\">// 检查是否需要继续等待</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; lock_grant <span class=\"comment\">// 解锁，唤醒 trx-&gt;lock-&gt;wait_thr</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; lock_reset_wait_and_release_thread_if_suspended</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |--&gt; lock_reset_lock_and_trx_wait</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |--&gt; lock_wait_release_thread_if_suspended</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |    |--&gt; que_thr_end_lock_wait</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |    |--&gt; os_event_set(thr-&gt;slot-&gt;event)</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; lock_update_wait_for_edge </span><br><span class=\"line\">|    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; lock_grant_cats</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; lock_table_dequeue</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>InnoDB 事务锁系统简介：<a href=\"http://mysql.taobao.org/monthly/2016/01/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2016/01/01/</a></p>\n<p>InnoDB 锁子系统浅析：<a href=\"http://mysql.taobao.org/monthly/2017/12/02/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2017/12/02/</a></p>\n<p>InnoDB 行锁分析：<a href=\"http://mysql.taobao.org/monthly/2018/05/04/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2018/05/04/</a></p>\n<p><a href=\"https://time.geekbang.org/column/article/75659\" target=\"_blank\" rel=\"noopener\">https://time.geekbang.org/column/article/75659</a></p>\n</blockquote>"},{"title":"InnoDB 物理文件介绍","date":"2020-12-05T12:41:27.000Z","_content":"\n关于 InnoDB 介绍的文章很多，但是对于 InnoDB 物理文件介绍的文章却很少，本文尝试对 InnoDB 的物理文件结构进行一个简单的说明。\n\n<!-- more -->\n\n## 几个重要概念\n\n### Space\n\n或者叫 table space，表空间，InnoDB 内的表空间有以下几类：系统表空间（ibdata）、临时表空间（ibtmp）、undo表空间（undo001）、用户表空间（ibd）。一个表空间对应一个物理文件，在 InnoDB 最新版本中，默认一个表空间对应一张表。\n\n<img src=\"/images/space-page-1.png\" width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n### Page\n\n页，InnoDB 内文件组织的基本单位，InnoDB 默认单个 Page 的大小是 16KB。单个 Space 由多个 Page 组成，Space 的大小一定是 16KB 的整数倍。Page 的类型比较复杂，包括：FSP_HDR Page、XDES Page、INODE Page、INDEX Page 等。不同类型的 Page 头部和尾部大小是固定的，分别是 38 和 8 字节。\n\n<img src=\"/images/space-page-2.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-3.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n### FSP_HDR Page\n\nSpace 内的第 1 个 Page，也可以叫做 Page 0。前面提到，Page 是文件组织的基本单位，每 64 个 Page 会组成 1 个 Extent，1 个 Extent 的大小为 1MB；每 256 个 Extent 会有一个单独的 FSP_HDR/XDES 进行管理。\n\n<img src=\"/images/space-page-4.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-5.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n注：FREE、FREE_FRAG、FULL_FRAG 列表中的元素为 XDES Entry；FULL_INODES、FREE_INODES 列表中的元素为 INODO Page。\n\n### XDES Page\n\n前面已经提到，每 256 个 Extent 会有一个单独的 FSP_HDR/XDES 进行管理，与 FSP_HDR Page 的区别在于，XDES Page 的 FSP Header 部分为空，其它部分相同。每一个 Extent 由 1 个单独的 XDES Entry 进行管理\n\n<img src=\"/images/space-page-6.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n### INODE Page\n\nINODE 这个命名是 InnoDB 里面比较容易让人混淆的概念之一，参考文献中给出了一个说法 file segment INODE，INODE Page 中包含了 85 个 INODE Entry，每个 INODE Entry 描述一个 file segment(FSEG)。\n\n<img src=\"/images/space-page-7.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-8.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n注：FREE、FULL 列表中的元素为 XDES Entry。\n\n### INDEX Page\n\nInnoDB 采用了 b+ 树进行数据的管理，数据本身也存在主键中，所以在 Space 内部，所有真实的用户数据都是保存在 INDEX Page 中。\n\n<img src=\"/images/space-page-9.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-10.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-11.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-12.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\nSystem Record 的格式如下：\n\n<img src=\"/images/space-page-13.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\nUser Record 的格式如下：\n\n<img src=\"/images/space-page-14.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-15.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-16.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-17.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-18.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n## 总体图\n\n<img src=\"/images/space-page-19.png\"  width=\"780px\" align=\"left\"/>\n\n<img src=\"/images/space-page-20.png\"  width=\"780px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n## 参考文献\n\n> https://blog.jcole.us/2013/01/03/the-basics-of-innodb-space-file-layout/\n>\n> https://blog.jcole.us/2013/01/04/page-management-in-innodb-space-files/\n>\n> https://blog.jcole.us/2013/01/07/the-physical-structure-of-innodb-index-pages/\n>\n> https://blog.jcole.us/2013/01/10/btree-index-structures-in-innodb/\n>\n> https://blog.jcole.us/2013/01/10/the-physical-structure-of-records-in-innodb/\n>\n> https://blog.jcole.us/2013/01/14/efficiently-traversing-innodb-btrees-with-the-page-directory/","source":"_posts/innodb/space-page.md","raw":"---\ntitle: InnoDB 物理文件介绍\ndate: 2020-12-05 20:41:27\ncategories: \n- InnoDB\n\n---\n\n关于 InnoDB 介绍的文章很多，但是对于 InnoDB 物理文件介绍的文章却很少，本文尝试对 InnoDB 的物理文件结构进行一个简单的说明。\n\n<!-- more -->\n\n## 几个重要概念\n\n### Space\n\n或者叫 table space，表空间，InnoDB 内的表空间有以下几类：系统表空间（ibdata）、临时表空间（ibtmp）、undo表空间（undo001）、用户表空间（ibd）。一个表空间对应一个物理文件，在 InnoDB 最新版本中，默认一个表空间对应一张表。\n\n<img src=\"/images/space-page-1.png\" width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n### Page\n\n页，InnoDB 内文件组织的基本单位，InnoDB 默认单个 Page 的大小是 16KB。单个 Space 由多个 Page 组成，Space 的大小一定是 16KB 的整数倍。Page 的类型比较复杂，包括：FSP_HDR Page、XDES Page、INODE Page、INDEX Page 等。不同类型的 Page 头部和尾部大小是固定的，分别是 38 和 8 字节。\n\n<img src=\"/images/space-page-2.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-3.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n### FSP_HDR Page\n\nSpace 内的第 1 个 Page，也可以叫做 Page 0。前面提到，Page 是文件组织的基本单位，每 64 个 Page 会组成 1 个 Extent，1 个 Extent 的大小为 1MB；每 256 个 Extent 会有一个单独的 FSP_HDR/XDES 进行管理。\n\n<img src=\"/images/space-page-4.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-5.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n注：FREE、FREE_FRAG、FULL_FRAG 列表中的元素为 XDES Entry；FULL_INODES、FREE_INODES 列表中的元素为 INODO Page。\n\n### XDES Page\n\n前面已经提到，每 256 个 Extent 会有一个单独的 FSP_HDR/XDES 进行管理，与 FSP_HDR Page 的区别在于，XDES Page 的 FSP Header 部分为空，其它部分相同。每一个 Extent 由 1 个单独的 XDES Entry 进行管理\n\n<img src=\"/images/space-page-6.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n### INODE Page\n\nINODE 这个命名是 InnoDB 里面比较容易让人混淆的概念之一，参考文献中给出了一个说法 file segment INODE，INODE Page 中包含了 85 个 INODE Entry，每个 INODE Entry 描述一个 file segment(FSEG)。\n\n<img src=\"/images/space-page-7.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-8.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n注：FREE、FULL 列表中的元素为 XDES Entry。\n\n### INDEX Page\n\nInnoDB 采用了 b+ 树进行数据的管理，数据本身也存在主键中，所以在 Space 内部，所有真实的用户数据都是保存在 INDEX Page 中。\n\n<img src=\"/images/space-page-9.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-10.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-11.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-12.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\nSystem Record 的格式如下：\n\n<img src=\"/images/space-page-13.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\nUser Record 的格式如下：\n\n<img src=\"/images/space-page-14.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-15.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-16.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-17.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-18.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n## 总体图\n\n<img src=\"/images/space-page-19.png\"  width=\"780px\" align=\"left\"/>\n\n<img src=\"/images/space-page-20.png\"  width=\"780px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n## 参考文献\n\n> https://blog.jcole.us/2013/01/03/the-basics-of-innodb-space-file-layout/\n>\n> https://blog.jcole.us/2013/01/04/page-management-in-innodb-space-files/\n>\n> https://blog.jcole.us/2013/01/07/the-physical-structure-of-innodb-index-pages/\n>\n> https://blog.jcole.us/2013/01/10/btree-index-structures-in-innodb/\n>\n> https://blog.jcole.us/2013/01/10/the-physical-structure-of-records-in-innodb/\n>\n> https://blog.jcole.us/2013/01/14/efficiently-traversing-innodb-btrees-with-the-page-directory/","slug":"innodb/space-page","published":1,"updated":"2020-12-05T13:52:00.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4xg000pgugmh2032qdy","content":"<p>关于 InnoDB 介绍的文章很多，但是对于 InnoDB 物理文件介绍的文章却很少，本文尝试对 InnoDB 的物理文件结构进行一个简单的说明。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"几个重要概念\"><a href=\"#几个重要概念\" class=\"headerlink\" title=\"几个重要概念\"></a>几个重要概念</h2><h3 id=\"Space\"><a href=\"#Space\" class=\"headerlink\" title=\"Space\"></a>Space</h3><p>或者叫 table space，表空间，InnoDB 内的表空间有以下几类：系统表空间（ibdata）、临时表空间（ibtmp）、undo表空间（undo001）、用户表空间（ibd）。一个表空间对应一个物理文件，在 InnoDB 最新版本中，默认一个表空间对应一张表。</p>\n<img src=\"/images/space-page-1.png\" width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<h3 id=\"Page\"><a href=\"#Page\" class=\"headerlink\" title=\"Page\"></a>Page</h3><p>页，InnoDB 内文件组织的基本单位，InnoDB 默认单个 Page 的大小是 16KB。单个 Space 由多个 Page 组成，Space 的大小一定是 16KB 的整数倍。Page 的类型比较复杂，包括：FSP_HDR Page、XDES Page、INODE Page、INDEX Page 等。不同类型的 Page 头部和尾部大小是固定的，分别是 38 和 8 字节。</p>\n<img src=\"/images/space-page-2.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-3.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<h3 id=\"FSP-HDR-Page\"><a href=\"#FSP-HDR-Page\" class=\"headerlink\" title=\"FSP_HDR Page\"></a>FSP_HDR Page</h3><p>Space 内的第 1 个 Page，也可以叫做 Page 0。前面提到，Page 是文件组织的基本单位，每 64 个 Page 会组成 1 个 Extent，1 个 Extent 的大小为 1MB；每 256 个 Extent 会有一个单独的 FSP_HDR/XDES 进行管理。</p>\n<img src=\"/images/space-page-4.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-5.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>注：FREE、FREE_FRAG、FULL_FRAG 列表中的元素为 XDES Entry；FULL_INODES、FREE_INODES 列表中的元素为 INODO Page。</p>\n<h3 id=\"XDES-Page\"><a href=\"#XDES-Page\" class=\"headerlink\" title=\"XDES Page\"></a>XDES Page</h3><p>前面已经提到，每 256 个 Extent 会有一个单独的 FSP_HDR/XDES 进行管理，与 FSP_HDR Page 的区别在于，XDES Page 的 FSP Header 部分为空，其它部分相同。每一个 Extent 由 1 个单独的 XDES Entry 进行管理</p>\n<img src=\"/images/space-page-6.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<h3 id=\"INODE-Page\"><a href=\"#INODE-Page\" class=\"headerlink\" title=\"INODE Page\"></a>INODE Page</h3><p>INODE 这个命名是 InnoDB 里面比较容易让人混淆的概念之一，参考文献中给出了一个说法 file segment INODE，INODE Page 中包含了 85 个 INODE Entry，每个 INODE Entry 描述一个 file segment(FSEG)。</p>\n<img src=\"/images/space-page-7.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-8.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>注：FREE、FULL 列表中的元素为 XDES Entry。</p>\n<h3 id=\"INDEX-Page\"><a href=\"#INDEX-Page\" class=\"headerlink\" title=\"INDEX Page\"></a>INDEX Page</h3><p>InnoDB 采用了 b+ 树进行数据的管理，数据本身也存在主键中，所以在 Space 内部，所有真实的用户数据都是保存在 INDEX Page 中。</p>\n<img src=\"/images/space-page-9.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-10.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-11.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-12.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>System Record 的格式如下：</p>\n<img src=\"/images/space-page-13.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>User Record 的格式如下：</p>\n<img src=\"/images/space-page-14.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-15.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-16.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-17.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-18.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<h2 id=\"总体图\"><a href=\"#总体图\" class=\"headerlink\" title=\"总体图\"></a>总体图</h2><img src=\"/images/space-page-19.png\"  width=\"780px\" align=\"left\"/>\n\n<img src=\"/images/space-page-20.png\"  width=\"780px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p><a href=\"https://blog.jcole.us/2013/01/03/the-basics-of-innodb-space-file-layout/\" target=\"_blank\" rel=\"noopener\">https://blog.jcole.us/2013/01/03/the-basics-of-innodb-space-file-layout/</a></p>\n<p><a href=\"https://blog.jcole.us/2013/01/04/page-management-in-innodb-space-files/\" target=\"_blank\" rel=\"noopener\">https://blog.jcole.us/2013/01/04/page-management-in-innodb-space-files/</a></p>\n<p><a href=\"https://blog.jcole.us/2013/01/07/the-physical-structure-of-innodb-index-pages/\" target=\"_blank\" rel=\"noopener\">https://blog.jcole.us/2013/01/07/the-physical-structure-of-innodb-index-pages/</a></p>\n<p><a href=\"https://blog.jcole.us/2013/01/10/btree-index-structures-in-innodb/\" target=\"_blank\" rel=\"noopener\">https://blog.jcole.us/2013/01/10/btree-index-structures-in-innodb/</a></p>\n<p><a href=\"https://blog.jcole.us/2013/01/10/the-physical-structure-of-records-in-innodb/\" target=\"_blank\" rel=\"noopener\">https://blog.jcole.us/2013/01/10/the-physical-structure-of-records-in-innodb/</a></p>\n<p><a href=\"https://blog.jcole.us/2013/01/14/efficiently-traversing-innodb-btrees-with-the-page-directory/\" target=\"_blank\" rel=\"noopener\">https://blog.jcole.us/2013/01/14/efficiently-traversing-innodb-btrees-with-the-page-directory/</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>关于 InnoDB 介绍的文章很多，但是对于 InnoDB 物理文件介绍的文章却很少，本文尝试对 InnoDB 的物理文件结构进行一个简单的说明。</p>","more":"<h2 id=\"几个重要概念\"><a href=\"#几个重要概念\" class=\"headerlink\" title=\"几个重要概念\"></a>几个重要概念</h2><h3 id=\"Space\"><a href=\"#Space\" class=\"headerlink\" title=\"Space\"></a>Space</h3><p>或者叫 table space，表空间，InnoDB 内的表空间有以下几类：系统表空间（ibdata）、临时表空间（ibtmp）、undo表空间（undo001）、用户表空间（ibd）。一个表空间对应一个物理文件，在 InnoDB 最新版本中，默认一个表空间对应一张表。</p>\n<img src=\"/images/space-page-1.png\" width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<h3 id=\"Page\"><a href=\"#Page\" class=\"headerlink\" title=\"Page\"></a>Page</h3><p>页，InnoDB 内文件组织的基本单位，InnoDB 默认单个 Page 的大小是 16KB。单个 Space 由多个 Page 组成，Space 的大小一定是 16KB 的整数倍。Page 的类型比较复杂，包括：FSP_HDR Page、XDES Page、INODE Page、INDEX Page 等。不同类型的 Page 头部和尾部大小是固定的，分别是 38 和 8 字节。</p>\n<img src=\"/images/space-page-2.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-3.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<h3 id=\"FSP-HDR-Page\"><a href=\"#FSP-HDR-Page\" class=\"headerlink\" title=\"FSP_HDR Page\"></a>FSP_HDR Page</h3><p>Space 内的第 1 个 Page，也可以叫做 Page 0。前面提到，Page 是文件组织的基本单位，每 64 个 Page 会组成 1 个 Extent，1 个 Extent 的大小为 1MB；每 256 个 Extent 会有一个单独的 FSP_HDR/XDES 进行管理。</p>\n<img src=\"/images/space-page-4.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-5.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>注：FREE、FREE_FRAG、FULL_FRAG 列表中的元素为 XDES Entry；FULL_INODES、FREE_INODES 列表中的元素为 INODO Page。</p>\n<h3 id=\"XDES-Page\"><a href=\"#XDES-Page\" class=\"headerlink\" title=\"XDES Page\"></a>XDES Page</h3><p>前面已经提到，每 256 个 Extent 会有一个单独的 FSP_HDR/XDES 进行管理，与 FSP_HDR Page 的区别在于，XDES Page 的 FSP Header 部分为空，其它部分相同。每一个 Extent 由 1 个单独的 XDES Entry 进行管理</p>\n<img src=\"/images/space-page-6.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<h3 id=\"INODE-Page\"><a href=\"#INODE-Page\" class=\"headerlink\" title=\"INODE Page\"></a>INODE Page</h3><p>INODE 这个命名是 InnoDB 里面比较容易让人混淆的概念之一，参考文献中给出了一个说法 file segment INODE，INODE Page 中包含了 85 个 INODE Entry，每个 INODE Entry 描述一个 file segment(FSEG)。</p>\n<img src=\"/images/space-page-7.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-8.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>注：FREE、FULL 列表中的元素为 XDES Entry。</p>\n<h3 id=\"INDEX-Page\"><a href=\"#INDEX-Page\" class=\"headerlink\" title=\"INDEX Page\"></a>INDEX Page</h3><p>InnoDB 采用了 b+ 树进行数据的管理，数据本身也存在主键中，所以在 Space 内部，所有真实的用户数据都是保存在 INDEX Page 中。</p>\n<img src=\"/images/space-page-9.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-10.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-11.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-12.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>System Record 的格式如下：</p>\n<img src=\"/images/space-page-13.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>User Record 的格式如下：</p>\n<img src=\"/images/space-page-14.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-15.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-16.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-17.png\"  width=\"520px\" align=\"left\"/>\n\n<img src=\"/images/space-page-18.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<h2 id=\"总体图\"><a href=\"#总体图\" class=\"headerlink\" title=\"总体图\"></a>总体图</h2><img src=\"/images/space-page-19.png\"  width=\"780px\" align=\"left\"/>\n\n<img src=\"/images/space-page-20.png\"  width=\"780px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p><a href=\"https://blog.jcole.us/2013/01/03/the-basics-of-innodb-space-file-layout/\" target=\"_blank\" rel=\"noopener\">https://blog.jcole.us/2013/01/03/the-basics-of-innodb-space-file-layout/</a></p>\n<p><a href=\"https://blog.jcole.us/2013/01/04/page-management-in-innodb-space-files/\" target=\"_blank\" rel=\"noopener\">https://blog.jcole.us/2013/01/04/page-management-in-innodb-space-files/</a></p>\n<p><a href=\"https://blog.jcole.us/2013/01/07/the-physical-structure-of-innodb-index-pages/\" target=\"_blank\" rel=\"noopener\">https://blog.jcole.us/2013/01/07/the-physical-structure-of-innodb-index-pages/</a></p>\n<p><a href=\"https://blog.jcole.us/2013/01/10/btree-index-structures-in-innodb/\" target=\"_blank\" rel=\"noopener\">https://blog.jcole.us/2013/01/10/btree-index-structures-in-innodb/</a></p>\n<p><a href=\"https://blog.jcole.us/2013/01/10/the-physical-structure-of-records-in-innodb/\" target=\"_blank\" rel=\"noopener\">https://blog.jcole.us/2013/01/10/the-physical-structure-of-records-in-innodb/</a></p>\n<p><a href=\"https://blog.jcole.us/2013/01/14/efficiently-traversing-innodb-btrees-with-the-page-directory/\" target=\"_blank\" rel=\"noopener\">https://blog.jcole.us/2013/01/14/efficiently-traversing-innodb-btrees-with-the-page-directory/</a></p>\n</blockquote>"},{"title":"cgroups 使用简介","date":"2020-07-18T13:03:55.000Z","_content":"\ncgroups 是 Linux 内核提供的一种可以限制、记录、隔离进程组所使用的物理资源的机制，本文简单介绍下 cgroups 的使用情况。\n\n<!-- more -->\n\n## cgroups 原理\n\ncgroups 的实现本质上是给系统进程挂上钩子（hooks），在 task 运行的过程中涉及到某个资源时就会触发钩子上所附带的 subsystem 进行检测，最终根据资源类别的不同使用对应的技术进行资源限制和优先级分配。cgroups 的目的是将任意进程进行分组化管理。\n\n> https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/index\n\n### 基本概念\n\ncgroups 主要由 task，cgroup，subsystem 以及 hierarchy 组成\n\n- task（任务）：在 cgroups 中，任务就是系统的一个进程；\n- cgroup （控制族群）：控制族群是一组按照某种标准划分的进程，cgroups 中的资源控制都是以控制族群为单位实现的。一个进程可以加入某个控制族群，也可以迁移至另一个控制族群；\n- hierarchy（层级）：控制族群可以组织成层级的形式，即一颗控制族群树,其上的子节点继承父节点的特定属性（cgroup 结构树）；\n- subsystem（子系统）：通常是一个资源控制器，例如 CPU 子系统可以控制 CPU 时间分配，一个子系统必须附加到控制族群树上才能起作用，该树上的所有控制族群都受到该子系统的控制；\n\n### 子系统\n\nsubsystem 实际上就是 cgroups 的资源控制系统，每种 subsystem 独立地控制一种资源，常见的子系统如下：\n\n- cpu：使用调度程序控制 task 对 CPU 的使用；\n- cpuset：可以为 cgroup 中的 task 分配独立的 CPU（此处针对多处理器系统）和内存；\n- memory：可以设定 cgroup 中 task 对内存使用量的限定；\n- blkio：可以为块设备设定输入/输出限制，比如物理驱动设备（包括磁盘、固态硬盘、USB等）；\n\n## cgroup 使用\n\n```shell\n# 关键信息\n1. cat /proc/cgroups 查看当前 cgroup 运行情况\n2. mount | grep cgroup 查看 cgroup 挂载情况\n3. cgroup 内的节点保持继承关系，子目录自动继承父目录的规则\n4. 删除 cgroup 下的目录时，不能直接 rm -rf ，需要使用 rmdir\n5. 通过规则目录下的 cgroup.procs 与进程进行绑定，限定进程的资源\n```\n\n### CPU 隔离\n\nCPU 隔离有两种模式：共享模式和独享模式，其中共享模式：\n\n1. 通过 cpu 子系统进行限制，/cgroup/cpu/xxx\n2. 主要由以下文件进行配置：\n\n```\n-rw-r--r-- 1 root root 0 Sep 23 14:54 cpu.cfs_period_us\n-rw-r--r-- 1 root root 0 Sep 23 14:54 cpu.cfs_quota_us\n```\n\n独享模式：\n\n1. 通过 cpuset 子系统进行限制，/cgroup/cpuset/xxx\n2. 主要由以下文件进行配置：\n\n```\n-rw-r--r-- 1 root root 0 Sep 23 14:45 cpuset.cpus\n```\n\n注：\n\n1. cfs_period_us 用来配置时间周期长度，cfs_quota_us 用来配置当前 cgroup 在设置的周期长度内所能使用的 CPU 时间数。cfs_quota_us/cfs_period_us 可以当做是对应的核数限制；\n2. cpuset.cpus 需要设置成全部核，cpuset.mems 需要设置为 0；\n3. 通过 cgroup.procs 与进程进行绑定；\n4. cpuset.cpus 里直接绑定 cpu 核，cpu 核的信息可以通过 /proc/cpuinfo 进行查看；\n\n### Memory 隔离\n\nMemory 的隔离：\n\n1. 通过 memory 子系统进行限制，/cgroup/memory/xxx\n2. 主要由以下文件进行配置：\n\n```\n-rw-r--r-- 1 root root 0 Sep 23 14:54 memory.limit_in_bytes\n```\n\n注：memory.oom_control文件用来配置当内存超出限制后的是否需要kill申请内存的进程。\n\n### IOPS 限制\n\nIOPS 的隔离：\n\n1. 通过 blkio 子系统进行限制，/cgroup/blkio/xxx\n2. 主要由以下文件进行配置：\n\n```\n-rw-r--r-- 1 root root 0 Nov 19 16:41 blkio.throttle.read_iops_device\n-rw-r--r-- 1 root root 0 Nov 19 16:41 blkio.throttle.write_iops_device\n```\n\n注：与内存限制不同的是，IOPS 的限制其实是对于块设备的 IO 限制，所以配置文件中会指明对应的设备 ID。\n\n### 参考文献\n\n> https://staight.github.io/2019/03/07/linux资源管理器-cgroups理解\n>\n> https://segmentfault.com/a/1190000006917884\n>\n> https://segmentfault.com/a/1190000007241437\n>\n> https://segmentfault.com/a/1190000008125359\n>\n> https://segmentfault.com/a/1190000008323952","source":"_posts/linux/cgroup-linux.md","raw":"---\ntitle: cgroups 使用简介\ndate: 2020-07-18 21:03:55\ncategories: \n- Linux\n\n---\n\ncgroups 是 Linux 内核提供的一种可以限制、记录、隔离进程组所使用的物理资源的机制，本文简单介绍下 cgroups 的使用情况。\n\n<!-- more -->\n\n## cgroups 原理\n\ncgroups 的实现本质上是给系统进程挂上钩子（hooks），在 task 运行的过程中涉及到某个资源时就会触发钩子上所附带的 subsystem 进行检测，最终根据资源类别的不同使用对应的技术进行资源限制和优先级分配。cgroups 的目的是将任意进程进行分组化管理。\n\n> https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/index\n\n### 基本概念\n\ncgroups 主要由 task，cgroup，subsystem 以及 hierarchy 组成\n\n- task（任务）：在 cgroups 中，任务就是系统的一个进程；\n- cgroup （控制族群）：控制族群是一组按照某种标准划分的进程，cgroups 中的资源控制都是以控制族群为单位实现的。一个进程可以加入某个控制族群，也可以迁移至另一个控制族群；\n- hierarchy（层级）：控制族群可以组织成层级的形式，即一颗控制族群树,其上的子节点继承父节点的特定属性（cgroup 结构树）；\n- subsystem（子系统）：通常是一个资源控制器，例如 CPU 子系统可以控制 CPU 时间分配，一个子系统必须附加到控制族群树上才能起作用，该树上的所有控制族群都受到该子系统的控制；\n\n### 子系统\n\nsubsystem 实际上就是 cgroups 的资源控制系统，每种 subsystem 独立地控制一种资源，常见的子系统如下：\n\n- cpu：使用调度程序控制 task 对 CPU 的使用；\n- cpuset：可以为 cgroup 中的 task 分配独立的 CPU（此处针对多处理器系统）和内存；\n- memory：可以设定 cgroup 中 task 对内存使用量的限定；\n- blkio：可以为块设备设定输入/输出限制，比如物理驱动设备（包括磁盘、固态硬盘、USB等）；\n\n## cgroup 使用\n\n```shell\n# 关键信息\n1. cat /proc/cgroups 查看当前 cgroup 运行情况\n2. mount | grep cgroup 查看 cgroup 挂载情况\n3. cgroup 内的节点保持继承关系，子目录自动继承父目录的规则\n4. 删除 cgroup 下的目录时，不能直接 rm -rf ，需要使用 rmdir\n5. 通过规则目录下的 cgroup.procs 与进程进行绑定，限定进程的资源\n```\n\n### CPU 隔离\n\nCPU 隔离有两种模式：共享模式和独享模式，其中共享模式：\n\n1. 通过 cpu 子系统进行限制，/cgroup/cpu/xxx\n2. 主要由以下文件进行配置：\n\n```\n-rw-r--r-- 1 root root 0 Sep 23 14:54 cpu.cfs_period_us\n-rw-r--r-- 1 root root 0 Sep 23 14:54 cpu.cfs_quota_us\n```\n\n独享模式：\n\n1. 通过 cpuset 子系统进行限制，/cgroup/cpuset/xxx\n2. 主要由以下文件进行配置：\n\n```\n-rw-r--r-- 1 root root 0 Sep 23 14:45 cpuset.cpus\n```\n\n注：\n\n1. cfs_period_us 用来配置时间周期长度，cfs_quota_us 用来配置当前 cgroup 在设置的周期长度内所能使用的 CPU 时间数。cfs_quota_us/cfs_period_us 可以当做是对应的核数限制；\n2. cpuset.cpus 需要设置成全部核，cpuset.mems 需要设置为 0；\n3. 通过 cgroup.procs 与进程进行绑定；\n4. cpuset.cpus 里直接绑定 cpu 核，cpu 核的信息可以通过 /proc/cpuinfo 进行查看；\n\n### Memory 隔离\n\nMemory 的隔离：\n\n1. 通过 memory 子系统进行限制，/cgroup/memory/xxx\n2. 主要由以下文件进行配置：\n\n```\n-rw-r--r-- 1 root root 0 Sep 23 14:54 memory.limit_in_bytes\n```\n\n注：memory.oom_control文件用来配置当内存超出限制后的是否需要kill申请内存的进程。\n\n### IOPS 限制\n\nIOPS 的隔离：\n\n1. 通过 blkio 子系统进行限制，/cgroup/blkio/xxx\n2. 主要由以下文件进行配置：\n\n```\n-rw-r--r-- 1 root root 0 Nov 19 16:41 blkio.throttle.read_iops_device\n-rw-r--r-- 1 root root 0 Nov 19 16:41 blkio.throttle.write_iops_device\n```\n\n注：与内存限制不同的是，IOPS 的限制其实是对于块设备的 IO 限制，所以配置文件中会指明对应的设备 ID。\n\n### 参考文献\n\n> https://staight.github.io/2019/03/07/linux资源管理器-cgroups理解\n>\n> https://segmentfault.com/a/1190000006917884\n>\n> https://segmentfault.com/a/1190000007241437\n>\n> https://segmentfault.com/a/1190000008125359\n>\n> https://segmentfault.com/a/1190000008323952","slug":"linux/cgroup-linux","published":1,"updated":"2020-12-05T12:02:58.666Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4xh000rgugm0fn93b1e","content":"<p>cgroups 是 Linux 内核提供的一种可以限制、记录、隔离进程组所使用的物理资源的机制，本文简单介绍下 cgroups 的使用情况。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"cgroups-原理\"><a href=\"#cgroups-原理\" class=\"headerlink\" title=\"cgroups 原理\"></a>cgroups 原理</h2><p>cgroups 的实现本质上是给系统进程挂上钩子（hooks），在 task 运行的过程中涉及到某个资源时就会触发钩子上所附带的 subsystem 进行检测，最终根据资源类别的不同使用对应的技术进行资源限制和优先级分配。cgroups 的目的是将任意进程进行分组化管理。</p>\n<blockquote>\n<p><a href=\"https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/index\" target=\"_blank\" rel=\"noopener\">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/index</a></p>\n</blockquote>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>cgroups 主要由 task，cgroup，subsystem 以及 hierarchy 组成</p>\n<ul>\n<li>task（任务）：在 cgroups 中，任务就是系统的一个进程；</li>\n<li>cgroup （控制族群）：控制族群是一组按照某种标准划分的进程，cgroups 中的资源控制都是以控制族群为单位实现的。一个进程可以加入某个控制族群，也可以迁移至另一个控制族群；</li>\n<li>hierarchy（层级）：控制族群可以组织成层级的形式，即一颗控制族群树,其上的子节点继承父节点的特定属性（cgroup 结构树）；</li>\n<li>subsystem（子系统）：通常是一个资源控制器，例如 CPU 子系统可以控制 CPU 时间分配，一个子系统必须附加到控制族群树上才能起作用，该树上的所有控制族群都受到该子系统的控制；</li>\n</ul>\n<h3 id=\"子系统\"><a href=\"#子系统\" class=\"headerlink\" title=\"子系统\"></a>子系统</h3><p>subsystem 实际上就是 cgroups 的资源控制系统，每种 subsystem 独立地控制一种资源，常见的子系统如下：</p>\n<ul>\n<li>cpu：使用调度程序控制 task 对 CPU 的使用；</li>\n<li>cpuset：可以为 cgroup 中的 task 分配独立的 CPU（此处针对多处理器系统）和内存；</li>\n<li>memory：可以设定 cgroup 中 task 对内存使用量的限定；</li>\n<li>blkio：可以为块设备设定输入/输出限制，比如物理驱动设备（包括磁盘、固态硬盘、USB等）；</li>\n</ul>\n<h2 id=\"cgroup-使用\"><a href=\"#cgroup-使用\" class=\"headerlink\" title=\"cgroup 使用\"></a>cgroup 使用</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 关键信息</span></span><br><span class=\"line\">1. cat /proc/cgroups 查看当前 cgroup 运行情况</span><br><span class=\"line\">2. mount | grep cgroup 查看 cgroup 挂载情况</span><br><span class=\"line\">3. cgroup 内的节点保持继承关系，子目录自动继承父目录的规则</span><br><span class=\"line\">4. 删除 cgroup 下的目录时，不能直接 rm -rf ，需要使用 rmdir</span><br><span class=\"line\">5. 通过规则目录下的 cgroup.procs 与进程进行绑定，限定进程的资源</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CPU-隔离\"><a href=\"#CPU-隔离\" class=\"headerlink\" title=\"CPU 隔离\"></a>CPU 隔离</h3><p>CPU 隔离有两种模式：共享模式和独享模式，其中共享模式：</p>\n<ol>\n<li>通过 cpu 子系统进行限制，/cgroup/cpu/xxx</li>\n<li>主要由以下文件进行配置：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 root root 0 Sep 23 14:54 cpu.cfs_period_us</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 Sep 23 14:54 cpu.cfs_quota_us</span><br></pre></td></tr></table></figure>\n\n<p>独享模式：</p>\n<ol>\n<li>通过 cpuset 子系统进行限制，/cgroup/cpuset/xxx</li>\n<li>主要由以下文件进行配置：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 root root 0 Sep 23 14:45 cpuset.cpus</span><br></pre></td></tr></table></figure>\n\n<p>注：</p>\n<ol>\n<li>cfs_period_us 用来配置时间周期长度，cfs_quota_us 用来配置当前 cgroup 在设置的周期长度内所能使用的 CPU 时间数。cfs_quota_us/cfs_period_us 可以当做是对应的核数限制；</li>\n<li>cpuset.cpus 需要设置成全部核，cpuset.mems 需要设置为 0；</li>\n<li>通过 cgroup.procs 与进程进行绑定；</li>\n<li>cpuset.cpus 里直接绑定 cpu 核，cpu 核的信息可以通过 /proc/cpuinfo 进行查看；</li>\n</ol>\n<h3 id=\"Memory-隔离\"><a href=\"#Memory-隔离\" class=\"headerlink\" title=\"Memory 隔离\"></a>Memory 隔离</h3><p>Memory 的隔离：</p>\n<ol>\n<li>通过 memory 子系统进行限制，/cgroup/memory/xxx</li>\n<li>主要由以下文件进行配置：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 root root 0 Sep 23 14:54 memory.limit_in_bytes</span><br></pre></td></tr></table></figure>\n\n<p>注：memory.oom_control文件用来配置当内存超出限制后的是否需要kill申请内存的进程。</p>\n<h3 id=\"IOPS-限制\"><a href=\"#IOPS-限制\" class=\"headerlink\" title=\"IOPS 限制\"></a>IOPS 限制</h3><p>IOPS 的隔离：</p>\n<ol>\n<li>通过 blkio 子系统进行限制，/cgroup/blkio/xxx</li>\n<li>主要由以下文件进行配置：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 root root 0 Nov 19 16:41 blkio.throttle.read_iops_device</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 Nov 19 16:41 blkio.throttle.write_iops_device</span><br></pre></td></tr></table></figure>\n\n<p>注：与内存限制不同的是，IOPS 的限制其实是对于块设备的 IO 限制，所以配置文件中会指明对应的设备 ID。</p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><blockquote>\n<p><a href=\"https://staight.github.io/2019/03/07/linux资源管理器-cgroups理解\" target=\"_blank\" rel=\"noopener\">https://staight.github.io/2019/03/07/linux资源管理器-cgroups理解</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000006917884\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000006917884</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000007241437\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000007241437</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000008125359\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000008125359</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000008323952\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000008323952</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>cgroups 是 Linux 内核提供的一种可以限制、记录、隔离进程组所使用的物理资源的机制，本文简单介绍下 cgroups 的使用情况。</p>","more":"<h2 id=\"cgroups-原理\"><a href=\"#cgroups-原理\" class=\"headerlink\" title=\"cgroups 原理\"></a>cgroups 原理</h2><p>cgroups 的实现本质上是给系统进程挂上钩子（hooks），在 task 运行的过程中涉及到某个资源时就会触发钩子上所附带的 subsystem 进行检测，最终根据资源类别的不同使用对应的技术进行资源限制和优先级分配。cgroups 的目的是将任意进程进行分组化管理。</p>\n<blockquote>\n<p><a href=\"https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/index\" target=\"_blank\" rel=\"noopener\">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/index</a></p>\n</blockquote>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>cgroups 主要由 task，cgroup，subsystem 以及 hierarchy 组成</p>\n<ul>\n<li>task（任务）：在 cgroups 中，任务就是系统的一个进程；</li>\n<li>cgroup （控制族群）：控制族群是一组按照某种标准划分的进程，cgroups 中的资源控制都是以控制族群为单位实现的。一个进程可以加入某个控制族群，也可以迁移至另一个控制族群；</li>\n<li>hierarchy（层级）：控制族群可以组织成层级的形式，即一颗控制族群树,其上的子节点继承父节点的特定属性（cgroup 结构树）；</li>\n<li>subsystem（子系统）：通常是一个资源控制器，例如 CPU 子系统可以控制 CPU 时间分配，一个子系统必须附加到控制族群树上才能起作用，该树上的所有控制族群都受到该子系统的控制；</li>\n</ul>\n<h3 id=\"子系统\"><a href=\"#子系统\" class=\"headerlink\" title=\"子系统\"></a>子系统</h3><p>subsystem 实际上就是 cgroups 的资源控制系统，每种 subsystem 独立地控制一种资源，常见的子系统如下：</p>\n<ul>\n<li>cpu：使用调度程序控制 task 对 CPU 的使用；</li>\n<li>cpuset：可以为 cgroup 中的 task 分配独立的 CPU（此处针对多处理器系统）和内存；</li>\n<li>memory：可以设定 cgroup 中 task 对内存使用量的限定；</li>\n<li>blkio：可以为块设备设定输入/输出限制，比如物理驱动设备（包括磁盘、固态硬盘、USB等）；</li>\n</ul>\n<h2 id=\"cgroup-使用\"><a href=\"#cgroup-使用\" class=\"headerlink\" title=\"cgroup 使用\"></a>cgroup 使用</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 关键信息</span></span><br><span class=\"line\">1. cat /proc/cgroups 查看当前 cgroup 运行情况</span><br><span class=\"line\">2. mount | grep cgroup 查看 cgroup 挂载情况</span><br><span class=\"line\">3. cgroup 内的节点保持继承关系，子目录自动继承父目录的规则</span><br><span class=\"line\">4. 删除 cgroup 下的目录时，不能直接 rm -rf ，需要使用 rmdir</span><br><span class=\"line\">5. 通过规则目录下的 cgroup.procs 与进程进行绑定，限定进程的资源</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CPU-隔离\"><a href=\"#CPU-隔离\" class=\"headerlink\" title=\"CPU 隔离\"></a>CPU 隔离</h3><p>CPU 隔离有两种模式：共享模式和独享模式，其中共享模式：</p>\n<ol>\n<li>通过 cpu 子系统进行限制，/cgroup/cpu/xxx</li>\n<li>主要由以下文件进行配置：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 root root 0 Sep 23 14:54 cpu.cfs_period_us</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 Sep 23 14:54 cpu.cfs_quota_us</span><br></pre></td></tr></table></figure>\n\n<p>独享模式：</p>\n<ol>\n<li>通过 cpuset 子系统进行限制，/cgroup/cpuset/xxx</li>\n<li>主要由以下文件进行配置：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 root root 0 Sep 23 14:45 cpuset.cpus</span><br></pre></td></tr></table></figure>\n\n<p>注：</p>\n<ol>\n<li>cfs_period_us 用来配置时间周期长度，cfs_quota_us 用来配置当前 cgroup 在设置的周期长度内所能使用的 CPU 时间数。cfs_quota_us/cfs_period_us 可以当做是对应的核数限制；</li>\n<li>cpuset.cpus 需要设置成全部核，cpuset.mems 需要设置为 0；</li>\n<li>通过 cgroup.procs 与进程进行绑定；</li>\n<li>cpuset.cpus 里直接绑定 cpu 核，cpu 核的信息可以通过 /proc/cpuinfo 进行查看；</li>\n</ol>\n<h3 id=\"Memory-隔离\"><a href=\"#Memory-隔离\" class=\"headerlink\" title=\"Memory 隔离\"></a>Memory 隔离</h3><p>Memory 的隔离：</p>\n<ol>\n<li>通过 memory 子系统进行限制，/cgroup/memory/xxx</li>\n<li>主要由以下文件进行配置：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 root root 0 Sep 23 14:54 memory.limit_in_bytes</span><br></pre></td></tr></table></figure>\n\n<p>注：memory.oom_control文件用来配置当内存超出限制后的是否需要kill申请内存的进程。</p>\n<h3 id=\"IOPS-限制\"><a href=\"#IOPS-限制\" class=\"headerlink\" title=\"IOPS 限制\"></a>IOPS 限制</h3><p>IOPS 的隔离：</p>\n<ol>\n<li>通过 blkio 子系统进行限制，/cgroup/blkio/xxx</li>\n<li>主要由以下文件进行配置：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 root root 0 Nov 19 16:41 blkio.throttle.read_iops_device</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 Nov 19 16:41 blkio.throttle.write_iops_device</span><br></pre></td></tr></table></figure>\n\n<p>注：与内存限制不同的是，IOPS 的限制其实是对于块设备的 IO 限制，所以配置文件中会指明对应的设备 ID。</p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><blockquote>\n<p><a href=\"https://staight.github.io/2019/03/07/linux资源管理器-cgroups理解\" target=\"_blank\" rel=\"noopener\">https://staight.github.io/2019/03/07/linux资源管理器-cgroups理解</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000006917884\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000006917884</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000007241437\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000007241437</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000008125359\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000008125359</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000008323952\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000008323952</a></p>\n</blockquote>"},{"title":"tcpdump 工具使用简介","date":"2020-07-18T12:38:37.000Z","_content":"\ntcpdump 工具是 Linux 平台下进行网络抓包的工具，tcpdump 抓包 + wireshark 分析也是分析网络问题的黄金搭档。本文对 tcpdump 的使用进行一个简单总结。\n\n<!-- more -->\n\n## tcpdump 工具介绍\n\ntcpdump 是一款强大的网络抓包工具，它使用 libpcap 库来抓取网络数据包，最初设计用于观察 TCP/IP 性能问题，但是后来逐步发展成为一个完整的网络分析工具。\n\n## 命令\n\n下面简单介绍下 tcpdump 工具常见的几种使用模式，更加丰富的使用说明，可以参考：\n\n> https://www.tcpdump.org/manpages/tcpdump.1.html\n>\n> https://github.com/mylxsw/growing-up/blob/master/doc/tcpdump简明教程.md\n\n### 简易命令\n\n```shell\ntcpdump -tttt -s0 -X -vv tcp port 8080 -w xxx.cap\n```\n\n### 使用选项\n\n- **-i any** 监听所有的网卡接口，用来查看是否有网络流量\n- **-i eth0** 只监听 eth0 网卡接口\n- **-D** 显示可用的接口列表\n- **-n** 不要解析主机名\n- **-nn** 不要解析主机名或者端口名\n- **-q** 显示更少的输出（更加 quiet）\n- **-t** 输出可读的时间戳\n- **-tttt** 输出最大程度可读的时间戳\n- **-X** 以 hex 和 ASCII 两种形式显示包的内容\n- **-XX** 与 **-X** 类似，增加以太网header的显示\n- **-v, -vv, -vvv** 显示更加多的包信息\n- **-c** 只读取 x 个包，然后停止\n- **-w file**  把捕获的包数据写入到文件中\n- **-C size**  使用 **-w** 写入文件时，限制文件的最大大小，超出时新开一个文件，单位 MB\n- **-s** 指定每一个包捕获的长度，单位是 byte，使用 -s0 可以捕获整个包的内容\n- **-S** 输出绝对的序列号\n- **-e** 获取以太网 header\n- **-E** 使用提供的秘钥解密 IPSEC 流量\n\n### 表达式\n\n可以使用表达式过滤指定类型的流量，有三种主要的表达式类型：\n\n- 类型（type）选项包含：host，net，port\n- 方向（dir）选项包含：src，dst\n- 协议（proto）选项包含：tcp，udp，icmp，ah 等","source":"_posts/linux/tcpdump-linux.md","raw":"---\ntitle: tcpdump 工具使用简介\ndate: 2020-07-18 20:38:37\ntags:\n- 网络\n- 工具\ncategories: \n- Linux\n\n---\n\ntcpdump 工具是 Linux 平台下进行网络抓包的工具，tcpdump 抓包 + wireshark 分析也是分析网络问题的黄金搭档。本文对 tcpdump 的使用进行一个简单总结。\n\n<!-- more -->\n\n## tcpdump 工具介绍\n\ntcpdump 是一款强大的网络抓包工具，它使用 libpcap 库来抓取网络数据包，最初设计用于观察 TCP/IP 性能问题，但是后来逐步发展成为一个完整的网络分析工具。\n\n## 命令\n\n下面简单介绍下 tcpdump 工具常见的几种使用模式，更加丰富的使用说明，可以参考：\n\n> https://www.tcpdump.org/manpages/tcpdump.1.html\n>\n> https://github.com/mylxsw/growing-up/blob/master/doc/tcpdump简明教程.md\n\n### 简易命令\n\n```shell\ntcpdump -tttt -s0 -X -vv tcp port 8080 -w xxx.cap\n```\n\n### 使用选项\n\n- **-i any** 监听所有的网卡接口，用来查看是否有网络流量\n- **-i eth0** 只监听 eth0 网卡接口\n- **-D** 显示可用的接口列表\n- **-n** 不要解析主机名\n- **-nn** 不要解析主机名或者端口名\n- **-q** 显示更少的输出（更加 quiet）\n- **-t** 输出可读的时间戳\n- **-tttt** 输出最大程度可读的时间戳\n- **-X** 以 hex 和 ASCII 两种形式显示包的内容\n- **-XX** 与 **-X** 类似，增加以太网header的显示\n- **-v, -vv, -vvv** 显示更加多的包信息\n- **-c** 只读取 x 个包，然后停止\n- **-w file**  把捕获的包数据写入到文件中\n- **-C size**  使用 **-w** 写入文件时，限制文件的最大大小，超出时新开一个文件，单位 MB\n- **-s** 指定每一个包捕获的长度，单位是 byte，使用 -s0 可以捕获整个包的内容\n- **-S** 输出绝对的序列号\n- **-e** 获取以太网 header\n- **-E** 使用提供的秘钥解密 IPSEC 流量\n\n### 表达式\n\n可以使用表达式过滤指定类型的流量，有三种主要的表达式类型：\n\n- 类型（type）选项包含：host，net，port\n- 方向（dir）选项包含：src，dst\n- 协议（proto）选项包含：tcp，udp，icmp，ah 等","slug":"linux/tcpdump-linux","published":1,"updated":"2020-12-05T12:03:01.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4xi000vgugm91qr26xv","content":"<p>tcpdump 工具是 Linux 平台下进行网络抓包的工具，tcpdump 抓包 + wireshark 分析也是分析网络问题的黄金搭档。本文对 tcpdump 的使用进行一个简单总结。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"tcpdump-工具介绍\"><a href=\"#tcpdump-工具介绍\" class=\"headerlink\" title=\"tcpdump 工具介绍\"></a>tcpdump 工具介绍</h2><p>tcpdump 是一款强大的网络抓包工具，它使用 libpcap 库来抓取网络数据包，最初设计用于观察 TCP/IP 性能问题，但是后来逐步发展成为一个完整的网络分析工具。</p>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p>下面简单介绍下 tcpdump 工具常见的几种使用模式，更加丰富的使用说明，可以参考：</p>\n<blockquote>\n<p><a href=\"https://www.tcpdump.org/manpages/tcpdump.1.html\" target=\"_blank\" rel=\"noopener\">https://www.tcpdump.org/manpages/tcpdump.1.html</a></p>\n<p><a href=\"https://github.com/mylxsw/growing-up/blob/master/doc/tcpdump简明教程.md\" target=\"_blank\" rel=\"noopener\">https://github.com/mylxsw/growing-up/blob/master/doc/tcpdump简明教程.md</a></p>\n</blockquote>\n<h3 id=\"简易命令\"><a href=\"#简易命令\" class=\"headerlink\" title=\"简易命令\"></a>简易命令</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcpdump -tttt -s0 -X -vv tcp port 8080 -w xxx.cap</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用选项\"><a href=\"#使用选项\" class=\"headerlink\" title=\"使用选项\"></a>使用选项</h3><ul>\n<li><strong>-i any</strong> 监听所有的网卡接口，用来查看是否有网络流量</li>\n<li><strong>-i eth0</strong> 只监听 eth0 网卡接口</li>\n<li><strong>-D</strong> 显示可用的接口列表</li>\n<li><strong>-n</strong> 不要解析主机名</li>\n<li><strong>-nn</strong> 不要解析主机名或者端口名</li>\n<li><strong>-q</strong> 显示更少的输出（更加 quiet）</li>\n<li><strong>-t</strong> 输出可读的时间戳</li>\n<li><strong>-tttt</strong> 输出最大程度可读的时间戳</li>\n<li><strong>-X</strong> 以 hex 和 ASCII 两种形式显示包的内容</li>\n<li><strong>-XX</strong> 与 <strong>-X</strong> 类似，增加以太网header的显示</li>\n<li><strong>-v, -vv, -vvv</strong> 显示更加多的包信息</li>\n<li><strong>-c</strong> 只读取 x 个包，然后停止</li>\n<li><strong>-w file</strong>  把捕获的包数据写入到文件中</li>\n<li><strong>-C size</strong>  使用 <strong>-w</strong> 写入文件时，限制文件的最大大小，超出时新开一个文件，单位 MB</li>\n<li><strong>-s</strong> 指定每一个包捕获的长度，单位是 byte，使用 -s0 可以捕获整个包的内容</li>\n<li><strong>-S</strong> 输出绝对的序列号</li>\n<li><strong>-e</strong> 获取以太网 header</li>\n<li><strong>-E</strong> 使用提供的秘钥解密 IPSEC 流量</li>\n</ul>\n<h3 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h3><p>可以使用表达式过滤指定类型的流量，有三种主要的表达式类型：</p>\n<ul>\n<li>类型（type）选项包含：host，net，port</li>\n<li>方向（dir）选项包含：src，dst</li>\n<li>协议（proto）选项包含：tcp，udp，icmp，ah 等</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>tcpdump 工具是 Linux 平台下进行网络抓包的工具，tcpdump 抓包 + wireshark 分析也是分析网络问题的黄金搭档。本文对 tcpdump 的使用进行一个简单总结。</p>","more":"<h2 id=\"tcpdump-工具介绍\"><a href=\"#tcpdump-工具介绍\" class=\"headerlink\" title=\"tcpdump 工具介绍\"></a>tcpdump 工具介绍</h2><p>tcpdump 是一款强大的网络抓包工具，它使用 libpcap 库来抓取网络数据包，最初设计用于观察 TCP/IP 性能问题，但是后来逐步发展成为一个完整的网络分析工具。</p>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p>下面简单介绍下 tcpdump 工具常见的几种使用模式，更加丰富的使用说明，可以参考：</p>\n<blockquote>\n<p><a href=\"https://www.tcpdump.org/manpages/tcpdump.1.html\" target=\"_blank\" rel=\"noopener\">https://www.tcpdump.org/manpages/tcpdump.1.html</a></p>\n<p><a href=\"https://github.com/mylxsw/growing-up/blob/master/doc/tcpdump简明教程.md\" target=\"_blank\" rel=\"noopener\">https://github.com/mylxsw/growing-up/blob/master/doc/tcpdump简明教程.md</a></p>\n</blockquote>\n<h3 id=\"简易命令\"><a href=\"#简易命令\" class=\"headerlink\" title=\"简易命令\"></a>简易命令</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcpdump -tttt -s0 -X -vv tcp port 8080 -w xxx.cap</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用选项\"><a href=\"#使用选项\" class=\"headerlink\" title=\"使用选项\"></a>使用选项</h3><ul>\n<li><strong>-i any</strong> 监听所有的网卡接口，用来查看是否有网络流量</li>\n<li><strong>-i eth0</strong> 只监听 eth0 网卡接口</li>\n<li><strong>-D</strong> 显示可用的接口列表</li>\n<li><strong>-n</strong> 不要解析主机名</li>\n<li><strong>-nn</strong> 不要解析主机名或者端口名</li>\n<li><strong>-q</strong> 显示更少的输出（更加 quiet）</li>\n<li><strong>-t</strong> 输出可读的时间戳</li>\n<li><strong>-tttt</strong> 输出最大程度可读的时间戳</li>\n<li><strong>-X</strong> 以 hex 和 ASCII 两种形式显示包的内容</li>\n<li><strong>-XX</strong> 与 <strong>-X</strong> 类似，增加以太网header的显示</li>\n<li><strong>-v, -vv, -vvv</strong> 显示更加多的包信息</li>\n<li><strong>-c</strong> 只读取 x 个包，然后停止</li>\n<li><strong>-w file</strong>  把捕获的包数据写入到文件中</li>\n<li><strong>-C size</strong>  使用 <strong>-w</strong> 写入文件时，限制文件的最大大小，超出时新开一个文件，单位 MB</li>\n<li><strong>-s</strong> 指定每一个包捕获的长度，单位是 byte，使用 -s0 可以捕获整个包的内容</li>\n<li><strong>-S</strong> 输出绝对的序列号</li>\n<li><strong>-e</strong> 获取以太网 header</li>\n<li><strong>-E</strong> 使用提供的秘钥解密 IPSEC 流量</li>\n</ul>\n<h3 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h3><p>可以使用表达式过滤指定类型的流量，有三种主要的表达式类型：</p>\n<ul>\n<li>类型（type）选项包含：host，net，port</li>\n<li>方向（dir）选项包含：src，dst</li>\n<li>协议（proto）选项包含：tcp，udp，icmp，ah 等</li>\n</ul>"},{"title":"InnoDB 事务提交过程","date":"2020-12-05T13:29:37.000Z","_content":"\n前面已经介绍过 MySQL 在 Server 层的事务提交过程，本文主要对 InnoDB 层的事务提交过程进行介绍。\n\n<!-- more -->\n\n## Server 层两阶段提交过程\n\n```c++\n|--> trans_commit\n|    |--> ha_commit_trans\n|    |    |--> tc_log->prepare\n|    |    |    |--> ha_prepare_low\n|    |    |    |    |--> innobase_xa_prepare\n|    |    |    |    |    |--> trx_prepare_for_mysql\n|    |    |    |    |    |    |--> trx_prepare\n|    |    |    |    |    |    |    |--> trx_prepare_low\n|    |    |    |    |    |    |    |    |--> trx_undo_set_state_at_prepare\n|    |    |    |    |    |    |    |    |    |--> trx_undo_write_xid\n|    |    |\n|    |    |--> tc_log->commit\n|    |    |    |--> ha_commit_low\n|    |    |    |    |--> innobase_commit\n|    |    |    |    |    |--> innobase_commit_low\n|    |    |    |    |    |    |--> trx_commit_for_mysql\n|    |    |    |    |    |    |    |--> trx_undo_gtid_add_update_undo\n|    |    |    |    |    |    |    |--> trx_undo_gtid_flush_prepare\n|    |    |    |    |    |    |    |--> trx_commit\n|    |    |    |    |    |    |    |    |--> trx_commit_low\n|    |    |    |    |    |\n|    |    |    |    |    |--> trx_deregister_from_2pc\n|    |    |    |    |    |\n|    |    |    |    |    |--> trx_commit_complete_for_mysql\n|    |    |    |    |    |    |--> trx_flush_log_if_needed\n```\n\n## InnoDB 层提交过程\n\n结合代码分析一下事务提交的过程：\n\n```c++\n|--> trx_commit_low\n|    |--> trx_write_serialisation_history\n|    |    |--> trx_serialisation_number_get\n|    |    |    |--> trx_sys_get_new_trx_id  // trx_no\n|    |    |    |--> UT_LIST_ADD_LAST(trx_sys->serialisation_list)\n|    |    |    |--> purge_sys->purge_queue->push  // purge_sys 维护\n|    |    |\n|    |    |--> trx_undo_set_state_at_finish\n|    |    |--> trx_undo_update_clean\n|    |    |    |--> trx_purge_add_update_undo_to_history\n|    |    |    |    |--> flst_add_first(rseg_header + TRX_RSEG_HISTORY, undo_header + TRX_UNDO_HISTORY_NODE, mtr)\n|    |    |\n|    |    |--> trx_sys_update_mysql_binlog_offset\n|    |\n|    |--> trx_commit_in_memory\n|    |    |--> trx_release_impl_and_expl_locks\n|    |    |    |--> trx_erase_lists\n|    |    |    |    |--> UT_LIST_REMOVE(trx_sys->serialisation_list)\n|    |    |    |    |--> trx_sys->rw_trx_ids.erase\n|    |    |    |    |--> UT_LIST_REMOVE(trx_sys->rw_trx_list)\n|    |    |    |    |--> trx_sys->mvcc->view_close\n|    |    |    |    |--> trx_sys->rw_trx_set.erase\n|    |    |    |    |--> trx_sys->min_active_id.store\n|    |    |    |\n|    |    |    |--> lock_trx_release_locks\n|    |    |    |    |--> lock_release\n|    |    |    |    |    |--> lock_rec_dequeue_from_page\n|    |    |    |    |    |    |--> lock_rec_discard\n|    |    |    |    |    |    |--> lock_rec_grant // 遍历 page，查看是否有需要唤醒的锁等待\n|    |    |    |    |    |    |    |--> lock_grant_or_update_wait_for_edge_if_waiting\n|    |    |    |    |    |    |    |    |--> lock_grant_or_update_wait_for_edge\n|    |    |    |    |    |    |    |    |    |--> lock_has_to_wait_in_queue // 检查是否需要继续等待\n|    |    |    |    |    |    |    |    |    |--> lock_grant // 解锁，唤醒 trx->lock->wait_thr\n|    |    |    |    |    |    |    |    |    |    |--> lock_reset_wait_and_release_thread_if_suspended\n|    |    |    |    |    |    |    |    |    |    |    |--> lock_reset_lock_and_trx_wait\n|    |    |    |    |    |    |    |    |    |    |    |--> lock_wait_release_thread_if_suspended\n|    |    |    |    |    |    |    |    |    |    |    |     |--> que_thr_end_lock_wait\n|    |    |    |    |    |    |    |    |    |    |    |     |--> os_event_set(thr->slot->event)\n|    |    |    |    |    |    |    |    |    |--> lock_update_wait_for_edge \n|    |    |    |    |    |    |    |\n|    |    |    |    |    |    |    |--> lock_grant_cats\n|    |    |    |    |    |\n|    |    |    |    |    |--> lock_table_dequeue\n|    |    |\n|    |    |--> trx_sys->mvcc->view_close\n|    |    |--> trx_undo_insert_cleanup\n|    |    |--> srv_active_wake_master_thread\n```\n\n## 读写事务维护\n\n### 插入 rw_trx_xxx\n\n```c++\n|--> trx_set_rw_mode\n|    |--> trx_assign_rseg_durable\n|    |    |--> get_next_redo_rseg\n|    |    |    |--> get_next_redo_rseg_from_trx_sys  // 系统表空间\n|    |    |    |\n|    |    |    |--> get_next_redo_rseg_from_undo_spaces  // 独立 undo 表空间\n|    |\n|    |--> trx_sys_get_new_trx_id\n|    |--> trx_sys->rw_trx_ids.push_back\n|    |--> trx_sys->rw_trx_set.insert\n|    |--> UT_LIST_ADD_FIRST(trx_sys->rw_trx_list)\n```\n\nMySQL 在 trx_sys 中引入了好几个数据结构来维护读写事务集合，这些数据结构的修改都需要在 trx_sys->mutex 的保护下进行：\n\n- rw_trx_ids ：仅 trx_id 的集合\n- rw_trx_set ：仅 trx 的集合\n- rw_trx_list ：trx 的有序列表（事务开始时间有序）\n\n对于显示启动的事务，MySQL 默认只会开启一个只读事务，直到事务中有 DML 操作时才会升级为读写事务。通过上面的代码可以看到，不管是 undo 还是 trx_id 都是在升级为读写事务时才会分配。\n\n判断一个 trx_id 是否是活跃的读写事务：\n\n```c++\ntrx_t *trx_rw_is_active(trx_id_t trx_id, ibool *corrupt, bool do_ref_count) {\n  trx_t *trx;\n\n  if (trx_sys->min_active_id.load() > trx_id) {\n    return (NULL);\n  }\n\n  ...\n    \n  trx = trx_rw_is_active_low(trx_id, corrupt);\n\n  return (trx);\n}\n```\n\n### 移除 rw_trx_xxx\n\n在事务提交的时候，需要从读写事务对应的数据结构中进行移除：\n\n```c++\n|--> trx_commit_in_memory\n|    |--> trx_release_impl_and_expl_locks\n|    |    |--> trx_erase_lists\n|    |    |    |--> UT_LIST_REMOVE(trx_sys->serialisation_list)\n|    |    |    |--> trx_sys->rw_trx_ids.erase\n|    |    |    |--> UT_LIST_REMOVE(trx_sys->rw_trx_list)\n|    |    |    |--> trx_sys->mvcc->view_close\n|    |    |    |--> trx_sys->rw_trx_set.erase\n|    |    |    |--> trx_sys->min_active_id.store\n```\n\n## purge_sys 维护\n\n<img src=\"/images/innodb-trx-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n如图所示是一个简单的 purge_sys 相关的类图，purge_sys 是一个全局对象，所有 purge 相关的信息全部在其中维护。关于 purge_sys 主要包括了一下几项：\n\n### 插入 purge_sys\n\n对于一个读写事务，如果事务中包含了更新操作，则需要将更新操作先关的 undo 插入到 purge_sys（如果事务中只有插入操作，不需要维护 purge_sys，因为不需要利用 undo 构建历史版本）。purge_sys 利用一个优先队列 `purge_queue` 保存待 purge 的 undo，准确的说应该是回滚段，一个回滚段中包含了多个 undo，但是如果该回滚段之前已经加入过队列，则不需要继续添加。\n\npurge_sys 中维护了一个按照 trx_no 有序的优先队列 purge_queue，在事务提交的过程中（commit阶段）会将事务对应的回滚段添加到 purge_queue 中。前面已经说过，并不是每次事务提交的时候都会将回滚段添加到 purge_queue 中，只有当 redo_rseg->last_page_no 为空时（即回滚段上之前不存在未 puge 的 undo），才会添加到 purge_queue 中。若 redo_rseg->last_page_no 非空，则说明该回滚段上存在未 purg 的 undo，此时只会更新回滚段的 TRX_RSEG_HISTORY 列表，将新的 undo 添加到 TRX_RSEG_HISTORY 列表的头部。\n\n为了方便理解，结合回滚段的物理结构进行分析：\n\n<img src=\"/images/innodb-trx-2.png\" width=\"280px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n新产生的 undo 都需要被链接到 TRX_RSEG_HISTORY 上。\n\n注：回滚段中的 undo 通过一个有序列表进行组织，先生成的 undo 肯定会先被 purge。\n\n在前面的代码中可以看到，在事务提交的过程中，需要调用 `trx_serialisation_number_get` 将需要 purge 的 undo 插入到 purge_sys 的优先队列中。\n\n### purge 推进\n\nInnoDB 内部通过单独的后台线程周期性的进行 undo 的 purge，purge 推进的基本原则是：尽可能的将不再使用的 undo 内容 purge 掉。具体的实现上，基本步骤如下：\n\n```c++\n/* srv_start_purge_threads */\n\n|--> srv_purge_coordinator_thread\n|--> srv_worker_thread\n\n\n/* srv_purge_coordinator_thread::trx_purge */\n|--> trx_sys->mvcc->clone_oldest_view  // 确认当前最老的 read view\n|\n|--> trx_purge_attach_undo_recs // 收集指定数据的 undo pages\n|    |--> trx_purge_fetch_next_rec // loop\n|    |    |--> trx_purge_choose_next_log // !purge_sys->next_stored，寻找下一个 log\n|    |    |    |--> purge_sys->rseg_iter->set_next() // 更新 purge_sys->rseg 位置\n|    |    |    |--> trx_purge_read_undo_rec // 更新 purge_sys->iter 信息\n|    |    |    |    |--> trx_undo_get_first_rec // 总是从 resg->last_page_no 开始，next_stored 置为 true\n|    |    |\n|    |    |--> trx_undo_build_roll_ptr\n|    |    |--> trx_purge_get_next_rec // 寻找下一个 record\n|    |    |    |--> trx_undo_page_get_next_rec // 从当前 page 寻找下一个 record\n|    |    |    |--> trx_undo_get_next_rec\n|    |    |    |    |--> trx_undo_page_get_next_rec\n|    |    |    |    |--> trx_undo_get_next_rec_from_next_page // 从下一个 page 寻找，TRX_UNDO_PAGE_NODE\n|    |    |    |--> trx_purge_rseg_get_next_history_log // next_stored 置为 false，查找 TRX_UNDO_HISTORY_NODE, 找到下一个 hdr\n|\n|--> que_fork_scheduler_round_robin\n|--> srv_que_task_enqueue_low\n|--> que_run_threads\n|--> trx_purge_wait_for_workers_to_complete\n|\n|--> trx_purge_truncate // 清理 undo 文件\n|    |--> trx_purge_truncate_history // 遍历 rsegs\n|    |    |--> trx_purge_truncate_rseg_history // 遍历 TRX_RSEG_HISTORY\n\n\n/* srv_worker_thread::::row_purge_step */\n\n|--> row_purge\n|    |--> row_purge_parse_undo_rec\n|    |--> row_purge_record\n|    |    |--> row_purge_record_func\n|    |    |    |--> row_purge_del_mark\n|    |    |    |--> row_purge_upd_exist_or_extern\n```\n\nundo 的 purge 由后台线程完成，后台线程分为两类：coordinator 线程和 worker 线程。coordinator 线程负责收集和分发 undo log，worker 线程负责实际的 purge 工作（coordinator 线程本身也会参与 purge）。\n\ncoordinator 线程按照以下的逻辑收集 undo：\n\n1. 从 purge_queue 里面弹出一个元素 TrxUndoRsegs，m_trx_undo_rsegs 指向弹出的元素；\n2. 继续从 purge_queue 弹出元素，若弹出元素的 trx_no 和 m_trx_undo_rsegs 的 trx_no 相同，则直接进行合并，否则退出循环；\n3. m_iter 指向 m_trx_undo_rsegs，开始遍历，purg_sys->rseg 指向待处理的回滚段；\n4. 从待处理的回滚段中依次取 undo_record，若无法取到下一个 undo_record，则需要根据TRX_UNDO_HISTORY_NODE 取下一个 undo，并将 trx_rseg_t 重新 放入 purge_queue 中；\n5. m_iter 正常遍历，当遍历到 m_trx_undo_rsegs 尾部时，重复 1；\n\n由于这个逻辑实在有点绕，下面结合 undo page 的内部结构再分析一下：\n\n<img src=\"/images/innodb-trx-3.png\" width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n基本的逻辑如下：\n\n1. trx_rseg_t 上的 last_page_no、last_offset、last_trx_no 指向的是该回滚到对应的第一个未 purge 的 undo，也可以理解为 TRX_RSEG_HISTORY 最尾部（添加时都是添加到头部）的的一个 undo；\n2. 拿到这个 undo 后，先在当前页去获取 undo record，如果无法获取，那么就需要通过 TRX_UNDO_PAGE_NODE 找到下一个 page；\n3. 如果无法继续找到 undo record，那么说明当前 undo 已经结束了，那么需要根据 TRX_UNDO_HOSTORY_NODE 向前（添加时都是添加到头部）找到下一个 undo，这个时候找到的 undo 不能直接去获取 undo record，而是需要将 trx_rseg_t 指向该 page，然后重新放回优先队列；\n\n### 记录清除\n\n准确的说 purge 过程包括了两个部分：清除记录和清除 undo。在 purge 推进过程中收集到的 undo rec 会被组装成 purge_node_t，通过后台线程进行清理。\n\n<img src=\"/images/innodb-trx-4.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n基本的执行路径如下：\n\n```c++\n|--> row_purge_step\n|    |--> row_purge\n|    |    |--> row_purge_record  // row_purge_record_func, loop\n|    |    |    |--> row_purge_del_mark\n|    |    |    |    |--> row_purge_remove_multi_sec_if_poss\n|    |    |    |    |--> row_purge_remove_clust_if_poss\n|    |    |    |    |    |--> row_purge_remove_clust_if_poss_low\n|    |    |    |    |    |    |--> btr_cur_optimistic_delete\n|    |    |    |    |    |    |--> btr_cur_pessimistic_delete\n```\n\n## Undo 管理\n\n### Undo 分配\n\n关于 Undo 的分配，参考之前的文章。\n\n### Undo 回收\n\n前面在介绍 purge_sys 的时候，主要分析了 purge 过程中如何收集需要被 purge 的 undo 内容，这部分重点介绍 undo 的具体回收过程。\n\n```c++\n|--> trx_purge_truncate // 清理 undo 文件\n|    |--> trx_purge_truncate_history // 遍历 rsegs\n|    |    |--> trx_purge_truncate_rseg_history // 遍历 TRX_RSEG_HISTORY\n|    |    |    |--> trx_undo_truncate_start  // 正在处理的 trx_no\n|    |    |    |    |--> trx_undo_empty_header_page\n|    |    |    |    |--> trx_undo_free_page\n|    |    |    |\n|    |    |    |--> trx_purge_free_segment  // 已经处理完的 trx_no\n|    |    |    |    |--> fseg_free_step_not_header // 清理除 header 外的内容\n|    |    |    |    |    |--> fseg_free_page_low\n|    |    |    |    |--> trx_purge_remove_log_hdr // 从回滚段 TRX_RSEG_HISTORY 移除\n|    |    |    |    |--> fseg_free_step // 清理 page\n|    |    |    |    |    |--> fseg_free_page_low\n|    |    |    |    |    |--> fsp_free_seg_inode\n|    |    |    |\n|    |    |    |--> trx_purge_remove_log_hdr\n```\n\n## 参考文献\n\n> http://mysql.taobao.org/monthly/2015/04/01/","source":"_posts/innodb/innodb-transaction-commit.md","raw":"---\ntitle: InnoDB 事务提交过程\ndate: 2020-12-05 21:29:37\ntags:\n- 事务\ncategories: \n- InnoDB\n\n---\n\n前面已经介绍过 MySQL 在 Server 层的事务提交过程，本文主要对 InnoDB 层的事务提交过程进行介绍。\n\n<!-- more -->\n\n## Server 层两阶段提交过程\n\n```c++\n|--> trans_commit\n|    |--> ha_commit_trans\n|    |    |--> tc_log->prepare\n|    |    |    |--> ha_prepare_low\n|    |    |    |    |--> innobase_xa_prepare\n|    |    |    |    |    |--> trx_prepare_for_mysql\n|    |    |    |    |    |    |--> trx_prepare\n|    |    |    |    |    |    |    |--> trx_prepare_low\n|    |    |    |    |    |    |    |    |--> trx_undo_set_state_at_prepare\n|    |    |    |    |    |    |    |    |    |--> trx_undo_write_xid\n|    |    |\n|    |    |--> tc_log->commit\n|    |    |    |--> ha_commit_low\n|    |    |    |    |--> innobase_commit\n|    |    |    |    |    |--> innobase_commit_low\n|    |    |    |    |    |    |--> trx_commit_for_mysql\n|    |    |    |    |    |    |    |--> trx_undo_gtid_add_update_undo\n|    |    |    |    |    |    |    |--> trx_undo_gtid_flush_prepare\n|    |    |    |    |    |    |    |--> trx_commit\n|    |    |    |    |    |    |    |    |--> trx_commit_low\n|    |    |    |    |    |\n|    |    |    |    |    |--> trx_deregister_from_2pc\n|    |    |    |    |    |\n|    |    |    |    |    |--> trx_commit_complete_for_mysql\n|    |    |    |    |    |    |--> trx_flush_log_if_needed\n```\n\n## InnoDB 层提交过程\n\n结合代码分析一下事务提交的过程：\n\n```c++\n|--> trx_commit_low\n|    |--> trx_write_serialisation_history\n|    |    |--> trx_serialisation_number_get\n|    |    |    |--> trx_sys_get_new_trx_id  // trx_no\n|    |    |    |--> UT_LIST_ADD_LAST(trx_sys->serialisation_list)\n|    |    |    |--> purge_sys->purge_queue->push  // purge_sys 维护\n|    |    |\n|    |    |--> trx_undo_set_state_at_finish\n|    |    |--> trx_undo_update_clean\n|    |    |    |--> trx_purge_add_update_undo_to_history\n|    |    |    |    |--> flst_add_first(rseg_header + TRX_RSEG_HISTORY, undo_header + TRX_UNDO_HISTORY_NODE, mtr)\n|    |    |\n|    |    |--> trx_sys_update_mysql_binlog_offset\n|    |\n|    |--> trx_commit_in_memory\n|    |    |--> trx_release_impl_and_expl_locks\n|    |    |    |--> trx_erase_lists\n|    |    |    |    |--> UT_LIST_REMOVE(trx_sys->serialisation_list)\n|    |    |    |    |--> trx_sys->rw_trx_ids.erase\n|    |    |    |    |--> UT_LIST_REMOVE(trx_sys->rw_trx_list)\n|    |    |    |    |--> trx_sys->mvcc->view_close\n|    |    |    |    |--> trx_sys->rw_trx_set.erase\n|    |    |    |    |--> trx_sys->min_active_id.store\n|    |    |    |\n|    |    |    |--> lock_trx_release_locks\n|    |    |    |    |--> lock_release\n|    |    |    |    |    |--> lock_rec_dequeue_from_page\n|    |    |    |    |    |    |--> lock_rec_discard\n|    |    |    |    |    |    |--> lock_rec_grant // 遍历 page，查看是否有需要唤醒的锁等待\n|    |    |    |    |    |    |    |--> lock_grant_or_update_wait_for_edge_if_waiting\n|    |    |    |    |    |    |    |    |--> lock_grant_or_update_wait_for_edge\n|    |    |    |    |    |    |    |    |    |--> lock_has_to_wait_in_queue // 检查是否需要继续等待\n|    |    |    |    |    |    |    |    |    |--> lock_grant // 解锁，唤醒 trx->lock->wait_thr\n|    |    |    |    |    |    |    |    |    |    |--> lock_reset_wait_and_release_thread_if_suspended\n|    |    |    |    |    |    |    |    |    |    |    |--> lock_reset_lock_and_trx_wait\n|    |    |    |    |    |    |    |    |    |    |    |--> lock_wait_release_thread_if_suspended\n|    |    |    |    |    |    |    |    |    |    |    |     |--> que_thr_end_lock_wait\n|    |    |    |    |    |    |    |    |    |    |    |     |--> os_event_set(thr->slot->event)\n|    |    |    |    |    |    |    |    |    |--> lock_update_wait_for_edge \n|    |    |    |    |    |    |    |\n|    |    |    |    |    |    |    |--> lock_grant_cats\n|    |    |    |    |    |\n|    |    |    |    |    |--> lock_table_dequeue\n|    |    |\n|    |    |--> trx_sys->mvcc->view_close\n|    |    |--> trx_undo_insert_cleanup\n|    |    |--> srv_active_wake_master_thread\n```\n\n## 读写事务维护\n\n### 插入 rw_trx_xxx\n\n```c++\n|--> trx_set_rw_mode\n|    |--> trx_assign_rseg_durable\n|    |    |--> get_next_redo_rseg\n|    |    |    |--> get_next_redo_rseg_from_trx_sys  // 系统表空间\n|    |    |    |\n|    |    |    |--> get_next_redo_rseg_from_undo_spaces  // 独立 undo 表空间\n|    |\n|    |--> trx_sys_get_new_trx_id\n|    |--> trx_sys->rw_trx_ids.push_back\n|    |--> trx_sys->rw_trx_set.insert\n|    |--> UT_LIST_ADD_FIRST(trx_sys->rw_trx_list)\n```\n\nMySQL 在 trx_sys 中引入了好几个数据结构来维护读写事务集合，这些数据结构的修改都需要在 trx_sys->mutex 的保护下进行：\n\n- rw_trx_ids ：仅 trx_id 的集合\n- rw_trx_set ：仅 trx 的集合\n- rw_trx_list ：trx 的有序列表（事务开始时间有序）\n\n对于显示启动的事务，MySQL 默认只会开启一个只读事务，直到事务中有 DML 操作时才会升级为读写事务。通过上面的代码可以看到，不管是 undo 还是 trx_id 都是在升级为读写事务时才会分配。\n\n判断一个 trx_id 是否是活跃的读写事务：\n\n```c++\ntrx_t *trx_rw_is_active(trx_id_t trx_id, ibool *corrupt, bool do_ref_count) {\n  trx_t *trx;\n\n  if (trx_sys->min_active_id.load() > trx_id) {\n    return (NULL);\n  }\n\n  ...\n    \n  trx = trx_rw_is_active_low(trx_id, corrupt);\n\n  return (trx);\n}\n```\n\n### 移除 rw_trx_xxx\n\n在事务提交的时候，需要从读写事务对应的数据结构中进行移除：\n\n```c++\n|--> trx_commit_in_memory\n|    |--> trx_release_impl_and_expl_locks\n|    |    |--> trx_erase_lists\n|    |    |    |--> UT_LIST_REMOVE(trx_sys->serialisation_list)\n|    |    |    |--> trx_sys->rw_trx_ids.erase\n|    |    |    |--> UT_LIST_REMOVE(trx_sys->rw_trx_list)\n|    |    |    |--> trx_sys->mvcc->view_close\n|    |    |    |--> trx_sys->rw_trx_set.erase\n|    |    |    |--> trx_sys->min_active_id.store\n```\n\n## purge_sys 维护\n\n<img src=\"/images/innodb-trx-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n如图所示是一个简单的 purge_sys 相关的类图，purge_sys 是一个全局对象，所有 purge 相关的信息全部在其中维护。关于 purge_sys 主要包括了一下几项：\n\n### 插入 purge_sys\n\n对于一个读写事务，如果事务中包含了更新操作，则需要将更新操作先关的 undo 插入到 purge_sys（如果事务中只有插入操作，不需要维护 purge_sys，因为不需要利用 undo 构建历史版本）。purge_sys 利用一个优先队列 `purge_queue` 保存待 purge 的 undo，准确的说应该是回滚段，一个回滚段中包含了多个 undo，但是如果该回滚段之前已经加入过队列，则不需要继续添加。\n\npurge_sys 中维护了一个按照 trx_no 有序的优先队列 purge_queue，在事务提交的过程中（commit阶段）会将事务对应的回滚段添加到 purge_queue 中。前面已经说过，并不是每次事务提交的时候都会将回滚段添加到 purge_queue 中，只有当 redo_rseg->last_page_no 为空时（即回滚段上之前不存在未 puge 的 undo），才会添加到 purge_queue 中。若 redo_rseg->last_page_no 非空，则说明该回滚段上存在未 purg 的 undo，此时只会更新回滚段的 TRX_RSEG_HISTORY 列表，将新的 undo 添加到 TRX_RSEG_HISTORY 列表的头部。\n\n为了方便理解，结合回滚段的物理结构进行分析：\n\n<img src=\"/images/innodb-trx-2.png\" width=\"280px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n新产生的 undo 都需要被链接到 TRX_RSEG_HISTORY 上。\n\n注：回滚段中的 undo 通过一个有序列表进行组织，先生成的 undo 肯定会先被 purge。\n\n在前面的代码中可以看到，在事务提交的过程中，需要调用 `trx_serialisation_number_get` 将需要 purge 的 undo 插入到 purge_sys 的优先队列中。\n\n### purge 推进\n\nInnoDB 内部通过单独的后台线程周期性的进行 undo 的 purge，purge 推进的基本原则是：尽可能的将不再使用的 undo 内容 purge 掉。具体的实现上，基本步骤如下：\n\n```c++\n/* srv_start_purge_threads */\n\n|--> srv_purge_coordinator_thread\n|--> srv_worker_thread\n\n\n/* srv_purge_coordinator_thread::trx_purge */\n|--> trx_sys->mvcc->clone_oldest_view  // 确认当前最老的 read view\n|\n|--> trx_purge_attach_undo_recs // 收集指定数据的 undo pages\n|    |--> trx_purge_fetch_next_rec // loop\n|    |    |--> trx_purge_choose_next_log // !purge_sys->next_stored，寻找下一个 log\n|    |    |    |--> purge_sys->rseg_iter->set_next() // 更新 purge_sys->rseg 位置\n|    |    |    |--> trx_purge_read_undo_rec // 更新 purge_sys->iter 信息\n|    |    |    |    |--> trx_undo_get_first_rec // 总是从 resg->last_page_no 开始，next_stored 置为 true\n|    |    |\n|    |    |--> trx_undo_build_roll_ptr\n|    |    |--> trx_purge_get_next_rec // 寻找下一个 record\n|    |    |    |--> trx_undo_page_get_next_rec // 从当前 page 寻找下一个 record\n|    |    |    |--> trx_undo_get_next_rec\n|    |    |    |    |--> trx_undo_page_get_next_rec\n|    |    |    |    |--> trx_undo_get_next_rec_from_next_page // 从下一个 page 寻找，TRX_UNDO_PAGE_NODE\n|    |    |    |--> trx_purge_rseg_get_next_history_log // next_stored 置为 false，查找 TRX_UNDO_HISTORY_NODE, 找到下一个 hdr\n|\n|--> que_fork_scheduler_round_robin\n|--> srv_que_task_enqueue_low\n|--> que_run_threads\n|--> trx_purge_wait_for_workers_to_complete\n|\n|--> trx_purge_truncate // 清理 undo 文件\n|    |--> trx_purge_truncate_history // 遍历 rsegs\n|    |    |--> trx_purge_truncate_rseg_history // 遍历 TRX_RSEG_HISTORY\n\n\n/* srv_worker_thread::::row_purge_step */\n\n|--> row_purge\n|    |--> row_purge_parse_undo_rec\n|    |--> row_purge_record\n|    |    |--> row_purge_record_func\n|    |    |    |--> row_purge_del_mark\n|    |    |    |--> row_purge_upd_exist_or_extern\n```\n\nundo 的 purge 由后台线程完成，后台线程分为两类：coordinator 线程和 worker 线程。coordinator 线程负责收集和分发 undo log，worker 线程负责实际的 purge 工作（coordinator 线程本身也会参与 purge）。\n\ncoordinator 线程按照以下的逻辑收集 undo：\n\n1. 从 purge_queue 里面弹出一个元素 TrxUndoRsegs，m_trx_undo_rsegs 指向弹出的元素；\n2. 继续从 purge_queue 弹出元素，若弹出元素的 trx_no 和 m_trx_undo_rsegs 的 trx_no 相同，则直接进行合并，否则退出循环；\n3. m_iter 指向 m_trx_undo_rsegs，开始遍历，purg_sys->rseg 指向待处理的回滚段；\n4. 从待处理的回滚段中依次取 undo_record，若无法取到下一个 undo_record，则需要根据TRX_UNDO_HISTORY_NODE 取下一个 undo，并将 trx_rseg_t 重新 放入 purge_queue 中；\n5. m_iter 正常遍历，当遍历到 m_trx_undo_rsegs 尾部时，重复 1；\n\n由于这个逻辑实在有点绕，下面结合 undo page 的内部结构再分析一下：\n\n<img src=\"/images/innodb-trx-3.png\" width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n基本的逻辑如下：\n\n1. trx_rseg_t 上的 last_page_no、last_offset、last_trx_no 指向的是该回滚到对应的第一个未 purge 的 undo，也可以理解为 TRX_RSEG_HISTORY 最尾部（添加时都是添加到头部）的的一个 undo；\n2. 拿到这个 undo 后，先在当前页去获取 undo record，如果无法获取，那么就需要通过 TRX_UNDO_PAGE_NODE 找到下一个 page；\n3. 如果无法继续找到 undo record，那么说明当前 undo 已经结束了，那么需要根据 TRX_UNDO_HOSTORY_NODE 向前（添加时都是添加到头部）找到下一个 undo，这个时候找到的 undo 不能直接去获取 undo record，而是需要将 trx_rseg_t 指向该 page，然后重新放回优先队列；\n\n### 记录清除\n\n准确的说 purge 过程包括了两个部分：清除记录和清除 undo。在 purge 推进过程中收集到的 undo rec 会被组装成 purge_node_t，通过后台线程进行清理。\n\n<img src=\"/images/innodb-trx-4.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n基本的执行路径如下：\n\n```c++\n|--> row_purge_step\n|    |--> row_purge\n|    |    |--> row_purge_record  // row_purge_record_func, loop\n|    |    |    |--> row_purge_del_mark\n|    |    |    |    |--> row_purge_remove_multi_sec_if_poss\n|    |    |    |    |--> row_purge_remove_clust_if_poss\n|    |    |    |    |    |--> row_purge_remove_clust_if_poss_low\n|    |    |    |    |    |    |--> btr_cur_optimistic_delete\n|    |    |    |    |    |    |--> btr_cur_pessimistic_delete\n```\n\n## Undo 管理\n\n### Undo 分配\n\n关于 Undo 的分配，参考之前的文章。\n\n### Undo 回收\n\n前面在介绍 purge_sys 的时候，主要分析了 purge 过程中如何收集需要被 purge 的 undo 内容，这部分重点介绍 undo 的具体回收过程。\n\n```c++\n|--> trx_purge_truncate // 清理 undo 文件\n|    |--> trx_purge_truncate_history // 遍历 rsegs\n|    |    |--> trx_purge_truncate_rseg_history // 遍历 TRX_RSEG_HISTORY\n|    |    |    |--> trx_undo_truncate_start  // 正在处理的 trx_no\n|    |    |    |    |--> trx_undo_empty_header_page\n|    |    |    |    |--> trx_undo_free_page\n|    |    |    |\n|    |    |    |--> trx_purge_free_segment  // 已经处理完的 trx_no\n|    |    |    |    |--> fseg_free_step_not_header // 清理除 header 外的内容\n|    |    |    |    |    |--> fseg_free_page_low\n|    |    |    |    |--> trx_purge_remove_log_hdr // 从回滚段 TRX_RSEG_HISTORY 移除\n|    |    |    |    |--> fseg_free_step // 清理 page\n|    |    |    |    |    |--> fseg_free_page_low\n|    |    |    |    |    |--> fsp_free_seg_inode\n|    |    |    |\n|    |    |    |--> trx_purge_remove_log_hdr\n```\n\n## 参考文献\n\n> http://mysql.taobao.org/monthly/2015/04/01/","slug":"innodb/innodb-transaction-commit","published":1,"updated":"2020-12-05T13:44:08.854Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4xk000xgugm03mw3lf0","content":"<p>前面已经介绍过 MySQL 在 Server 层的事务提交过程，本文主要对 InnoDB 层的事务提交过程进行介绍。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Server-层两阶段提交过程\"><a href=\"#Server-层两阶段提交过程\" class=\"headerlink\" title=\"Server 层两阶段提交过程\"></a>Server 层两阶段提交过程</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; trans_commit</span><br><span class=\"line\">|    |--&gt; ha_commit_trans</span><br><span class=\"line\">|    |    |--&gt; tc_log-&gt;<span class=\"built_in\">prepare</span></span><br><span class=\"line\">|    |    |    |--&gt; ha_prepare_low</span><br><span class=\"line\">|    |    |    |    |--&gt; innobase_xa_prepare</span><br><span class=\"line\">|    |    |    |    |    |--&gt; trx_prepare_for_mysql</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; trx_prepare</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; trx_prepare_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; trx_undo_set_state_at_prepare</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; trx_undo_write_xid</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; tc_log-&gt;commit</span><br><span class=\"line\">|    |    |    |--&gt; ha_commit_low</span><br><span class=\"line\">|    |    |    |    |--&gt; innobase_commit</span><br><span class=\"line\">|    |    |    |    |    |--&gt; innobase_commit_low</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; trx_commit_for_mysql</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; trx_undo_gtid_add_update_undo</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; trx_undo_gtid_flush_prepare</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; trx_commit</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; trx_commit_low</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; trx_deregister_from_2pc</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; trx_commit_complete_for_mysql</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; trx_flush_log_if_needed</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"InnoDB-层提交过程\"><a href=\"#InnoDB-层提交过程\" class=\"headerlink\" title=\"InnoDB 层提交过程\"></a>InnoDB 层提交过程</h2><p>结合代码分析一下事务提交的过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; trx_commit_low</span><br><span class=\"line\">|    |--&gt; trx_write_serialisation_history</span><br><span class=\"line\">|    |    |--&gt; trx_serialisation_number_get</span><br><span class=\"line\">|    |    |    |--&gt; trx_sys_get_new_trx_id  <span class=\"comment\">// trx_no</span></span><br><span class=\"line\">|    |    |    |--&gt; UT_LIST_ADD_LAST(trx_sys-&gt;serialisation_list)</span><br><span class=\"line\">|    |    |    |--&gt; purge_sys-&gt;purge_queue-&gt;push  <span class=\"comment\">// purge_sys 维护</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; trx_undo_set_state_at_finish</span><br><span class=\"line\">|    |    |--&gt; trx_undo_update_clean</span><br><span class=\"line\">|    |    |    |--&gt; trx_purge_add_update_undo_to_history</span><br><span class=\"line\">|    |    |    |    |--&gt; flst_add_first(rseg_header + TRX_RSEG_HISTORY, undo_header + TRX_UNDO_HISTORY_NODE, mtr)</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; trx_sys_update_mysql_binlog_offset</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; trx_commit_in_memory</span><br><span class=\"line\">|    |    |--&gt; trx_release_impl_and_expl_locks</span><br><span class=\"line\">|    |    |    |--&gt; trx_erase_lists</span><br><span class=\"line\">|    |    |    |    |--&gt; UT_LIST_REMOVE(trx_sys-&gt;serialisation_list)</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_sys-&gt;rw_trx_ids.erase</span><br><span class=\"line\">|    |    |    |    |--&gt; UT_LIST_REMOVE(trx_sys-&gt;rw_trx_list)</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_sys-&gt;mvcc-&gt;view_close</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_sys-&gt;rw_trx_set.erase</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_sys-&gt;min_active_id.store</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; lock_trx_release_locks</span><br><span class=\"line\">|    |    |    |    |--&gt; lock_release</span><br><span class=\"line\">|    |    |    |    |    |--&gt; lock_rec_dequeue_from_page</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; lock_rec_discard</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; lock_rec_grant <span class=\"comment\">// 遍历 page，查看是否有需要唤醒的锁等待</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; lock_grant_or_update_wait_for_edge_if_waiting</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; lock_grant_or_update_wait_for_edge</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; lock_has_to_wait_in_queue <span class=\"comment\">// 检查是否需要继续等待</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; lock_grant <span class=\"comment\">// 解锁，唤醒 trx-&gt;lock-&gt;wait_thr</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |--&gt; lock_reset_wait_and_release_thread_if_suspended</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |    |--&gt; lock_reset_lock_and_trx_wait</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |    |--&gt; lock_wait_release_thread_if_suspended</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |    |     |--&gt; que_thr_end_lock_wait</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |    |     |--&gt; os_event_set(thr-&gt;slot-&gt;event)</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; lock_update_wait_for_edge </span><br><span class=\"line\">|    |    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; lock_grant_cats</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; lock_table_dequeue</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; trx_sys-&gt;mvcc-&gt;view_close</span><br><span class=\"line\">|    |    |--&gt; trx_undo_insert_cleanup</span><br><span class=\"line\">|    |    |--&gt; srv_active_wake_master_thread</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"读写事务维护\"><a href=\"#读写事务维护\" class=\"headerlink\" title=\"读写事务维护\"></a>读写事务维护</h2><h3 id=\"插入-rw-trx-xxx\"><a href=\"#插入-rw-trx-xxx\" class=\"headerlink\" title=\"插入 rw_trx_xxx\"></a>插入 rw_trx_xxx</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; trx_set_rw_mode</span><br><span class=\"line\">|    |--&gt; trx_assign_rseg_durable</span><br><span class=\"line\">|    |    |--&gt; get_next_redo_rseg</span><br><span class=\"line\">|    |    |    |--&gt; get_next_redo_rseg_from_trx_sys  <span class=\"comment\">// 系统表空间</span></span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; get_next_redo_rseg_from_undo_spaces  <span class=\"comment\">// 独立 undo 表空间</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; trx_sys_get_new_trx_id</span><br><span class=\"line\">|    |--&gt; trx_sys-&gt;rw_trx_ids.push_back</span><br><span class=\"line\">|    |--&gt; trx_sys-&gt;rw_trx_set.insert</span><br><span class=\"line\">|    |--&gt; UT_LIST_ADD_FIRST(trx_sys-&gt;rw_trx_list)</span><br></pre></td></tr></table></figure>\n\n<p>MySQL 在 trx_sys 中引入了好几个数据结构来维护读写事务集合，这些数据结构的修改都需要在 trx_sys-&gt;mutex 的保护下进行：</p>\n<ul>\n<li>rw_trx_ids ：仅 trx_id 的集合</li>\n<li>rw_trx_set ：仅 trx 的集合</li>\n<li>rw_trx_list ：trx 的有序列表（事务开始时间有序）</li>\n</ul>\n<p>对于显示启动的事务，MySQL 默认只会开启一个只读事务，直到事务中有 DML 操作时才会升级为读写事务。通过上面的代码可以看到，不管是 undo 还是 trx_id 都是在升级为读写事务时才会分配。</p>\n<p>判断一个 trx_id 是否是活跃的读写事务：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">trx_t</span> *<span class=\"title\">trx_rw_is_active</span><span class=\"params\">(<span class=\"keyword\">trx_id_t</span> trx_id, ibool *corrupt, <span class=\"keyword\">bool</span> do_ref_count)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">trx_t</span> *trx;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (trx_sys-&gt;min_active_id.load() &gt; trx_id) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">    </span><br><span class=\"line\">  trx = trx_rw_is_active_low(trx_id, corrupt);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (trx);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"移除-rw-trx-xxx\"><a href=\"#移除-rw-trx-xxx\" class=\"headerlink\" title=\"移除 rw_trx_xxx\"></a>移除 rw_trx_xxx</h3><p>在事务提交的时候，需要从读写事务对应的数据结构中进行移除：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; trx_commit_in_memory</span><br><span class=\"line\">|    |--&gt; trx_release_impl_and_expl_locks</span><br><span class=\"line\">|    |    |--&gt; trx_erase_lists</span><br><span class=\"line\">|    |    |    |--&gt; UT_LIST_REMOVE(trx_sys-&gt;serialisation_list)</span><br><span class=\"line\">|    |    |    |--&gt; trx_sys-&gt;rw_trx_ids.erase</span><br><span class=\"line\">|    |    |    |--&gt; UT_LIST_REMOVE(trx_sys-&gt;rw_trx_list)</span><br><span class=\"line\">|    |    |    |--&gt; trx_sys-&gt;mvcc-&gt;view_close</span><br><span class=\"line\">|    |    |    |--&gt; trx_sys-&gt;rw_trx_set.erase</span><br><span class=\"line\">|    |    |    |--&gt; trx_sys-&gt;min_active_id.store</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"purge-sys-维护\"><a href=\"#purge-sys-维护\" class=\"headerlink\" title=\"purge_sys 维护\"></a>purge_sys 维护</h2><img src=\"/images/innodb-trx-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>如图所示是一个简单的 purge_sys 相关的类图，purge_sys 是一个全局对象，所有 purge 相关的信息全部在其中维护。关于 purge_sys 主要包括了一下几项：</p>\n<h3 id=\"插入-purge-sys\"><a href=\"#插入-purge-sys\" class=\"headerlink\" title=\"插入 purge_sys\"></a>插入 purge_sys</h3><p>对于一个读写事务，如果事务中包含了更新操作，则需要将更新操作先关的 undo 插入到 purge_sys（如果事务中只有插入操作，不需要维护 purge_sys，因为不需要利用 undo 构建历史版本）。purge_sys 利用一个优先队列 <code>purge_queue</code> 保存待 purge 的 undo，准确的说应该是回滚段，一个回滚段中包含了多个 undo，但是如果该回滚段之前已经加入过队列，则不需要继续添加。</p>\n<p>purge_sys 中维护了一个按照 trx_no 有序的优先队列 purge_queue，在事务提交的过程中（commit阶段）会将事务对应的回滚段添加到 purge_queue 中。前面已经说过，并不是每次事务提交的时候都会将回滚段添加到 purge_queue 中，只有当 redo_rseg-&gt;last_page_no 为空时（即回滚段上之前不存在未 puge 的 undo），才会添加到 purge_queue 中。若 redo_rseg-&gt;last_page_no 非空，则说明该回滚段上存在未 purg 的 undo，此时只会更新回滚段的 TRX_RSEG_HISTORY 列表，将新的 undo 添加到 TRX_RSEG_HISTORY 列表的头部。</p>\n<p>为了方便理解，结合回滚段的物理结构进行分析：</p>\n<img src=\"/images/innodb-trx-2.png\" width=\"280px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>新产生的 undo 都需要被链接到 TRX_RSEG_HISTORY 上。</p>\n<p>注：回滚段中的 undo 通过一个有序列表进行组织，先生成的 undo 肯定会先被 purge。</p>\n<p>在前面的代码中可以看到，在事务提交的过程中，需要调用 <code>trx_serialisation_number_get</code> 将需要 purge 的 undo 插入到 purge_sys 的优先队列中。</p>\n<h3 id=\"purge-推进\"><a href=\"#purge-推进\" class=\"headerlink\" title=\"purge 推进\"></a>purge 推进</h3><p>InnoDB 内部通过单独的后台线程周期性的进行 undo 的 purge，purge 推进的基本原则是：尽可能的将不再使用的 undo 内容 purge 掉。具体的实现上，基本步骤如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* srv_start_purge_threads */</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; srv_purge_coordinator_thread</span><br><span class=\"line\">|--&gt; srv_worker_thread</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* srv_purge_coordinator_thread::trx_purge */</span></span><br><span class=\"line\">|--&gt; trx_sys-&gt;mvcc-&gt;clone_oldest_view  <span class=\"comment\">// 确认当前最老的 read view</span></span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; trx_purge_attach_undo_recs <span class=\"comment\">// 收集指定数据的 undo pages</span></span><br><span class=\"line\">|    |--&gt; trx_purge_fetch_next_rec <span class=\"comment\">// loop</span></span><br><span class=\"line\">|    |    |--&gt; trx_purge_choose_next_log <span class=\"comment\">// !purge_sys-&gt;next_stored，寻找下一个 log</span></span><br><span class=\"line\">|    |    |    |--&gt; purge_sys-&gt;rseg_iter-&gt;set_next() <span class=\"comment\">// 更新 purge_sys-&gt;rseg 位置</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_purge_read_undo_rec <span class=\"comment\">// 更新 purge_sys-&gt;iter 信息</span></span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_get_first_rec <span class=\"comment\">// 总是从 resg-&gt;last_page_no 开始，next_stored 置为 true</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; trx_undo_build_roll_ptr</span><br><span class=\"line\">|    |    |--&gt; trx_purge_get_next_rec <span class=\"comment\">// 寻找下一个 record</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_undo_page_get_next_rec <span class=\"comment\">// 从当前 page 寻找下一个 record</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_undo_get_next_rec</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_page_get_next_rec</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_get_next_rec_from_next_page <span class=\"comment\">// 从下一个 page 寻找，TRX_UNDO_PAGE_NODE</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_purge_rseg_get_next_history_log <span class=\"comment\">// next_stored 置为 false，查找 TRX_UNDO_HISTORY_NODE, 找到下一个 hdr</span></span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; que_fork_scheduler_round_robin</span><br><span class=\"line\">|--&gt; srv_que_task_enqueue_low</span><br><span class=\"line\">|--&gt; que_run_threads</span><br><span class=\"line\">|--&gt; trx_purge_wait_for_workers_to_complete</span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; trx_purge_truncate <span class=\"comment\">// 清理 undo 文件</span></span><br><span class=\"line\">|    |--&gt; trx_purge_truncate_history <span class=\"comment\">// 遍历 rsegs</span></span><br><span class=\"line\">|    |    |--&gt; trx_purge_truncate_rseg_history <span class=\"comment\">// 遍历 TRX_RSEG_HISTORY</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* srv_worker_thread::::row_purge_step */</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; row_purge</span><br><span class=\"line\">|    |--&gt; row_purge_parse_undo_rec</span><br><span class=\"line\">|    |--&gt; row_purge_record</span><br><span class=\"line\">|    |    |--&gt; row_purge_record_func</span><br><span class=\"line\">|    |    |    |--&gt; row_purge_del_mark</span><br><span class=\"line\">|    |    |    |--&gt; row_purge_upd_exist_or_extern</span><br></pre></td></tr></table></figure>\n\n<p>undo 的 purge 由后台线程完成，后台线程分为两类：coordinator 线程和 worker 线程。coordinator 线程负责收集和分发 undo log，worker 线程负责实际的 purge 工作（coordinator 线程本身也会参与 purge）。</p>\n<p>coordinator 线程按照以下的逻辑收集 undo：</p>\n<ol>\n<li>从 purge_queue 里面弹出一个元素 TrxUndoRsegs，m_trx_undo_rsegs 指向弹出的元素；</li>\n<li>继续从 purge_queue 弹出元素，若弹出元素的 trx_no 和 m_trx_undo_rsegs 的 trx_no 相同，则直接进行合并，否则退出循环；</li>\n<li>m_iter 指向 m_trx_undo_rsegs，开始遍历，purg_sys-&gt;rseg 指向待处理的回滚段；</li>\n<li>从待处理的回滚段中依次取 undo_record，若无法取到下一个 undo_record，则需要根据TRX_UNDO_HISTORY_NODE 取下一个 undo，并将 trx_rseg_t 重新 放入 purge_queue 中；</li>\n<li>m_iter 正常遍历，当遍历到 m_trx_undo_rsegs 尾部时，重复 1；</li>\n</ol>\n<p>由于这个逻辑实在有点绕，下面结合 undo page 的内部结构再分析一下：</p>\n<img src=\"/images/innodb-trx-3.png\" width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>基本的逻辑如下：</p>\n<ol>\n<li>trx_rseg_t 上的 last_page_no、last_offset、last_trx_no 指向的是该回滚到对应的第一个未 purge 的 undo，也可以理解为 TRX_RSEG_HISTORY 最尾部（添加时都是添加到头部）的的一个 undo；</li>\n<li>拿到这个 undo 后，先在当前页去获取 undo record，如果无法获取，那么就需要通过 TRX_UNDO_PAGE_NODE 找到下一个 page；</li>\n<li>如果无法继续找到 undo record，那么说明当前 undo 已经结束了，那么需要根据 TRX_UNDO_HOSTORY_NODE 向前（添加时都是添加到头部）找到下一个 undo，这个时候找到的 undo 不能直接去获取 undo record，而是需要将 trx_rseg_t 指向该 page，然后重新放回优先队列；</li>\n</ol>\n<h3 id=\"记录清除\"><a href=\"#记录清除\" class=\"headerlink\" title=\"记录清除\"></a>记录清除</h3><p>准确的说 purge 过程包括了两个部分：清除记录和清除 undo。在 purge 推进过程中收集到的 undo rec 会被组装成 purge_node_t，通过后台线程进行清理。</p>\n<img src=\"/images/innodb-trx-4.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>基本的执行路径如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; row_purge_step</span><br><span class=\"line\">|    |--&gt; row_purge</span><br><span class=\"line\">|    |    |--&gt; row_purge_record  <span class=\"comment\">// row_purge_record_func, loop</span></span><br><span class=\"line\">|    |    |    |--&gt; row_purge_del_mark</span><br><span class=\"line\">|    |    |    |    |--&gt; row_purge_remove_multi_sec_if_poss</span><br><span class=\"line\">|    |    |    |    |--&gt; row_purge_remove_clust_if_poss</span><br><span class=\"line\">|    |    |    |    |    |--&gt; row_purge_remove_clust_if_poss_low</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; btr_cur_optimistic_delete</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; btr_cur_pessimistic_delete</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Undo-管理\"><a href=\"#Undo-管理\" class=\"headerlink\" title=\"Undo 管理\"></a>Undo 管理</h2><h3 id=\"Undo-分配\"><a href=\"#Undo-分配\" class=\"headerlink\" title=\"Undo 分配\"></a>Undo 分配</h3><p>关于 Undo 的分配，参考之前的文章。</p>\n<h3 id=\"Undo-回收\"><a href=\"#Undo-回收\" class=\"headerlink\" title=\"Undo 回收\"></a>Undo 回收</h3><p>前面在介绍 purge_sys 的时候，主要分析了 purge 过程中如何收集需要被 purge 的 undo 内容，这部分重点介绍 undo 的具体回收过程。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; trx_purge_truncate <span class=\"comment\">// 清理 undo 文件</span></span><br><span class=\"line\">|    |--&gt; trx_purge_truncate_history <span class=\"comment\">// 遍历 rsegs</span></span><br><span class=\"line\">|    |    |--&gt; trx_purge_truncate_rseg_history <span class=\"comment\">// 遍历 TRX_RSEG_HISTORY</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_undo_truncate_start  <span class=\"comment\">// 正在处理的 trx_no</span></span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_empty_header_page</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_free_page</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; trx_purge_free_segment  <span class=\"comment\">// 已经处理完的 trx_no</span></span><br><span class=\"line\">|    |    |    |    |--&gt; fseg_free_step_not_header <span class=\"comment\">// 清理除 header 外的内容</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; fseg_free_page_low</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_purge_remove_log_hdr <span class=\"comment\">// 从回滚段 TRX_RSEG_HISTORY 移除</span></span><br><span class=\"line\">|    |    |    |    |--&gt; fseg_free_step <span class=\"comment\">// 清理 page</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; fseg_free_page_low</span><br><span class=\"line\">|    |    |    |    |    |--&gt; fsp_free_seg_inode</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; trx_purge_remove_log_hdr</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p><a href=\"http://mysql.taobao.org/monthly/2015/04/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2015/04/01/</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>前面已经介绍过 MySQL 在 Server 层的事务提交过程，本文主要对 InnoDB 层的事务提交过程进行介绍。</p>","more":"<h2 id=\"Server-层两阶段提交过程\"><a href=\"#Server-层两阶段提交过程\" class=\"headerlink\" title=\"Server 层两阶段提交过程\"></a>Server 层两阶段提交过程</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; trans_commit</span><br><span class=\"line\">|    |--&gt; ha_commit_trans</span><br><span class=\"line\">|    |    |--&gt; tc_log-&gt;<span class=\"built_in\">prepare</span></span><br><span class=\"line\">|    |    |    |--&gt; ha_prepare_low</span><br><span class=\"line\">|    |    |    |    |--&gt; innobase_xa_prepare</span><br><span class=\"line\">|    |    |    |    |    |--&gt; trx_prepare_for_mysql</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; trx_prepare</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; trx_prepare_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; trx_undo_set_state_at_prepare</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; trx_undo_write_xid</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; tc_log-&gt;commit</span><br><span class=\"line\">|    |    |    |--&gt; ha_commit_low</span><br><span class=\"line\">|    |    |    |    |--&gt; innobase_commit</span><br><span class=\"line\">|    |    |    |    |    |--&gt; innobase_commit_low</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; trx_commit_for_mysql</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; trx_undo_gtid_add_update_undo</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; trx_undo_gtid_flush_prepare</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; trx_commit</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; trx_commit_low</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; trx_deregister_from_2pc</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; trx_commit_complete_for_mysql</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; trx_flush_log_if_needed</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"InnoDB-层提交过程\"><a href=\"#InnoDB-层提交过程\" class=\"headerlink\" title=\"InnoDB 层提交过程\"></a>InnoDB 层提交过程</h2><p>结合代码分析一下事务提交的过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; trx_commit_low</span><br><span class=\"line\">|    |--&gt; trx_write_serialisation_history</span><br><span class=\"line\">|    |    |--&gt; trx_serialisation_number_get</span><br><span class=\"line\">|    |    |    |--&gt; trx_sys_get_new_trx_id  <span class=\"comment\">// trx_no</span></span><br><span class=\"line\">|    |    |    |--&gt; UT_LIST_ADD_LAST(trx_sys-&gt;serialisation_list)</span><br><span class=\"line\">|    |    |    |--&gt; purge_sys-&gt;purge_queue-&gt;push  <span class=\"comment\">// purge_sys 维护</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; trx_undo_set_state_at_finish</span><br><span class=\"line\">|    |    |--&gt; trx_undo_update_clean</span><br><span class=\"line\">|    |    |    |--&gt; trx_purge_add_update_undo_to_history</span><br><span class=\"line\">|    |    |    |    |--&gt; flst_add_first(rseg_header + TRX_RSEG_HISTORY, undo_header + TRX_UNDO_HISTORY_NODE, mtr)</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; trx_sys_update_mysql_binlog_offset</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; trx_commit_in_memory</span><br><span class=\"line\">|    |    |--&gt; trx_release_impl_and_expl_locks</span><br><span class=\"line\">|    |    |    |--&gt; trx_erase_lists</span><br><span class=\"line\">|    |    |    |    |--&gt; UT_LIST_REMOVE(trx_sys-&gt;serialisation_list)</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_sys-&gt;rw_trx_ids.erase</span><br><span class=\"line\">|    |    |    |    |--&gt; UT_LIST_REMOVE(trx_sys-&gt;rw_trx_list)</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_sys-&gt;mvcc-&gt;view_close</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_sys-&gt;rw_trx_set.erase</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_sys-&gt;min_active_id.store</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; lock_trx_release_locks</span><br><span class=\"line\">|    |    |    |    |--&gt; lock_release</span><br><span class=\"line\">|    |    |    |    |    |--&gt; lock_rec_dequeue_from_page</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; lock_rec_discard</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; lock_rec_grant <span class=\"comment\">// 遍历 page，查看是否有需要唤醒的锁等待</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; lock_grant_or_update_wait_for_edge_if_waiting</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; lock_grant_or_update_wait_for_edge</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; lock_has_to_wait_in_queue <span class=\"comment\">// 检查是否需要继续等待</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; lock_grant <span class=\"comment\">// 解锁，唤醒 trx-&gt;lock-&gt;wait_thr</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |--&gt; lock_reset_wait_and_release_thread_if_suspended</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |    |--&gt; lock_reset_lock_and_trx_wait</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |    |--&gt; lock_wait_release_thread_if_suspended</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |    |     |--&gt; que_thr_end_lock_wait</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |    |     |--&gt; os_event_set(thr-&gt;slot-&gt;event)</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; lock_update_wait_for_edge </span><br><span class=\"line\">|    |    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; lock_grant_cats</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; lock_table_dequeue</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; trx_sys-&gt;mvcc-&gt;view_close</span><br><span class=\"line\">|    |    |--&gt; trx_undo_insert_cleanup</span><br><span class=\"line\">|    |    |--&gt; srv_active_wake_master_thread</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"读写事务维护\"><a href=\"#读写事务维护\" class=\"headerlink\" title=\"读写事务维护\"></a>读写事务维护</h2><h3 id=\"插入-rw-trx-xxx\"><a href=\"#插入-rw-trx-xxx\" class=\"headerlink\" title=\"插入 rw_trx_xxx\"></a>插入 rw_trx_xxx</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; trx_set_rw_mode</span><br><span class=\"line\">|    |--&gt; trx_assign_rseg_durable</span><br><span class=\"line\">|    |    |--&gt; get_next_redo_rseg</span><br><span class=\"line\">|    |    |    |--&gt; get_next_redo_rseg_from_trx_sys  <span class=\"comment\">// 系统表空间</span></span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; get_next_redo_rseg_from_undo_spaces  <span class=\"comment\">// 独立 undo 表空间</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; trx_sys_get_new_trx_id</span><br><span class=\"line\">|    |--&gt; trx_sys-&gt;rw_trx_ids.push_back</span><br><span class=\"line\">|    |--&gt; trx_sys-&gt;rw_trx_set.insert</span><br><span class=\"line\">|    |--&gt; UT_LIST_ADD_FIRST(trx_sys-&gt;rw_trx_list)</span><br></pre></td></tr></table></figure>\n\n<p>MySQL 在 trx_sys 中引入了好几个数据结构来维护读写事务集合，这些数据结构的修改都需要在 trx_sys-&gt;mutex 的保护下进行：</p>\n<ul>\n<li>rw_trx_ids ：仅 trx_id 的集合</li>\n<li>rw_trx_set ：仅 trx 的集合</li>\n<li>rw_trx_list ：trx 的有序列表（事务开始时间有序）</li>\n</ul>\n<p>对于显示启动的事务，MySQL 默认只会开启一个只读事务，直到事务中有 DML 操作时才会升级为读写事务。通过上面的代码可以看到，不管是 undo 还是 trx_id 都是在升级为读写事务时才会分配。</p>\n<p>判断一个 trx_id 是否是活跃的读写事务：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">trx_t</span> *<span class=\"title\">trx_rw_is_active</span><span class=\"params\">(<span class=\"keyword\">trx_id_t</span> trx_id, ibool *corrupt, <span class=\"keyword\">bool</span> do_ref_count)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">trx_t</span> *trx;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (trx_sys-&gt;min_active_id.load() &gt; trx_id) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">    </span><br><span class=\"line\">  trx = trx_rw_is_active_low(trx_id, corrupt);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (trx);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"移除-rw-trx-xxx\"><a href=\"#移除-rw-trx-xxx\" class=\"headerlink\" title=\"移除 rw_trx_xxx\"></a>移除 rw_trx_xxx</h3><p>在事务提交的时候，需要从读写事务对应的数据结构中进行移除：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; trx_commit_in_memory</span><br><span class=\"line\">|    |--&gt; trx_release_impl_and_expl_locks</span><br><span class=\"line\">|    |    |--&gt; trx_erase_lists</span><br><span class=\"line\">|    |    |    |--&gt; UT_LIST_REMOVE(trx_sys-&gt;serialisation_list)</span><br><span class=\"line\">|    |    |    |--&gt; trx_sys-&gt;rw_trx_ids.erase</span><br><span class=\"line\">|    |    |    |--&gt; UT_LIST_REMOVE(trx_sys-&gt;rw_trx_list)</span><br><span class=\"line\">|    |    |    |--&gt; trx_sys-&gt;mvcc-&gt;view_close</span><br><span class=\"line\">|    |    |    |--&gt; trx_sys-&gt;rw_trx_set.erase</span><br><span class=\"line\">|    |    |    |--&gt; trx_sys-&gt;min_active_id.store</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"purge-sys-维护\"><a href=\"#purge-sys-维护\" class=\"headerlink\" title=\"purge_sys 维护\"></a>purge_sys 维护</h2><img src=\"/images/innodb-trx-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>如图所示是一个简单的 purge_sys 相关的类图，purge_sys 是一个全局对象，所有 purge 相关的信息全部在其中维护。关于 purge_sys 主要包括了一下几项：</p>\n<h3 id=\"插入-purge-sys\"><a href=\"#插入-purge-sys\" class=\"headerlink\" title=\"插入 purge_sys\"></a>插入 purge_sys</h3><p>对于一个读写事务，如果事务中包含了更新操作，则需要将更新操作先关的 undo 插入到 purge_sys（如果事务中只有插入操作，不需要维护 purge_sys，因为不需要利用 undo 构建历史版本）。purge_sys 利用一个优先队列 <code>purge_queue</code> 保存待 purge 的 undo，准确的说应该是回滚段，一个回滚段中包含了多个 undo，但是如果该回滚段之前已经加入过队列，则不需要继续添加。</p>\n<p>purge_sys 中维护了一个按照 trx_no 有序的优先队列 purge_queue，在事务提交的过程中（commit阶段）会将事务对应的回滚段添加到 purge_queue 中。前面已经说过，并不是每次事务提交的时候都会将回滚段添加到 purge_queue 中，只有当 redo_rseg-&gt;last_page_no 为空时（即回滚段上之前不存在未 puge 的 undo），才会添加到 purge_queue 中。若 redo_rseg-&gt;last_page_no 非空，则说明该回滚段上存在未 purg 的 undo，此时只会更新回滚段的 TRX_RSEG_HISTORY 列表，将新的 undo 添加到 TRX_RSEG_HISTORY 列表的头部。</p>\n<p>为了方便理解，结合回滚段的物理结构进行分析：</p>\n<img src=\"/images/innodb-trx-2.png\" width=\"280px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>新产生的 undo 都需要被链接到 TRX_RSEG_HISTORY 上。</p>\n<p>注：回滚段中的 undo 通过一个有序列表进行组织，先生成的 undo 肯定会先被 purge。</p>\n<p>在前面的代码中可以看到，在事务提交的过程中，需要调用 <code>trx_serialisation_number_get</code> 将需要 purge 的 undo 插入到 purge_sys 的优先队列中。</p>\n<h3 id=\"purge-推进\"><a href=\"#purge-推进\" class=\"headerlink\" title=\"purge 推进\"></a>purge 推进</h3><p>InnoDB 内部通过单独的后台线程周期性的进行 undo 的 purge，purge 推进的基本原则是：尽可能的将不再使用的 undo 内容 purge 掉。具体的实现上，基本步骤如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* srv_start_purge_threads */</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; srv_purge_coordinator_thread</span><br><span class=\"line\">|--&gt; srv_worker_thread</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* srv_purge_coordinator_thread::trx_purge */</span></span><br><span class=\"line\">|--&gt; trx_sys-&gt;mvcc-&gt;clone_oldest_view  <span class=\"comment\">// 确认当前最老的 read view</span></span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; trx_purge_attach_undo_recs <span class=\"comment\">// 收集指定数据的 undo pages</span></span><br><span class=\"line\">|    |--&gt; trx_purge_fetch_next_rec <span class=\"comment\">// loop</span></span><br><span class=\"line\">|    |    |--&gt; trx_purge_choose_next_log <span class=\"comment\">// !purge_sys-&gt;next_stored，寻找下一个 log</span></span><br><span class=\"line\">|    |    |    |--&gt; purge_sys-&gt;rseg_iter-&gt;set_next() <span class=\"comment\">// 更新 purge_sys-&gt;rseg 位置</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_purge_read_undo_rec <span class=\"comment\">// 更新 purge_sys-&gt;iter 信息</span></span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_get_first_rec <span class=\"comment\">// 总是从 resg-&gt;last_page_no 开始，next_stored 置为 true</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; trx_undo_build_roll_ptr</span><br><span class=\"line\">|    |    |--&gt; trx_purge_get_next_rec <span class=\"comment\">// 寻找下一个 record</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_undo_page_get_next_rec <span class=\"comment\">// 从当前 page 寻找下一个 record</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_undo_get_next_rec</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_page_get_next_rec</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_get_next_rec_from_next_page <span class=\"comment\">// 从下一个 page 寻找，TRX_UNDO_PAGE_NODE</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_purge_rseg_get_next_history_log <span class=\"comment\">// next_stored 置为 false，查找 TRX_UNDO_HISTORY_NODE, 找到下一个 hdr</span></span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; que_fork_scheduler_round_robin</span><br><span class=\"line\">|--&gt; srv_que_task_enqueue_low</span><br><span class=\"line\">|--&gt; que_run_threads</span><br><span class=\"line\">|--&gt; trx_purge_wait_for_workers_to_complete</span><br><span class=\"line\">|</span><br><span class=\"line\">|--&gt; trx_purge_truncate <span class=\"comment\">// 清理 undo 文件</span></span><br><span class=\"line\">|    |--&gt; trx_purge_truncate_history <span class=\"comment\">// 遍历 rsegs</span></span><br><span class=\"line\">|    |    |--&gt; trx_purge_truncate_rseg_history <span class=\"comment\">// 遍历 TRX_RSEG_HISTORY</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* srv_worker_thread::::row_purge_step */</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; row_purge</span><br><span class=\"line\">|    |--&gt; row_purge_parse_undo_rec</span><br><span class=\"line\">|    |--&gt; row_purge_record</span><br><span class=\"line\">|    |    |--&gt; row_purge_record_func</span><br><span class=\"line\">|    |    |    |--&gt; row_purge_del_mark</span><br><span class=\"line\">|    |    |    |--&gt; row_purge_upd_exist_or_extern</span><br></pre></td></tr></table></figure>\n\n<p>undo 的 purge 由后台线程完成，后台线程分为两类：coordinator 线程和 worker 线程。coordinator 线程负责收集和分发 undo log，worker 线程负责实际的 purge 工作（coordinator 线程本身也会参与 purge）。</p>\n<p>coordinator 线程按照以下的逻辑收集 undo：</p>\n<ol>\n<li>从 purge_queue 里面弹出一个元素 TrxUndoRsegs，m_trx_undo_rsegs 指向弹出的元素；</li>\n<li>继续从 purge_queue 弹出元素，若弹出元素的 trx_no 和 m_trx_undo_rsegs 的 trx_no 相同，则直接进行合并，否则退出循环；</li>\n<li>m_iter 指向 m_trx_undo_rsegs，开始遍历，purg_sys-&gt;rseg 指向待处理的回滚段；</li>\n<li>从待处理的回滚段中依次取 undo_record，若无法取到下一个 undo_record，则需要根据TRX_UNDO_HISTORY_NODE 取下一个 undo，并将 trx_rseg_t 重新 放入 purge_queue 中；</li>\n<li>m_iter 正常遍历，当遍历到 m_trx_undo_rsegs 尾部时，重复 1；</li>\n</ol>\n<p>由于这个逻辑实在有点绕，下面结合 undo page 的内部结构再分析一下：</p>\n<img src=\"/images/innodb-trx-3.png\" width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>基本的逻辑如下：</p>\n<ol>\n<li>trx_rseg_t 上的 last_page_no、last_offset、last_trx_no 指向的是该回滚到对应的第一个未 purge 的 undo，也可以理解为 TRX_RSEG_HISTORY 最尾部（添加时都是添加到头部）的的一个 undo；</li>\n<li>拿到这个 undo 后，先在当前页去获取 undo record，如果无法获取，那么就需要通过 TRX_UNDO_PAGE_NODE 找到下一个 page；</li>\n<li>如果无法继续找到 undo record，那么说明当前 undo 已经结束了，那么需要根据 TRX_UNDO_HOSTORY_NODE 向前（添加时都是添加到头部）找到下一个 undo，这个时候找到的 undo 不能直接去获取 undo record，而是需要将 trx_rseg_t 指向该 page，然后重新放回优先队列；</li>\n</ol>\n<h3 id=\"记录清除\"><a href=\"#记录清除\" class=\"headerlink\" title=\"记录清除\"></a>记录清除</h3><p>准确的说 purge 过程包括了两个部分：清除记录和清除 undo。在 purge 推进过程中收集到的 undo rec 会被组装成 purge_node_t，通过后台线程进行清理。</p>\n<img src=\"/images/innodb-trx-4.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>基本的执行路径如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; row_purge_step</span><br><span class=\"line\">|    |--&gt; row_purge</span><br><span class=\"line\">|    |    |--&gt; row_purge_record  <span class=\"comment\">// row_purge_record_func, loop</span></span><br><span class=\"line\">|    |    |    |--&gt; row_purge_del_mark</span><br><span class=\"line\">|    |    |    |    |--&gt; row_purge_remove_multi_sec_if_poss</span><br><span class=\"line\">|    |    |    |    |--&gt; row_purge_remove_clust_if_poss</span><br><span class=\"line\">|    |    |    |    |    |--&gt; row_purge_remove_clust_if_poss_low</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; btr_cur_optimistic_delete</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; btr_cur_pessimistic_delete</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Undo-管理\"><a href=\"#Undo-管理\" class=\"headerlink\" title=\"Undo 管理\"></a>Undo 管理</h2><h3 id=\"Undo-分配\"><a href=\"#Undo-分配\" class=\"headerlink\" title=\"Undo 分配\"></a>Undo 分配</h3><p>关于 Undo 的分配，参考之前的文章。</p>\n<h3 id=\"Undo-回收\"><a href=\"#Undo-回收\" class=\"headerlink\" title=\"Undo 回收\"></a>Undo 回收</h3><p>前面在介绍 purge_sys 的时候，主要分析了 purge 过程中如何收集需要被 purge 的 undo 内容，这部分重点介绍 undo 的具体回收过程。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; trx_purge_truncate <span class=\"comment\">// 清理 undo 文件</span></span><br><span class=\"line\">|    |--&gt; trx_purge_truncate_history <span class=\"comment\">// 遍历 rsegs</span></span><br><span class=\"line\">|    |    |--&gt; trx_purge_truncate_rseg_history <span class=\"comment\">// 遍历 TRX_RSEG_HISTORY</span></span><br><span class=\"line\">|    |    |    |--&gt; trx_undo_truncate_start  <span class=\"comment\">// 正在处理的 trx_no</span></span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_empty_header_page</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_undo_free_page</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; trx_purge_free_segment  <span class=\"comment\">// 已经处理完的 trx_no</span></span><br><span class=\"line\">|    |    |    |    |--&gt; fseg_free_step_not_header <span class=\"comment\">// 清理除 header 外的内容</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; fseg_free_page_low</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_purge_remove_log_hdr <span class=\"comment\">// 从回滚段 TRX_RSEG_HISTORY 移除</span></span><br><span class=\"line\">|    |    |    |    |--&gt; fseg_free_step <span class=\"comment\">// 清理 page</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; fseg_free_page_low</span><br><span class=\"line\">|    |    |    |    |    |--&gt; fsp_free_seg_inode</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; trx_purge_remove_log_hdr</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p><a href=\"http://mysql.taobao.org/monthly/2015/04/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2015/04/01/</a></p>\n</blockquote>"},{"title":"perf 工具使用简介","date":"2020-07-18T12:07:30.000Z","_content":"\nperf 工具是 Linux 平台下进行性能分析的一个非常常用的工具，这篇文章对 perf 工具的使用进行一个简单的介绍。\n\n<!-- more -->\n\n## perf 工具介绍\n\nperf 是 Linux 平台下用来进行软件性能分析的工具。最初的时候叫做 Performance Counter，在 2.6.31 中第一次亮相，此后成为内核开发最为活跃的一个领域，在 2.6.32 中正式改名为 Performance Event，因为 perf 已不再仅仅作为 PMU 的抽象，而是能够处理所有的性能相关的事件。通过它，应用程序可以利用 PMU，tracepoint 和内核中的特殊计数器来进行性能统计。\n\nperf 不但可以分析指定应用程序的性能问题（per thread），也可以用来分析内核的性能问题，当然也可以同时分析应用代码和内核，从而全面理解应用程序中的性能瓶颈。使用 perf 可以分析程序运行期间发生的硬件事件，比如 instructions retired ，processor clock cycles 等；也可以分析软件事件，比如 Page Fault 和进程切换。\n\n## 命令\n\n下面简单介绍下 perf 工具常见的几种使用模式，更加丰富的使用说明，可以参考：\n\n> http://www.brendangregg.com/perf.html\n\n### perf stat\n\n执行一个命令并收集其运行过程中的各个数据，可以提供一个程序运行情况的总体概览，使用方式如下：\n\n```shell\nperf stat cmd\n```\n\n### perf top\n\n实时显示当前系统的性能统计信息。该命令主要用来观察整个系统当前的状态，比如可以通过查看该命令的输出来查看当前系统最耗时的内核函数或某个用户进程，也可以用来实时查看某个进程的运行情况，使用方式如下：\n\n```she\nperf top\n\nperf top -p $PID\n```\n\n### perf report\n\n记录单个函数级别的统计信息，常用来分析某个进程的热点，perf record 不会将结果显示出来，而是将结果输出到文件中，可以用 perf report 来进行解析，使用方式如下：\n\n```shell\nperf record -F 99 -p PID -g -- sleep 10\n\nperf report\n```\n\n","source":"_posts/linux/perf-linux.md","raw":"---\ntitle: perf 工具使用简介\ndate: 2020-07-18 20:07:30\ntags:\n- 工具\ncategories: \n- Linux\n\n---\n\nperf 工具是 Linux 平台下进行性能分析的一个非常常用的工具，这篇文章对 perf 工具的使用进行一个简单的介绍。\n\n<!-- more -->\n\n## perf 工具介绍\n\nperf 是 Linux 平台下用来进行软件性能分析的工具。最初的时候叫做 Performance Counter，在 2.6.31 中第一次亮相，此后成为内核开发最为活跃的一个领域，在 2.6.32 中正式改名为 Performance Event，因为 perf 已不再仅仅作为 PMU 的抽象，而是能够处理所有的性能相关的事件。通过它，应用程序可以利用 PMU，tracepoint 和内核中的特殊计数器来进行性能统计。\n\nperf 不但可以分析指定应用程序的性能问题（per thread），也可以用来分析内核的性能问题，当然也可以同时分析应用代码和内核，从而全面理解应用程序中的性能瓶颈。使用 perf 可以分析程序运行期间发生的硬件事件，比如 instructions retired ，processor clock cycles 等；也可以分析软件事件，比如 Page Fault 和进程切换。\n\n## 命令\n\n下面简单介绍下 perf 工具常见的几种使用模式，更加丰富的使用说明，可以参考：\n\n> http://www.brendangregg.com/perf.html\n\n### perf stat\n\n执行一个命令并收集其运行过程中的各个数据，可以提供一个程序运行情况的总体概览，使用方式如下：\n\n```shell\nperf stat cmd\n```\n\n### perf top\n\n实时显示当前系统的性能统计信息。该命令主要用来观察整个系统当前的状态，比如可以通过查看该命令的输出来查看当前系统最耗时的内核函数或某个用户进程，也可以用来实时查看某个进程的运行情况，使用方式如下：\n\n```she\nperf top\n\nperf top -p $PID\n```\n\n### perf report\n\n记录单个函数级别的统计信息，常用来分析某个进程的热点，perf record 不会将结果显示出来，而是将结果输出到文件中，可以用 perf report 来进行解析，使用方式如下：\n\n```shell\nperf record -F 99 -p PID -g -- sleep 10\n\nperf report\n```\n\n","slug":"linux/perf-linux","published":1,"updated":"2020-12-05T12:03:04.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4xl0011gugmgy465uil","content":"<p>perf 工具是 Linux 平台下进行性能分析的一个非常常用的工具，这篇文章对 perf 工具的使用进行一个简单的介绍。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"perf-工具介绍\"><a href=\"#perf-工具介绍\" class=\"headerlink\" title=\"perf 工具介绍\"></a>perf 工具介绍</h2><p>perf 是 Linux 平台下用来进行软件性能分析的工具。最初的时候叫做 Performance Counter，在 2.6.31 中第一次亮相，此后成为内核开发最为活跃的一个领域，在 2.6.32 中正式改名为 Performance Event，因为 perf 已不再仅仅作为 PMU 的抽象，而是能够处理所有的性能相关的事件。通过它，应用程序可以利用 PMU，tracepoint 和内核中的特殊计数器来进行性能统计。</p>\n<p>perf 不但可以分析指定应用程序的性能问题（per thread），也可以用来分析内核的性能问题，当然也可以同时分析应用代码和内核，从而全面理解应用程序中的性能瓶颈。使用 perf 可以分析程序运行期间发生的硬件事件，比如 instructions retired ，processor clock cycles 等；也可以分析软件事件，比如 Page Fault 和进程切换。</p>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p>下面简单介绍下 perf 工具常见的几种使用模式，更加丰富的使用说明，可以参考：</p>\n<blockquote>\n<p><a href=\"http://www.brendangregg.com/perf.html\" target=\"_blank\" rel=\"noopener\">http://www.brendangregg.com/perf.html</a></p>\n</blockquote>\n<h3 id=\"perf-stat\"><a href=\"#perf-stat\" class=\"headerlink\" title=\"perf stat\"></a>perf stat</h3><p>执行一个命令并收集其运行过程中的各个数据，可以提供一个程序运行情况的总体概览，使用方式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perf stat cmd</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"perf-top\"><a href=\"#perf-top\" class=\"headerlink\" title=\"perf top\"></a>perf top</h3><p>实时显示当前系统的性能统计信息。该命令主要用来观察整个系统当前的状态，比如可以通过查看该命令的输出来查看当前系统最耗时的内核函数或某个用户进程，也可以用来实时查看某个进程的运行情况，使用方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perf top</span><br><span class=\"line\"></span><br><span class=\"line\">perf top -p $PID</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"perf-report\"><a href=\"#perf-report\" class=\"headerlink\" title=\"perf report\"></a>perf report</h3><p>记录单个函数级别的统计信息，常用来分析某个进程的热点，perf record 不会将结果显示出来，而是将结果输出到文件中，可以用 perf report 来进行解析，使用方式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perf record -F 99 -p PID -g -- sleep 10</span><br><span class=\"line\"></span><br><span class=\"line\">perf report</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>perf 工具是 Linux 平台下进行性能分析的一个非常常用的工具，这篇文章对 perf 工具的使用进行一个简单的介绍。</p>","more":"<h2 id=\"perf-工具介绍\"><a href=\"#perf-工具介绍\" class=\"headerlink\" title=\"perf 工具介绍\"></a>perf 工具介绍</h2><p>perf 是 Linux 平台下用来进行软件性能分析的工具。最初的时候叫做 Performance Counter，在 2.6.31 中第一次亮相，此后成为内核开发最为活跃的一个领域，在 2.6.32 中正式改名为 Performance Event，因为 perf 已不再仅仅作为 PMU 的抽象，而是能够处理所有的性能相关的事件。通过它，应用程序可以利用 PMU，tracepoint 和内核中的特殊计数器来进行性能统计。</p>\n<p>perf 不但可以分析指定应用程序的性能问题（per thread），也可以用来分析内核的性能问题，当然也可以同时分析应用代码和内核，从而全面理解应用程序中的性能瓶颈。使用 perf 可以分析程序运行期间发生的硬件事件，比如 instructions retired ，processor clock cycles 等；也可以分析软件事件，比如 Page Fault 和进程切换。</p>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p>下面简单介绍下 perf 工具常见的几种使用模式，更加丰富的使用说明，可以参考：</p>\n<blockquote>\n<p><a href=\"http://www.brendangregg.com/perf.html\" target=\"_blank\" rel=\"noopener\">http://www.brendangregg.com/perf.html</a></p>\n</blockquote>\n<h3 id=\"perf-stat\"><a href=\"#perf-stat\" class=\"headerlink\" title=\"perf stat\"></a>perf stat</h3><p>执行一个命令并收集其运行过程中的各个数据，可以提供一个程序运行情况的总体概览，使用方式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perf stat cmd</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"perf-top\"><a href=\"#perf-top\" class=\"headerlink\" title=\"perf top\"></a>perf top</h3><p>实时显示当前系统的性能统计信息。该命令主要用来观察整个系统当前的状态，比如可以通过查看该命令的输出来查看当前系统最耗时的内核函数或某个用户进程，也可以用来实时查看某个进程的运行情况，使用方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perf top</span><br><span class=\"line\"></span><br><span class=\"line\">perf top -p $PID</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"perf-report\"><a href=\"#perf-report\" class=\"headerlink\" title=\"perf report\"></a>perf report</h3><p>记录单个函数级别的统计信息，常用来分析某个进程的热点，perf record 不会将结果显示出来，而是将结果输出到文件中，可以用 perf report 来进行解析，使用方式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perf record -F 99 -p PID -g -- sleep 10</span><br><span class=\"line\"></span><br><span class=\"line\">perf report</span><br></pre></td></tr></table></figure>"},{"title":"MySQL 词法&语法分析过程","date":"2020-12-05T11:19:25.000Z","_content":"\nMySQL 的词法分析部分采用了自己实现的方式，语法分析部分使用了 Yacc。关于 Yacc 的基本语法规则，可以先看看前面的参考文献。\n\n<!-- more -->\n\n## 基本流程\n\n首先以 MySQL 8.0 版本为例，介绍一下一条 SQL 在进行解析时候的基本流程：\n\n```c++\n1. mysql_parse(thd, &parser_state)\n\n2. parse_sql(thd, parser_state, NULL)\n\n3. thd->sql_parser()\n\n4. MYSQLparse(this, &root)\n\n    4.1. MYSQLlex\n\n    4.2. lex_one_token\n\n    4.3. find_key_word\n\n    4.4. consume_optimizer_hints\n\n    4.5. HINT_PARSER_parse\n\n5. lex->make_sql_cmd(root)\n\n    5.1. m_sql_cmd = root->make_cmd(thd)\n\n    5.2. opt_hints->contextualize(&pc)\n```\n\nServer 层调用词法&语法分析的入口在 `mysql_parse ` 方法中，最终调用 `MYSQLparse` 方法，生成 `Parse_tree_root` 对象。根据 sql_yacc.cc 文件头部的宏定义可以知道，`MYSQLparse` 对应的就是 sql_yacc.yy 中定义的语法分析规则。\n\n```c++\n// sql_yacc.cc\n\n#define yyparse         MYSQLparse\n#define yylex           MYSQLlex\n#define yylval          MYSQLlval\n#define yylloc          MYSQLlloc\n\n# define YYLEX yylex (&yylval, &yylloc, YYTHD)\n\nint\nyyparse (class THD *YYTHD, class Parse_tree_root **parse_tree)\n{\n  ...\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n  {\n    YYDPRINTF ((stderr, \"Reading a token: \"));\n    yychar = YYLEX;  //调用词法分析\n  }\n\n  ...\n}\n```\n\n前面已经提到，MySQL 中的词法分析没有采用 Lex 进行实现，而是自己手写了词法分析的逻辑，具体的代码在 sql_lex.cc 中。基本的逻辑如下：\n\n```c++\nint MYSQLlex(YYSTYPE *yacc_yylval, YYLTYPE *yylloc, THD *thd) {\n  auto *yylval = reinterpret_cast<Lexer_yystype *>(yacc_yylval);\n  Lex_input_stream *lip = &thd->m_parser_state->m_lip;\n  int token;\n    \n  ...\n\n  token = lex_one_token(yylval, thd);\n\n  ...\n}\n\nstatic int lex_one_token(Lexer_yystype *yylval, THD *thd) {\n  ...\n  uchar c = 0;\n  enum my_lex_states state;\n  Lex_input_stream *lip = &thd->m_parser_state->m_lip;\n  lip->yylval = yylval;\n  ...\n      \n  lip->start_token();\n  state = lip->next_state;\n  lip->next_state = MY_LEX_START;\n  for (;;) {\n    switch (state) {\n      case MY_LEX_START:  // Start of token\n        // Skip starting whitespace\n        while (state_map[c = lip->yyPeek()] == MY_LEX_SKIP) {\n          if (c == '\\n') lip->yylineno++;\n\n          lip->yySkip();\n        }\n\n        /* Start of real token */\n        lip->restart_token();\n        c = lip->yyGet();  // 此处读取到第1个有效字符，进入后续处理逻辑\n        state = state_map[c];\n        break;\n      ...\n    }\n  }\n  \n  ...\n}\n```\n\n以一个标识符的处理为例：\n\n```c++\n{\n    ...\n    case MY_LEX_IDENT:\n      const char *start;\n      if (use_mb(cs)) {\n        result_state = IDENT_QUOTED;\n        switch (my_mbcharlen(cs, lip->yyGetLast())) {\n          case 1:\n            break;\n          case 0:\n            if (my_mbmaxlenlen(cs) < 2) break;\n            /* else fall through */\n          default:\n            int l =\n                my_ismbchar(cs, lip->get_ptr() - 1, lip->get_end_of_query());\n            if (l == 0) {\n              state = MY_LEX_CHAR;\n              continue;\n            }\n            lip->skip_binary(l - 1);\n        }\n        while (ident_map[c = lip->yyGet()]) {\n          switch (my_mbcharlen(cs, c)) {\n            case 1:\n              break;\n            case 0:\n              if (my_mbmaxlenlen(cs) < 2) break;\n              /* else fall through */\n            default:\n              int l;\n              if ((l = my_ismbchar(cs, lip->get_ptr() - 1,\n                                   lip->get_end_of_query())) == 0)\n                break;\n              lip->skip_binary(l - 1);\n          }\n        }\n      } else {\n        for (result_state = c; ident_map[c = lip->yyGet()]; result_state |= c)\n          ;\n        /* If there were non-ASCII characters, mark that we must convert */\n        result_state = result_state & 0x80 ? IDENT_QUOTED : IDENT;\n      }\n      length = lip->yyLength();\n      start = lip->get_ptr();\n      if (lip->ignore_space) {\n        /*\n          If we find a space then this can't be an identifier. We notice this\n          below by checking start != lex->ptr.\n        */\n        for (; state_map[c] == MY_LEX_SKIP; c = lip->yyGet()) {\n          if (c == '\\n') lip->yylineno++;\n        }\n      }\n      if (start == lip->get_ptr() && c == '.' && ident_map[lip->yyPeek()])\n        lip->next_state = MY_LEX_IDENT_SEP;\n      else {  // '(' must follow directly if function\n        lip->yyUnget();\n        if ((tokval = find_keyword(lip, length, c == '('))) {\n          lip->next_state = MY_LEX_START;  // Allow signed numbers\n          return (tokval);                 // Was keyword\n        }\n        lip->yySkip();  // next state does a unget\n      }\n      yylval->lex_str = get_token(lip, 0, length);\n      \n      /*\n         Note: \"SELECT _bla AS 'alias'\"\n         _bla should be considered as a IDENT if charset haven't been found.\n         So we don't use MYF(MY_WME) with get_charset_by_csname to avoid\n         producing an error.\n      */\n      \n      if (yylval->lex_str.str[0] == '_') {\n        auto charset_name = yylval->lex_str.str + 1;\n        const CHARSET_INFO *cs =\n            get_charset_by_csname(charset_name, MY_CS_PRIMARY, MYF(0));\n        if (cs) {\n          lip->warn_on_deprecated_charset(cs, charset_name);\n          if (cs == &my_charset_utf8mb4_0900_ai_ci) {\n            /*\n              If cs is utf8mb4, and the collation of cs is the default\n              collation of utf8mb4, then update cs with a value of the\n              default_collation_for_utf8mb4 system variable:\n            */\n            cs = thd->variables.default_collation_for_utf8mb4;\n          }\n          yylval->charset = cs;\n          lip->m_underscore_cs = cs;\n      \n          lip->body_utf8_append(lip->m_cpp_text_start,\n                                lip->get_cpp_tok_start() + length);\n          return (UNDERSCORE_CHARSET);\n        }\n      }\n      \n      lip->body_utf8_append(lip->m_cpp_text_start);\n      \n      lip->body_utf8_append_literal(thd, &yylval->lex_str, cs,\n                                    lip->m_cpp_text_end);\n      \n      return (result_state);  // IDENT or IDENT_QUOTED\n    ...\n}\n```\n\n以一个简单的 update 语句为例：\n\n```sql\nupdate t1 set age = 10 where id = 1;\n```\n\n在 sql_yacc.yy 中，对于 update 语句的处理模式如下：\n\n```bash\nupdate_stmt:\n          opt_with_clause\n          UPDATE_SYM            /* #1 */\n          opt_low_priority      /* #2 */\n          opt_ignore            /* #3 */\n          table_reference_list  /* #4 */\n          SET_SYM               /* #5 */\n          update_list           /* #6 */\n          opt_where_clause      /* #7 */\n          opt_order_clause      /* #8 */\n          opt_simple_limit      /* #9 */\n          {\n            $$= NEW_PTN PT_update($1, $2, $3, $4, $5, $7.column_list, $7.value_list,\n                                  $8, $9, $10);\n          }\n        ;\n```\n\n一条 update 语句被切分为 10 个部分，对应生成 10 个参数：\n\n1. opt_with_clause: with子句\n2. UPDATE_SYM: update关键字\n3. opt_low_priority: \n4. opt_ignore: \n5. table_reference_list: 表信息\n6. SET_SYM: set关键字\n7. update_list: 更新内容\n8. opt_where_clause: where子句\n9. opt_order_clause: order子句\n10. opt_simple_limit: limit子句\n\n每一个部分经过处理都会生成一个 YYSTYPE 类型对象，YYSTYPE 是一个集合类，具体定义可以查看 parser_yystype.h，摘要部分信息如下：\n\n```c++\nunion YYSTYPE {\n  Lexer_yystype lexer;  // terminal values from the lexical scanner\n  ...\n\n  Mem_root_array_YY<PT_table_reference *> table_reference_list;\n  ...  \n\n  Item *item;\n  ...\n\n  struct {\n    class PT_item_list *column_list;\n    class PT_item_list *value_list;\n  } column_value_list_pair;\n  ...\n}\n```\n\n匹配到 update 语句模式的，经过语法分析，最终会生成一个 PT_update 类型的 Parse_tree_root。\n\n## 语法扩展\n\n## 参考文献\n\n> Yacc介绍：https://www.ibm.com/developerworks/cn/linux/sdk/lex/index.html\n>\n> 词法分析：https://www.cnblogs.com/nocode/archive/2011/08/03/2126726.html\n>\n> 语法分析：https://www.cnblogs.com/nocode/archive/2011/08/09/2132814.html\n>\n> http://mysql.taobao.org/monthly/2017/02/04/\n>\n> http://mysql.taobao.org/monthly/2017/04/02/\n>\n> SQL解析：https://tech.meituan.com/2018/05/20/sql-parser-used-in-mtdp.html\n>\n> http://www.orczhou.com/index.php/2012/11/mysql-innodb-source-code-optimization-1/\n>\n> https://www.jiqizhixin.com/articles/2018-12-12-17","source":"_posts/mysql/parser.md","raw":"---\ntitle: MySQL 词法&语法分析过程\ndate: 2020-12-05 19:19:25\ncategories: \n- MySQL\n\n---\n\nMySQL 的词法分析部分采用了自己实现的方式，语法分析部分使用了 Yacc。关于 Yacc 的基本语法规则，可以先看看前面的参考文献。\n\n<!-- more -->\n\n## 基本流程\n\n首先以 MySQL 8.0 版本为例，介绍一下一条 SQL 在进行解析时候的基本流程：\n\n```c++\n1. mysql_parse(thd, &parser_state)\n\n2. parse_sql(thd, parser_state, NULL)\n\n3. thd->sql_parser()\n\n4. MYSQLparse(this, &root)\n\n    4.1. MYSQLlex\n\n    4.2. lex_one_token\n\n    4.3. find_key_word\n\n    4.4. consume_optimizer_hints\n\n    4.5. HINT_PARSER_parse\n\n5. lex->make_sql_cmd(root)\n\n    5.1. m_sql_cmd = root->make_cmd(thd)\n\n    5.2. opt_hints->contextualize(&pc)\n```\n\nServer 层调用词法&语法分析的入口在 `mysql_parse ` 方法中，最终调用 `MYSQLparse` 方法，生成 `Parse_tree_root` 对象。根据 sql_yacc.cc 文件头部的宏定义可以知道，`MYSQLparse` 对应的就是 sql_yacc.yy 中定义的语法分析规则。\n\n```c++\n// sql_yacc.cc\n\n#define yyparse         MYSQLparse\n#define yylex           MYSQLlex\n#define yylval          MYSQLlval\n#define yylloc          MYSQLlloc\n\n# define YYLEX yylex (&yylval, &yylloc, YYTHD)\n\nint\nyyparse (class THD *YYTHD, class Parse_tree_root **parse_tree)\n{\n  ...\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n  {\n    YYDPRINTF ((stderr, \"Reading a token: \"));\n    yychar = YYLEX;  //调用词法分析\n  }\n\n  ...\n}\n```\n\n前面已经提到，MySQL 中的词法分析没有采用 Lex 进行实现，而是自己手写了词法分析的逻辑，具体的代码在 sql_lex.cc 中。基本的逻辑如下：\n\n```c++\nint MYSQLlex(YYSTYPE *yacc_yylval, YYLTYPE *yylloc, THD *thd) {\n  auto *yylval = reinterpret_cast<Lexer_yystype *>(yacc_yylval);\n  Lex_input_stream *lip = &thd->m_parser_state->m_lip;\n  int token;\n    \n  ...\n\n  token = lex_one_token(yylval, thd);\n\n  ...\n}\n\nstatic int lex_one_token(Lexer_yystype *yylval, THD *thd) {\n  ...\n  uchar c = 0;\n  enum my_lex_states state;\n  Lex_input_stream *lip = &thd->m_parser_state->m_lip;\n  lip->yylval = yylval;\n  ...\n      \n  lip->start_token();\n  state = lip->next_state;\n  lip->next_state = MY_LEX_START;\n  for (;;) {\n    switch (state) {\n      case MY_LEX_START:  // Start of token\n        // Skip starting whitespace\n        while (state_map[c = lip->yyPeek()] == MY_LEX_SKIP) {\n          if (c == '\\n') lip->yylineno++;\n\n          lip->yySkip();\n        }\n\n        /* Start of real token */\n        lip->restart_token();\n        c = lip->yyGet();  // 此处读取到第1个有效字符，进入后续处理逻辑\n        state = state_map[c];\n        break;\n      ...\n    }\n  }\n  \n  ...\n}\n```\n\n以一个标识符的处理为例：\n\n```c++\n{\n    ...\n    case MY_LEX_IDENT:\n      const char *start;\n      if (use_mb(cs)) {\n        result_state = IDENT_QUOTED;\n        switch (my_mbcharlen(cs, lip->yyGetLast())) {\n          case 1:\n            break;\n          case 0:\n            if (my_mbmaxlenlen(cs) < 2) break;\n            /* else fall through */\n          default:\n            int l =\n                my_ismbchar(cs, lip->get_ptr() - 1, lip->get_end_of_query());\n            if (l == 0) {\n              state = MY_LEX_CHAR;\n              continue;\n            }\n            lip->skip_binary(l - 1);\n        }\n        while (ident_map[c = lip->yyGet()]) {\n          switch (my_mbcharlen(cs, c)) {\n            case 1:\n              break;\n            case 0:\n              if (my_mbmaxlenlen(cs) < 2) break;\n              /* else fall through */\n            default:\n              int l;\n              if ((l = my_ismbchar(cs, lip->get_ptr() - 1,\n                                   lip->get_end_of_query())) == 0)\n                break;\n              lip->skip_binary(l - 1);\n          }\n        }\n      } else {\n        for (result_state = c; ident_map[c = lip->yyGet()]; result_state |= c)\n          ;\n        /* If there were non-ASCII characters, mark that we must convert */\n        result_state = result_state & 0x80 ? IDENT_QUOTED : IDENT;\n      }\n      length = lip->yyLength();\n      start = lip->get_ptr();\n      if (lip->ignore_space) {\n        /*\n          If we find a space then this can't be an identifier. We notice this\n          below by checking start != lex->ptr.\n        */\n        for (; state_map[c] == MY_LEX_SKIP; c = lip->yyGet()) {\n          if (c == '\\n') lip->yylineno++;\n        }\n      }\n      if (start == lip->get_ptr() && c == '.' && ident_map[lip->yyPeek()])\n        lip->next_state = MY_LEX_IDENT_SEP;\n      else {  // '(' must follow directly if function\n        lip->yyUnget();\n        if ((tokval = find_keyword(lip, length, c == '('))) {\n          lip->next_state = MY_LEX_START;  // Allow signed numbers\n          return (tokval);                 // Was keyword\n        }\n        lip->yySkip();  // next state does a unget\n      }\n      yylval->lex_str = get_token(lip, 0, length);\n      \n      /*\n         Note: \"SELECT _bla AS 'alias'\"\n         _bla should be considered as a IDENT if charset haven't been found.\n         So we don't use MYF(MY_WME) with get_charset_by_csname to avoid\n         producing an error.\n      */\n      \n      if (yylval->lex_str.str[0] == '_') {\n        auto charset_name = yylval->lex_str.str + 1;\n        const CHARSET_INFO *cs =\n            get_charset_by_csname(charset_name, MY_CS_PRIMARY, MYF(0));\n        if (cs) {\n          lip->warn_on_deprecated_charset(cs, charset_name);\n          if (cs == &my_charset_utf8mb4_0900_ai_ci) {\n            /*\n              If cs is utf8mb4, and the collation of cs is the default\n              collation of utf8mb4, then update cs with a value of the\n              default_collation_for_utf8mb4 system variable:\n            */\n            cs = thd->variables.default_collation_for_utf8mb4;\n          }\n          yylval->charset = cs;\n          lip->m_underscore_cs = cs;\n      \n          lip->body_utf8_append(lip->m_cpp_text_start,\n                                lip->get_cpp_tok_start() + length);\n          return (UNDERSCORE_CHARSET);\n        }\n      }\n      \n      lip->body_utf8_append(lip->m_cpp_text_start);\n      \n      lip->body_utf8_append_literal(thd, &yylval->lex_str, cs,\n                                    lip->m_cpp_text_end);\n      \n      return (result_state);  // IDENT or IDENT_QUOTED\n    ...\n}\n```\n\n以一个简单的 update 语句为例：\n\n```sql\nupdate t1 set age = 10 where id = 1;\n```\n\n在 sql_yacc.yy 中，对于 update 语句的处理模式如下：\n\n```bash\nupdate_stmt:\n          opt_with_clause\n          UPDATE_SYM            /* #1 */\n          opt_low_priority      /* #2 */\n          opt_ignore            /* #3 */\n          table_reference_list  /* #4 */\n          SET_SYM               /* #5 */\n          update_list           /* #6 */\n          opt_where_clause      /* #7 */\n          opt_order_clause      /* #8 */\n          opt_simple_limit      /* #9 */\n          {\n            $$= NEW_PTN PT_update($1, $2, $3, $4, $5, $7.column_list, $7.value_list,\n                                  $8, $9, $10);\n          }\n        ;\n```\n\n一条 update 语句被切分为 10 个部分，对应生成 10 个参数：\n\n1. opt_with_clause: with子句\n2. UPDATE_SYM: update关键字\n3. opt_low_priority: \n4. opt_ignore: \n5. table_reference_list: 表信息\n6. SET_SYM: set关键字\n7. update_list: 更新内容\n8. opt_where_clause: where子句\n9. opt_order_clause: order子句\n10. opt_simple_limit: limit子句\n\n每一个部分经过处理都会生成一个 YYSTYPE 类型对象，YYSTYPE 是一个集合类，具体定义可以查看 parser_yystype.h，摘要部分信息如下：\n\n```c++\nunion YYSTYPE {\n  Lexer_yystype lexer;  // terminal values from the lexical scanner\n  ...\n\n  Mem_root_array_YY<PT_table_reference *> table_reference_list;\n  ...  \n\n  Item *item;\n  ...\n\n  struct {\n    class PT_item_list *column_list;\n    class PT_item_list *value_list;\n  } column_value_list_pair;\n  ...\n}\n```\n\n匹配到 update 语句模式的，经过语法分析，最终会生成一个 PT_update 类型的 Parse_tree_root。\n\n## 语法扩展\n\n## 参考文献\n\n> Yacc介绍：https://www.ibm.com/developerworks/cn/linux/sdk/lex/index.html\n>\n> 词法分析：https://www.cnblogs.com/nocode/archive/2011/08/03/2126726.html\n>\n> 语法分析：https://www.cnblogs.com/nocode/archive/2011/08/09/2132814.html\n>\n> http://mysql.taobao.org/monthly/2017/02/04/\n>\n> http://mysql.taobao.org/monthly/2017/04/02/\n>\n> SQL解析：https://tech.meituan.com/2018/05/20/sql-parser-used-in-mtdp.html\n>\n> http://www.orczhou.com/index.php/2012/11/mysql-innodb-source-code-optimization-1/\n>\n> https://www.jiqizhixin.com/articles/2018-12-12-17","slug":"mysql/parser","published":1,"updated":"2020-12-05T13:52:43.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4xm0014gugm4gdlgo4v","content":"<p>MySQL 的词法分析部分采用了自己实现的方式，语法分析部分使用了 Yacc。关于 Yacc 的基本语法规则，可以先看看前面的参考文献。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"基本流程\"><a href=\"#基本流程\" class=\"headerlink\" title=\"基本流程\"></a>基本流程</h2><p>首先以 MySQL 8.0 版本为例，介绍一下一条 SQL 在进行解析时候的基本流程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> mysql_parse(thd, &amp;parser_state)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> parse_sql(thd, parser_state, <span class=\"literal\">NULL</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span> thd-&gt;sql_parser()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4.</span> MYSQLparse(<span class=\"keyword\">this</span>, &amp;root)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">4.1</span>. MYSQLlex</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">4.2</span>. lex_one_token</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">4.3</span>. find_key_word</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">4.4</span>. consume_optimizer_hints</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">4.5</span>. HINT_PARSER_parse</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5.</span> lex-&gt;make_sql_cmd(root)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">5.1</span>. m_sql_cmd = root-&gt;make_cmd(thd)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">5.2</span>. opt_hints-&gt;contextualize(&amp;pc)</span><br></pre></td></tr></table></figure>\n\n<p>Server 层调用词法&amp;语法分析的入口在 <code>mysql_parse</code> 方法中，最终调用 <code>MYSQLparse</code> 方法，生成 <code>Parse_tree_root</code> 对象。根据 sql_yacc.cc 文件头部的宏定义可以知道，<code>MYSQLparse</code> 对应的就是 sql_yacc.yy 中定义的语法分析规则。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sql_yacc.cc</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> yyparse         MYSQLparse</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> yylex           MYSQLlex</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> yylval          MYSQLlval</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> yylloc          MYSQLlloc</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">define</span> YYLEX yylex (&amp;yylval, &amp;yylloc, YYTHD)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span></span><br><span class=\"line\">yyparse (class THD *YYTHD, class Parse_tree_root **parse_tree)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (yychar == YYEMPTY)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    YYDPRINTF ((<span class=\"built_in\">stderr</span>, <span class=\"string\">\"Reading a token: \"</span>));</span><br><span class=\"line\">    yychar = YYLEX;  <span class=\"comment\">//调用词法分析</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前面已经提到，MySQL 中的词法分析没有采用 Lex 进行实现，而是自己手写了词法分析的逻辑，具体的代码在 sql_lex.cc 中。基本的逻辑如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MYSQLlex</span><span class=\"params\">(YYSTYPE *yacc_yylval, YYLTYPE *yylloc, THD *thd)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> *yylval = <span class=\"keyword\">reinterpret_cast</span>&lt;Lexer_yystype *&gt;(yacc_yylval);</span><br><span class=\"line\">  Lex_input_stream *lip = &amp;thd-&gt;m_parser_state-&gt;m_lip;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> token;</span><br><span class=\"line\">    </span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  token = lex_one_token(yylval, thd);</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">lex_one_token</span><span class=\"params\">(Lexer_yystype *yylval, THD *thd)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  uchar c = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">enum</span> my_lex_states state;</span><br><span class=\"line\">  Lex_input_stream *lip = &amp;thd-&gt;m_parser_state-&gt;m_lip;</span><br><span class=\"line\">  lip-&gt;yylval = yylval;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">      </span><br><span class=\"line\">  lip-&gt;start_token();</span><br><span class=\"line\">  state = lip-&gt;next_state;</span><br><span class=\"line\">  lip-&gt;next_state = MY_LEX_START;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (state) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> MY_LEX_START:  <span class=\"comment\">// Start of token</span></span><br><span class=\"line\">        <span class=\"comment\">// Skip starting whitespace</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (state_map[c = lip-&gt;yyPeek()] == MY_LEX_SKIP) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (c == <span class=\"string\">'\\n'</span>) lip-&gt;yylineno++;</span><br><span class=\"line\"></span><br><span class=\"line\">          lip-&gt;yySkip();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Start of real token */</span></span><br><span class=\"line\">        lip-&gt;restart_token();</span><br><span class=\"line\">        c = lip-&gt;yyGet();  <span class=\"comment\">// 此处读取到第1个有效字符，进入后续处理逻辑</span></span><br><span class=\"line\">        state = state_map[c];</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以一个标识符的处理为例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MY_LEX_IDENT:</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *start;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (use_mb(cs)) &#123;</span><br><span class=\"line\">        result_state = IDENT_QUOTED;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (my_mbcharlen(cs, lip-&gt;yyGetLast())) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (my_mbmaxlenlen(cs) &lt; <span class=\"number\">2</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">/* else fall through */</span></span><br><span class=\"line\">          <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">int</span> l =</span><br><span class=\"line\">                my_ismbchar(cs, lip-&gt;get_ptr() - <span class=\"number\">1</span>, lip-&gt;get_end_of_query());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              state = MY_LEX_CHAR;</span><br><span class=\"line\">              <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            lip-&gt;skip_binary(l - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ident_map[c = lip-&gt;yyGet()]) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">switch</span> (my_mbcharlen(cs, c)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (my_mbmaxlenlen(cs) &lt; <span class=\"number\">2</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              <span class=\"comment\">/* else fall through */</span></span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">              <span class=\"keyword\">int</span> l;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> ((l = my_ismbchar(cs, lip-&gt;get_ptr() - <span class=\"number\">1</span>,</span><br><span class=\"line\">                                   lip-&gt;get_end_of_query())) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              lip-&gt;skip_binary(l - <span class=\"number\">1</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (result_state = c; ident_map[c = lip-&gt;yyGet()]; result_state |= c)</span><br><span class=\"line\">          ;</span><br><span class=\"line\">        <span class=\"comment\">/* If there were non-ASCII characters, mark that we must convert */</span></span><br><span class=\"line\">        result_state = result_state &amp; <span class=\"number\">0x80</span> ? IDENT_QUOTED : IDENT;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      length = lip-&gt;yyLength();</span><br><span class=\"line\">      start = lip-&gt;get_ptr();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (lip-&gt;ignore_space) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">          If we find a space then this can't be an identifier. We notice this</span></span><br><span class=\"line\"><span class=\"comment\">          below by checking start != lex-&gt;ptr.</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; state_map[c] == MY_LEX_SKIP; c = lip-&gt;yyGet()) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (c == <span class=\"string\">'\\n'</span>) lip-&gt;yylineno++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (start == lip-&gt;get_ptr() &amp;&amp; c == <span class=\"string\">'.'</span> &amp;&amp; ident_map[lip-&gt;yyPeek()])</span><br><span class=\"line\">        lip-&gt;next_state = MY_LEX_IDENT_SEP;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">// '(' must follow directly if function</span></span><br><span class=\"line\">        lip-&gt;yyUnget();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tokval = find_keyword(lip, length, c == <span class=\"string\">'('</span>))) &#123;</span><br><span class=\"line\">          lip-&gt;next_state = MY_LEX_START;  <span class=\"comment\">// Allow signed numbers</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> (tokval);                 <span class=\"comment\">// Was keyword</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lip-&gt;yySkip();  <span class=\"comment\">// next state does a unget</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      yylval-&gt;lex_str = get_token(lip, <span class=\"number\">0</span>, length);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         Note: \"SELECT _bla AS 'alias'\"</span></span><br><span class=\"line\"><span class=\"comment\">         _bla should be considered as a IDENT if charset haven't been found.</span></span><br><span class=\"line\"><span class=\"comment\">         So we don't use MYF(MY_WME) with get_charset_by_csname to avoid</span></span><br><span class=\"line\"><span class=\"comment\">         producing an error.</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (yylval-&gt;lex_str.str[<span class=\"number\">0</span>] == <span class=\"string\">'_'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> charset_name = yylval-&gt;lex_str.str + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> CHARSET_INFO *cs =</span><br><span class=\"line\">            get_charset_by_csname(charset_name, MY_CS_PRIMARY, MYF(<span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cs) &#123;</span><br><span class=\"line\">          lip-&gt;warn_on_deprecated_charset(cs, charset_name);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (cs == &amp;my_charset_utf8mb4_0900_ai_ci) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">              If cs is utf8mb4, and the collation of cs is the default</span></span><br><span class=\"line\"><span class=\"comment\">              collation of utf8mb4, then update cs with a value of the</span></span><br><span class=\"line\"><span class=\"comment\">              default_collation_for_utf8mb4 system variable:</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            cs = thd-&gt;variables.default_collation_for_utf8mb4;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          yylval-&gt;charset = cs;</span><br><span class=\"line\">          lip-&gt;m_underscore_cs = cs;</span><br><span class=\"line\">      </span><br><span class=\"line\">          lip-&gt;body_utf8_append(lip-&gt;m_cpp_text_start,</span><br><span class=\"line\">                                lip-&gt;get_cpp_tok_start() + length);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> (UNDERSCORE_CHARSET);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      lip-&gt;body_utf8_append(lip-&gt;m_cpp_text_start);</span><br><span class=\"line\">      </span><br><span class=\"line\">      lip-&gt;body_utf8_append_literal(thd, &amp;yylval-&gt;lex_str, cs,</span><br><span class=\"line\">                                    lip-&gt;m_cpp_text_end);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">return</span> (result_state);  <span class=\"comment\">// IDENT or IDENT_QUOTED</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以一个简单的 update 语句为例：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">update</span> t1 <span class=\"keyword\">set</span> age = <span class=\"number\">10</span> <span class=\"keyword\">where</span> <span class=\"keyword\">id</span> = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在 sql_yacc.yy 中，对于 update 语句的处理模式如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update_stmt:</span><br><span class=\"line\">          opt_with_clause</span><br><span class=\"line\">          UPDATE_SYM            /* <span class=\"comment\">#1 */</span></span><br><span class=\"line\">          opt_low_priority      /* <span class=\"comment\">#2 */</span></span><br><span class=\"line\">          opt_ignore            /* <span class=\"comment\">#3 */</span></span><br><span class=\"line\">          table_reference_list  /* <span class=\"comment\">#4 */</span></span><br><span class=\"line\">          SET_SYM               /* <span class=\"comment\">#5 */</span></span><br><span class=\"line\">          update_list           /* <span class=\"comment\">#6 */</span></span><br><span class=\"line\">          opt_where_clause      /* <span class=\"comment\">#7 */</span></span><br><span class=\"line\">          opt_order_clause      /* <span class=\"comment\">#8 */</span></span><br><span class=\"line\">          opt_simple_limit      /* <span class=\"comment\">#9 */</span></span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            $$= NEW_PTN PT_update(<span class=\"variable\">$1</span>, <span class=\"variable\">$2</span>, <span class=\"variable\">$3</span>, <span class=\"variable\">$4</span>, <span class=\"variable\">$5</span>, <span class=\"variable\">$7</span>.column_list, <span class=\"variable\">$7</span>.value_list,</span><br><span class=\"line\">                                  <span class=\"variable\">$8</span>, <span class=\"variable\">$9</span>, <span class=\"variable\">$10</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ;</span><br></pre></td></tr></table></figure>\n\n<p>一条 update 语句被切分为 10 个部分，对应生成 10 个参数：</p>\n<ol>\n<li>opt_with_clause: with子句</li>\n<li>UPDATE_SYM: update关键字</li>\n<li>opt_low_priority: </li>\n<li>opt_ignore: </li>\n<li>table_reference_list: 表信息</li>\n<li>SET_SYM: set关键字</li>\n<li>update_list: 更新内容</li>\n<li>opt_where_clause: where子句</li>\n<li>opt_order_clause: order子句</li>\n<li>opt_simple_limit: limit子句</li>\n</ol>\n<p>每一个部分经过处理都会生成一个 YYSTYPE 类型对象，YYSTYPE 是一个集合类，具体定义可以查看 parser_yystype.h，摘要部分信息如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">union</span> YYSTYPE &#123;</span><br><span class=\"line\">  Lexer_yystype lexer;  <span class=\"comment\">// terminal values from the lexical scanner</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  Mem_root_array_YY&lt;PT_table_reference *&gt; table_reference_list;</span><br><span class=\"line\">  ...  </span><br><span class=\"line\"></span><br><span class=\"line\">  Item *item;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PT_item_list</span> *<span class=\"title\">column_list</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PT_item_list</span> *<span class=\"title\">value_list</span>;</span></span><br><span class=\"line\">  &#125; column_value_list_pair;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>匹配到 update 语句模式的，经过语法分析，最终会生成一个 PT_update 类型的 Parse_tree_root。</p>\n<h2 id=\"语法扩展\"><a href=\"#语法扩展\" class=\"headerlink\" title=\"语法扩展\"></a>语法扩展</h2><h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>Yacc介绍：<a href=\"https://www.ibm.com/developerworks/cn/linux/sdk/lex/index.html\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/cn/linux/sdk/lex/index.html</a></p>\n<p>词法分析：<a href=\"https://www.cnblogs.com/nocode/archive/2011/08/03/2126726.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/nocode/archive/2011/08/03/2126726.html</a></p>\n<p>语法分析：<a href=\"https://www.cnblogs.com/nocode/archive/2011/08/09/2132814.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/nocode/archive/2011/08/09/2132814.html</a></p>\n<p><a href=\"http://mysql.taobao.org/monthly/2017/02/04/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2017/02/04/</a></p>\n<p><a href=\"http://mysql.taobao.org/monthly/2017/04/02/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2017/04/02/</a></p>\n<p>SQL解析：<a href=\"https://tech.meituan.com/2018/05/20/sql-parser-used-in-mtdp.html\" target=\"_blank\" rel=\"noopener\">https://tech.meituan.com/2018/05/20/sql-parser-used-in-mtdp.html</a></p>\n<p><a href=\"http://www.orczhou.com/index.php/2012/11/mysql-innodb-source-code-optimization-1/\" target=\"_blank\" rel=\"noopener\">http://www.orczhou.com/index.php/2012/11/mysql-innodb-source-code-optimization-1/</a></p>\n<p><a href=\"https://www.jiqizhixin.com/articles/2018-12-12-17\" target=\"_blank\" rel=\"noopener\">https://www.jiqizhixin.com/articles/2018-12-12-17</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>MySQL 的词法分析部分采用了自己实现的方式，语法分析部分使用了 Yacc。关于 Yacc 的基本语法规则，可以先看看前面的参考文献。</p>","more":"<h2 id=\"基本流程\"><a href=\"#基本流程\" class=\"headerlink\" title=\"基本流程\"></a>基本流程</h2><p>首先以 MySQL 8.0 版本为例，介绍一下一条 SQL 在进行解析时候的基本流程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> mysql_parse(thd, &amp;parser_state)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> parse_sql(thd, parser_state, <span class=\"literal\">NULL</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span> thd-&gt;sql_parser()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4.</span> MYSQLparse(<span class=\"keyword\">this</span>, &amp;root)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">4.1</span>. MYSQLlex</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">4.2</span>. lex_one_token</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">4.3</span>. find_key_word</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">4.4</span>. consume_optimizer_hints</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">4.5</span>. HINT_PARSER_parse</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5.</span> lex-&gt;make_sql_cmd(root)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">5.1</span>. m_sql_cmd = root-&gt;make_cmd(thd)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">5.2</span>. opt_hints-&gt;contextualize(&amp;pc)</span><br></pre></td></tr></table></figure>\n\n<p>Server 层调用词法&amp;语法分析的入口在 <code>mysql_parse</code> 方法中，最终调用 <code>MYSQLparse</code> 方法，生成 <code>Parse_tree_root</code> 对象。根据 sql_yacc.cc 文件头部的宏定义可以知道，<code>MYSQLparse</code> 对应的就是 sql_yacc.yy 中定义的语法分析规则。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sql_yacc.cc</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> yyparse         MYSQLparse</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> yylex           MYSQLlex</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> yylval          MYSQLlval</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> yylloc          MYSQLlloc</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">define</span> YYLEX yylex (&amp;yylval, &amp;yylloc, YYTHD)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span></span><br><span class=\"line\">yyparse (class THD *YYTHD, class Parse_tree_root **parse_tree)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (yychar == YYEMPTY)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    YYDPRINTF ((<span class=\"built_in\">stderr</span>, <span class=\"string\">\"Reading a token: \"</span>));</span><br><span class=\"line\">    yychar = YYLEX;  <span class=\"comment\">//调用词法分析</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前面已经提到，MySQL 中的词法分析没有采用 Lex 进行实现，而是自己手写了词法分析的逻辑，具体的代码在 sql_lex.cc 中。基本的逻辑如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MYSQLlex</span><span class=\"params\">(YYSTYPE *yacc_yylval, YYLTYPE *yylloc, THD *thd)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> *yylval = <span class=\"keyword\">reinterpret_cast</span>&lt;Lexer_yystype *&gt;(yacc_yylval);</span><br><span class=\"line\">  Lex_input_stream *lip = &amp;thd-&gt;m_parser_state-&gt;m_lip;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> token;</span><br><span class=\"line\">    </span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  token = lex_one_token(yylval, thd);</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">lex_one_token</span><span class=\"params\">(Lexer_yystype *yylval, THD *thd)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  uchar c = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">enum</span> my_lex_states state;</span><br><span class=\"line\">  Lex_input_stream *lip = &amp;thd-&gt;m_parser_state-&gt;m_lip;</span><br><span class=\"line\">  lip-&gt;yylval = yylval;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">      </span><br><span class=\"line\">  lip-&gt;start_token();</span><br><span class=\"line\">  state = lip-&gt;next_state;</span><br><span class=\"line\">  lip-&gt;next_state = MY_LEX_START;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (state) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> MY_LEX_START:  <span class=\"comment\">// Start of token</span></span><br><span class=\"line\">        <span class=\"comment\">// Skip starting whitespace</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (state_map[c = lip-&gt;yyPeek()] == MY_LEX_SKIP) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (c == <span class=\"string\">'\\n'</span>) lip-&gt;yylineno++;</span><br><span class=\"line\"></span><br><span class=\"line\">          lip-&gt;yySkip();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Start of real token */</span></span><br><span class=\"line\">        lip-&gt;restart_token();</span><br><span class=\"line\">        c = lip-&gt;yyGet();  <span class=\"comment\">// 此处读取到第1个有效字符，进入后续处理逻辑</span></span><br><span class=\"line\">        state = state_map[c];</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以一个标识符的处理为例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MY_LEX_IDENT:</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *start;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (use_mb(cs)) &#123;</span><br><span class=\"line\">        result_state = IDENT_QUOTED;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (my_mbcharlen(cs, lip-&gt;yyGetLast())) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (my_mbmaxlenlen(cs) &lt; <span class=\"number\">2</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">/* else fall through */</span></span><br><span class=\"line\">          <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">int</span> l =</span><br><span class=\"line\">                my_ismbchar(cs, lip-&gt;get_ptr() - <span class=\"number\">1</span>, lip-&gt;get_end_of_query());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              state = MY_LEX_CHAR;</span><br><span class=\"line\">              <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            lip-&gt;skip_binary(l - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ident_map[c = lip-&gt;yyGet()]) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">switch</span> (my_mbcharlen(cs, c)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (my_mbmaxlenlen(cs) &lt; <span class=\"number\">2</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              <span class=\"comment\">/* else fall through */</span></span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">              <span class=\"keyword\">int</span> l;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> ((l = my_ismbchar(cs, lip-&gt;get_ptr() - <span class=\"number\">1</span>,</span><br><span class=\"line\">                                   lip-&gt;get_end_of_query())) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              lip-&gt;skip_binary(l - <span class=\"number\">1</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (result_state = c; ident_map[c = lip-&gt;yyGet()]; result_state |= c)</span><br><span class=\"line\">          ;</span><br><span class=\"line\">        <span class=\"comment\">/* If there were non-ASCII characters, mark that we must convert */</span></span><br><span class=\"line\">        result_state = result_state &amp; <span class=\"number\">0x80</span> ? IDENT_QUOTED : IDENT;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      length = lip-&gt;yyLength();</span><br><span class=\"line\">      start = lip-&gt;get_ptr();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (lip-&gt;ignore_space) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">          If we find a space then this can't be an identifier. We notice this</span></span><br><span class=\"line\"><span class=\"comment\">          below by checking start != lex-&gt;ptr.</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; state_map[c] == MY_LEX_SKIP; c = lip-&gt;yyGet()) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (c == <span class=\"string\">'\\n'</span>) lip-&gt;yylineno++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (start == lip-&gt;get_ptr() &amp;&amp; c == <span class=\"string\">'.'</span> &amp;&amp; ident_map[lip-&gt;yyPeek()])</span><br><span class=\"line\">        lip-&gt;next_state = MY_LEX_IDENT_SEP;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">// '(' must follow directly if function</span></span><br><span class=\"line\">        lip-&gt;yyUnget();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tokval = find_keyword(lip, length, c == <span class=\"string\">'('</span>))) &#123;</span><br><span class=\"line\">          lip-&gt;next_state = MY_LEX_START;  <span class=\"comment\">// Allow signed numbers</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> (tokval);                 <span class=\"comment\">// Was keyword</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lip-&gt;yySkip();  <span class=\"comment\">// next state does a unget</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      yylval-&gt;lex_str = get_token(lip, <span class=\"number\">0</span>, length);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         Note: \"SELECT _bla AS 'alias'\"</span></span><br><span class=\"line\"><span class=\"comment\">         _bla should be considered as a IDENT if charset haven't been found.</span></span><br><span class=\"line\"><span class=\"comment\">         So we don't use MYF(MY_WME) with get_charset_by_csname to avoid</span></span><br><span class=\"line\"><span class=\"comment\">         producing an error.</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (yylval-&gt;lex_str.str[<span class=\"number\">0</span>] == <span class=\"string\">'_'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> charset_name = yylval-&gt;lex_str.str + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> CHARSET_INFO *cs =</span><br><span class=\"line\">            get_charset_by_csname(charset_name, MY_CS_PRIMARY, MYF(<span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cs) &#123;</span><br><span class=\"line\">          lip-&gt;warn_on_deprecated_charset(cs, charset_name);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (cs == &amp;my_charset_utf8mb4_0900_ai_ci) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">              If cs is utf8mb4, and the collation of cs is the default</span></span><br><span class=\"line\"><span class=\"comment\">              collation of utf8mb4, then update cs with a value of the</span></span><br><span class=\"line\"><span class=\"comment\">              default_collation_for_utf8mb4 system variable:</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            cs = thd-&gt;variables.default_collation_for_utf8mb4;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          yylval-&gt;charset = cs;</span><br><span class=\"line\">          lip-&gt;m_underscore_cs = cs;</span><br><span class=\"line\">      </span><br><span class=\"line\">          lip-&gt;body_utf8_append(lip-&gt;m_cpp_text_start,</span><br><span class=\"line\">                                lip-&gt;get_cpp_tok_start() + length);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> (UNDERSCORE_CHARSET);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      lip-&gt;body_utf8_append(lip-&gt;m_cpp_text_start);</span><br><span class=\"line\">      </span><br><span class=\"line\">      lip-&gt;body_utf8_append_literal(thd, &amp;yylval-&gt;lex_str, cs,</span><br><span class=\"line\">                                    lip-&gt;m_cpp_text_end);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">return</span> (result_state);  <span class=\"comment\">// IDENT or IDENT_QUOTED</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以一个简单的 update 语句为例：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">update</span> t1 <span class=\"keyword\">set</span> age = <span class=\"number\">10</span> <span class=\"keyword\">where</span> <span class=\"keyword\">id</span> = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在 sql_yacc.yy 中，对于 update 语句的处理模式如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update_stmt:</span><br><span class=\"line\">          opt_with_clause</span><br><span class=\"line\">          UPDATE_SYM            /* <span class=\"comment\">#1 */</span></span><br><span class=\"line\">          opt_low_priority      /* <span class=\"comment\">#2 */</span></span><br><span class=\"line\">          opt_ignore            /* <span class=\"comment\">#3 */</span></span><br><span class=\"line\">          table_reference_list  /* <span class=\"comment\">#4 */</span></span><br><span class=\"line\">          SET_SYM               /* <span class=\"comment\">#5 */</span></span><br><span class=\"line\">          update_list           /* <span class=\"comment\">#6 */</span></span><br><span class=\"line\">          opt_where_clause      /* <span class=\"comment\">#7 */</span></span><br><span class=\"line\">          opt_order_clause      /* <span class=\"comment\">#8 */</span></span><br><span class=\"line\">          opt_simple_limit      /* <span class=\"comment\">#9 */</span></span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            $$= NEW_PTN PT_update(<span class=\"variable\">$1</span>, <span class=\"variable\">$2</span>, <span class=\"variable\">$3</span>, <span class=\"variable\">$4</span>, <span class=\"variable\">$5</span>, <span class=\"variable\">$7</span>.column_list, <span class=\"variable\">$7</span>.value_list,</span><br><span class=\"line\">                                  <span class=\"variable\">$8</span>, <span class=\"variable\">$9</span>, <span class=\"variable\">$10</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ;</span><br></pre></td></tr></table></figure>\n\n<p>一条 update 语句被切分为 10 个部分，对应生成 10 个参数：</p>\n<ol>\n<li>opt_with_clause: with子句</li>\n<li>UPDATE_SYM: update关键字</li>\n<li>opt_low_priority: </li>\n<li>opt_ignore: </li>\n<li>table_reference_list: 表信息</li>\n<li>SET_SYM: set关键字</li>\n<li>update_list: 更新内容</li>\n<li>opt_where_clause: where子句</li>\n<li>opt_order_clause: order子句</li>\n<li>opt_simple_limit: limit子句</li>\n</ol>\n<p>每一个部分经过处理都会生成一个 YYSTYPE 类型对象，YYSTYPE 是一个集合类，具体定义可以查看 parser_yystype.h，摘要部分信息如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">union</span> YYSTYPE &#123;</span><br><span class=\"line\">  Lexer_yystype lexer;  <span class=\"comment\">// terminal values from the lexical scanner</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  Mem_root_array_YY&lt;PT_table_reference *&gt; table_reference_list;</span><br><span class=\"line\">  ...  </span><br><span class=\"line\"></span><br><span class=\"line\">  Item *item;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PT_item_list</span> *<span class=\"title\">column_list</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PT_item_list</span> *<span class=\"title\">value_list</span>;</span></span><br><span class=\"line\">  &#125; column_value_list_pair;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>匹配到 update 语句模式的，经过语法分析，最终会生成一个 PT_update 类型的 Parse_tree_root。</p>\n<h2 id=\"语法扩展\"><a href=\"#语法扩展\" class=\"headerlink\" title=\"语法扩展\"></a>语法扩展</h2><h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p>Yacc介绍：<a href=\"https://www.ibm.com/developerworks/cn/linux/sdk/lex/index.html\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/cn/linux/sdk/lex/index.html</a></p>\n<p>词法分析：<a href=\"https://www.cnblogs.com/nocode/archive/2011/08/03/2126726.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/nocode/archive/2011/08/03/2126726.html</a></p>\n<p>语法分析：<a href=\"https://www.cnblogs.com/nocode/archive/2011/08/09/2132814.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/nocode/archive/2011/08/09/2132814.html</a></p>\n<p><a href=\"http://mysql.taobao.org/monthly/2017/02/04/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2017/02/04/</a></p>\n<p><a href=\"http://mysql.taobao.org/monthly/2017/04/02/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2017/04/02/</a></p>\n<p>SQL解析：<a href=\"https://tech.meituan.com/2018/05/20/sql-parser-used-in-mtdp.html\" target=\"_blank\" rel=\"noopener\">https://tech.meituan.com/2018/05/20/sql-parser-used-in-mtdp.html</a></p>\n<p><a href=\"http://www.orczhou.com/index.php/2012/11/mysql-innodb-source-code-optimization-1/\" target=\"_blank\" rel=\"noopener\">http://www.orczhou.com/index.php/2012/11/mysql-innodb-source-code-optimization-1/</a></p>\n<p><a href=\"https://www.jiqizhixin.com/articles/2018-12-12-17\" target=\"_blank\" rel=\"noopener\">https://www.jiqizhixin.com/articles/2018-12-12-17</a></p>\n</blockquote>"},{"title":"MySQL 建连过程分析","date":"2020-07-15T14:09:20.000Z","_content":"\n本文结合 MySQL 8.0 的源码对 MySQL 的连接处理过程进行一个介绍，其它版本与 8.0 版本基本类似。\n\n<!-- more -->\n\n## 数据结构\n\n在介绍 MySQL 建连过程之前，先整体看一下相关类的关系：\n\n<img src=\"/images/connection-handler-1.jpg\" width=\"88%\"/>\n\nMySQL 8.0 在 Linux 平台下使用的是 poll 机制，默认情况下每个用户连接会使用一个单独的线程进行处理。\n\n## MySQL 建连过程\n\nMySQL 建连过程可以分为以下几个步骤：\n\n### 初始化\n\n```c++\nstatic Connection_acceptor<Mysqld_socket_listener> *mysqld_socket_acceptor = NULL;\n\nstatic bool network_init(void) {\n  ...\n  /* 解析网络配置信息 */\n  Mysqld_socket_listener *mysqld_socket_listener = new (std::nothrow)\n      Mysqld_socket_listener(bind_addresses_info, mysqld_port,\n                             admin_address_info, mysqld_admin_port,\n                             listen_admin_interface_in_separate_thread,\n                             back_log, mysqld_port_timeout, unix_sock_name);\n\n  mysqld_socket_acceptor = new (std::nothrow)\n      Connection_acceptor<Mysqld_socket_listener>(mysqld_socket_listener);\n  ...\n  /* 初始化监听端口 */\n  if (mysqld_socket_acceptor->init_connection_acceptor())\n    return true;\n  ...\n}\n\nbool init_connection_acceptor() { return m_listener->setup_listener(); }\n\nbool Mysqld_socket_listener::setup_listener() {\n  ...\n  if (m_tcp_port) {\n    for (const auto &bind_address_info : m_bind_addresses) {\n      TCP_socket tcp_socket(bind_address_info.address,\n                            bind_address_info.network_namespace, m_tcp_port,\n                            m_backlog, m_port_timeout);\n\n      /* socket 初始化，底层调用的还是 socket/bind/listen 函数 */\n      MYSQL_SOCKET mysql_socket = tcp_socket.get_listener_socket();\n      if (mysql_socket.fd == INVALID_SOCKET) return true;\n\n      Socket_attr s(Socket_type::TCP_SOCKET,\n                    bind_address_info.network_namespace);\n      m_socket_map.insert(\n          std::pair<MYSQL_SOCKET, Socket_attr>(mysql_socket, s));\n    }\n  }\n\n  /* 将所有监听的 socket 信息加入到 m_poll_info 中 */\n  setup_connection_events(m_socket_map);\n  return false;\n}\n\n/* socker 初始化 */\nMYSQL_SOCKET TCP_socket::get_listener_socket() {\n  ...\n  MYSQL_SOCKET listener_socket = create_socket(ai_ptr.get(), AF_INET, &a);\n  mysql_socket_bind(listener_socket, a->ai_addr, a->ai_addrlen);\n  mysql_socket_listen(listener_socket, static_cast<int>(m_backlog);\n  ...\n}\n\nvoid Mysqld_socket_listener::setup_connection_events(\n    const socket_map_t &socket_map) {\n#ifdef HAVE_POLL\n  const socket_map_t::size_type total_number_of_addresses_to_bind =\n      socket_map.size();\n  m_poll_info.m_fds.reserve(total_number_of_addresses_to_bind);\n  m_poll_info.m_pfs_fds.reserve(total_number_of_addresses_to_bind);\n#endif\n\n  for (const auto &element : socket_map) add_socket_to_listener(element.first);\n}\n\nvoid Mysqld_socket_listener::add_socket_to_listener(\n    MYSQL_SOCKET listen_socket) {\n  mysql_socket_set_thread_owner(listen_socket);\n\n#ifdef HAVE_POLL\n  m_poll_info.m_fds.emplace_back(\n      pollfd{mysql_socket_getfd(listen_socket), POLLIN, 0});\n  m_poll_info.m_pfs_fds.push_back(listen_socket);\n#else\n  FD_SET(mysql_socket_getfd(listen_socket), &m_select_info.m_client_fds);\n  if ((uint)mysql_socket_getfd(listen_socket) >\n      m_select_info.m_max_used_connection)\n    m_select_info.m_max_used_connection = mysql_socket_getfd(listen_socket);\n#endif\n}\n```\n\n### 连接建立\n\n```c++\nint mysqld_main(int argc, char **argv) {\n  ...\n  mysqld_socket_acceptor->connection_event_loop();\n  ...\n}\n\nvoid connection_event_loop() {\n  Connection_handler_manager *mgr =\n    Connection_handler_manager::get_instance();\n  while (!connection_events_loop_aborted()) {\n    /* 监听到连接事件，开始 channel 处理 */\n    Channel_info *channel_info = m_listener->listen_for_connection_event();\n    if (channel_info != NULL) mgr->process_new_connection(channel_info);\n  }\n}\n\nChannel_info *Mysqld_socket_listener::listen_for_connection_event() {\n#ifdef HAVE_POLL\n  /* 通过 poll 机制进行监听 */\n  int retval = poll(&m_poll_info.m_fds[0], m_socket_map.size(), -1);\n#else\n  m_select_info.m_read_fds = m_select_info.m_client_fds;\n  int retval = select((int)m_select_info.m_max_used_connection,\n                      &m_select_info.m_read_fds, 0, 0, 0);\n#endif\n\n  bool is_unix_socket = false, is_admin_sock;\n  /* 获取到一个 ready 的 socket */\n  MYSQL_SOCKET listen_sock = get_ready_socket(&is_unix_socket, &is_admin_sock);\n  DBUG_ASSERT(mysql_socket_getfd(listen_sock) != INVALID_SOCKET);\n  \n  MYSQL_SOCKET connect_sock;\n  accept_connection(listen_sock, &connect_sock);\n\n  Channel_info *channel_info = NULL;\n  if (is_unix_socket)\n    channel_info = new (std::nothrow) Channel_info_local_socket(connect_sock);\n  else\n    channel_info = new (std::nothrow)\n        Channel_info_tcpip_socket(connect_sock, is_admin_sock);\n}\n\nvoid Connection_handler_manager::process_new_connection(\n    Channel_info *channel_info) {\n  ...\n  if (m_connection_handler->add_connection(channel_info)) {\n    inc_aborted_connects();\n    delete channel_info;\n  }\n}\n\n/* 一对一处理模式 */\nbool Per_thread_connection_handler::add_connection(Channel_info *channel_info) {\n  ...\n  /* 检查是否有空闲的线程 */\n  if (!check_idle_thread_and_enqueue_connection(channel_info)) return false;\n  \n  channel_info->set_prior_thr_create_utime();\n  /* 新建一个线程进行处理 */\n  error =\n      mysql_thread_create(key_thread_one_connection, &id, &connection_attrib,\n                          handle_connection, (void *)channel_info);\n  ...\n  if (error) {\n    connection_errors_internal++;\n    if (!create_thd_err_log_throttle.log())\n      LogErr(ERROR_LEVEL, ER_CONN_PER_THREAD_NO_THREAD, error);\n    channel_info->send_error_and_close_channel(ER_CANT_CREATE_THREAD, error,\n                                               true);\n\n    im::global_manager_dec_connection(NULL);\n    return true;\n  }\n  ...\n}\n\nstatic void *handle_connection(void *arg) {\n  ...\n  Channel_info *channel_info = static_cast<Channel_info *>(arg);\n  if (my_thread_init()) {\n    ...\n  }\n  ...\n  for (;;) {\n    THD *thd = init_new_thd(channel_info);\n    ...\n    while (thd_connection_alive(thd)) {\n      /* 开始请求处理 */\n      if (do_command(thd)) break;\n    }\n    ...\n    /* thread 复用 */\n    channel_info = Per_thread_connection_handler::block_until_new_connection();\n  }\n}\n```\n\n### 请求处理\n\n```c++\nbool do_command(THD *thd,\n                std::function<bool(THD *, const COM_DATA *,\n                                   enum enum_server_command)> *dispatcher) {\n  ...\n  thd->m_server_idle = true;\n  rc = thd->get_protocol()->get_command(&com_data, &command);\n  thd->m_server_idle = false;\n  ...\n  return_value = dispatch_command(thd, &com_data, command);\n  ...\n}\n\nbool dispatch_command(THD *thd, const COM_DATA *com_data,\n                      enum enum_server_command command) {\n  ...\n  thd->set_command(command);\n  ...\n  switch (command) {\n    ...\n    case COM_QUERY: {...}\n    ...\n  }\n}\n```\n\n## 附\n\nMySQL 5.7 可以参考：http://mysql.taobao.org/monthly/2016/07/04/","source":"_posts/mysql/connection-handler.md","raw":"---\ntitle: MySQL 建连过程分析\ndate: 2020-07-15 22:09:20\ncategories: \n- MySQL\n\n---\n\n本文结合 MySQL 8.0 的源码对 MySQL 的连接处理过程进行一个介绍，其它版本与 8.0 版本基本类似。\n\n<!-- more -->\n\n## 数据结构\n\n在介绍 MySQL 建连过程之前，先整体看一下相关类的关系：\n\n<img src=\"/images/connection-handler-1.jpg\" width=\"88%\"/>\n\nMySQL 8.0 在 Linux 平台下使用的是 poll 机制，默认情况下每个用户连接会使用一个单独的线程进行处理。\n\n## MySQL 建连过程\n\nMySQL 建连过程可以分为以下几个步骤：\n\n### 初始化\n\n```c++\nstatic Connection_acceptor<Mysqld_socket_listener> *mysqld_socket_acceptor = NULL;\n\nstatic bool network_init(void) {\n  ...\n  /* 解析网络配置信息 */\n  Mysqld_socket_listener *mysqld_socket_listener = new (std::nothrow)\n      Mysqld_socket_listener(bind_addresses_info, mysqld_port,\n                             admin_address_info, mysqld_admin_port,\n                             listen_admin_interface_in_separate_thread,\n                             back_log, mysqld_port_timeout, unix_sock_name);\n\n  mysqld_socket_acceptor = new (std::nothrow)\n      Connection_acceptor<Mysqld_socket_listener>(mysqld_socket_listener);\n  ...\n  /* 初始化监听端口 */\n  if (mysqld_socket_acceptor->init_connection_acceptor())\n    return true;\n  ...\n}\n\nbool init_connection_acceptor() { return m_listener->setup_listener(); }\n\nbool Mysqld_socket_listener::setup_listener() {\n  ...\n  if (m_tcp_port) {\n    for (const auto &bind_address_info : m_bind_addresses) {\n      TCP_socket tcp_socket(bind_address_info.address,\n                            bind_address_info.network_namespace, m_tcp_port,\n                            m_backlog, m_port_timeout);\n\n      /* socket 初始化，底层调用的还是 socket/bind/listen 函数 */\n      MYSQL_SOCKET mysql_socket = tcp_socket.get_listener_socket();\n      if (mysql_socket.fd == INVALID_SOCKET) return true;\n\n      Socket_attr s(Socket_type::TCP_SOCKET,\n                    bind_address_info.network_namespace);\n      m_socket_map.insert(\n          std::pair<MYSQL_SOCKET, Socket_attr>(mysql_socket, s));\n    }\n  }\n\n  /* 将所有监听的 socket 信息加入到 m_poll_info 中 */\n  setup_connection_events(m_socket_map);\n  return false;\n}\n\n/* socker 初始化 */\nMYSQL_SOCKET TCP_socket::get_listener_socket() {\n  ...\n  MYSQL_SOCKET listener_socket = create_socket(ai_ptr.get(), AF_INET, &a);\n  mysql_socket_bind(listener_socket, a->ai_addr, a->ai_addrlen);\n  mysql_socket_listen(listener_socket, static_cast<int>(m_backlog);\n  ...\n}\n\nvoid Mysqld_socket_listener::setup_connection_events(\n    const socket_map_t &socket_map) {\n#ifdef HAVE_POLL\n  const socket_map_t::size_type total_number_of_addresses_to_bind =\n      socket_map.size();\n  m_poll_info.m_fds.reserve(total_number_of_addresses_to_bind);\n  m_poll_info.m_pfs_fds.reserve(total_number_of_addresses_to_bind);\n#endif\n\n  for (const auto &element : socket_map) add_socket_to_listener(element.first);\n}\n\nvoid Mysqld_socket_listener::add_socket_to_listener(\n    MYSQL_SOCKET listen_socket) {\n  mysql_socket_set_thread_owner(listen_socket);\n\n#ifdef HAVE_POLL\n  m_poll_info.m_fds.emplace_back(\n      pollfd{mysql_socket_getfd(listen_socket), POLLIN, 0});\n  m_poll_info.m_pfs_fds.push_back(listen_socket);\n#else\n  FD_SET(mysql_socket_getfd(listen_socket), &m_select_info.m_client_fds);\n  if ((uint)mysql_socket_getfd(listen_socket) >\n      m_select_info.m_max_used_connection)\n    m_select_info.m_max_used_connection = mysql_socket_getfd(listen_socket);\n#endif\n}\n```\n\n### 连接建立\n\n```c++\nint mysqld_main(int argc, char **argv) {\n  ...\n  mysqld_socket_acceptor->connection_event_loop();\n  ...\n}\n\nvoid connection_event_loop() {\n  Connection_handler_manager *mgr =\n    Connection_handler_manager::get_instance();\n  while (!connection_events_loop_aborted()) {\n    /* 监听到连接事件，开始 channel 处理 */\n    Channel_info *channel_info = m_listener->listen_for_connection_event();\n    if (channel_info != NULL) mgr->process_new_connection(channel_info);\n  }\n}\n\nChannel_info *Mysqld_socket_listener::listen_for_connection_event() {\n#ifdef HAVE_POLL\n  /* 通过 poll 机制进行监听 */\n  int retval = poll(&m_poll_info.m_fds[0], m_socket_map.size(), -1);\n#else\n  m_select_info.m_read_fds = m_select_info.m_client_fds;\n  int retval = select((int)m_select_info.m_max_used_connection,\n                      &m_select_info.m_read_fds, 0, 0, 0);\n#endif\n\n  bool is_unix_socket = false, is_admin_sock;\n  /* 获取到一个 ready 的 socket */\n  MYSQL_SOCKET listen_sock = get_ready_socket(&is_unix_socket, &is_admin_sock);\n  DBUG_ASSERT(mysql_socket_getfd(listen_sock) != INVALID_SOCKET);\n  \n  MYSQL_SOCKET connect_sock;\n  accept_connection(listen_sock, &connect_sock);\n\n  Channel_info *channel_info = NULL;\n  if (is_unix_socket)\n    channel_info = new (std::nothrow) Channel_info_local_socket(connect_sock);\n  else\n    channel_info = new (std::nothrow)\n        Channel_info_tcpip_socket(connect_sock, is_admin_sock);\n}\n\nvoid Connection_handler_manager::process_new_connection(\n    Channel_info *channel_info) {\n  ...\n  if (m_connection_handler->add_connection(channel_info)) {\n    inc_aborted_connects();\n    delete channel_info;\n  }\n}\n\n/* 一对一处理模式 */\nbool Per_thread_connection_handler::add_connection(Channel_info *channel_info) {\n  ...\n  /* 检查是否有空闲的线程 */\n  if (!check_idle_thread_and_enqueue_connection(channel_info)) return false;\n  \n  channel_info->set_prior_thr_create_utime();\n  /* 新建一个线程进行处理 */\n  error =\n      mysql_thread_create(key_thread_one_connection, &id, &connection_attrib,\n                          handle_connection, (void *)channel_info);\n  ...\n  if (error) {\n    connection_errors_internal++;\n    if (!create_thd_err_log_throttle.log())\n      LogErr(ERROR_LEVEL, ER_CONN_PER_THREAD_NO_THREAD, error);\n    channel_info->send_error_and_close_channel(ER_CANT_CREATE_THREAD, error,\n                                               true);\n\n    im::global_manager_dec_connection(NULL);\n    return true;\n  }\n  ...\n}\n\nstatic void *handle_connection(void *arg) {\n  ...\n  Channel_info *channel_info = static_cast<Channel_info *>(arg);\n  if (my_thread_init()) {\n    ...\n  }\n  ...\n  for (;;) {\n    THD *thd = init_new_thd(channel_info);\n    ...\n    while (thd_connection_alive(thd)) {\n      /* 开始请求处理 */\n      if (do_command(thd)) break;\n    }\n    ...\n    /* thread 复用 */\n    channel_info = Per_thread_connection_handler::block_until_new_connection();\n  }\n}\n```\n\n### 请求处理\n\n```c++\nbool do_command(THD *thd,\n                std::function<bool(THD *, const COM_DATA *,\n                                   enum enum_server_command)> *dispatcher) {\n  ...\n  thd->m_server_idle = true;\n  rc = thd->get_protocol()->get_command(&com_data, &command);\n  thd->m_server_idle = false;\n  ...\n  return_value = dispatch_command(thd, &com_data, command);\n  ...\n}\n\nbool dispatch_command(THD *thd, const COM_DATA *com_data,\n                      enum enum_server_command command) {\n  ...\n  thd->set_command(command);\n  ...\n  switch (command) {\n    ...\n    case COM_QUERY: {...}\n    ...\n  }\n}\n```\n\n## 附\n\nMySQL 5.7 可以参考：http://mysql.taobao.org/monthly/2016/07/04/","slug":"mysql/connection-handler","published":1,"updated":"2020-12-05T12:02:28.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4xn0019gugm0c0d0ecu","content":"<p>本文结合 MySQL 8.0 的源码对 MySQL 的连接处理过程进行一个介绍，其它版本与 8.0 版本基本类似。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>在介绍 MySQL 建连过程之前，先整体看一下相关类的关系：</p>\n<img src=\"/images/connection-handler-1.jpg\" width=\"88%\"/>\n\n<p>MySQL 8.0 在 Linux 平台下使用的是 poll 机制，默认情况下每个用户连接会使用一个单独的线程进行处理。</p>\n<h2 id=\"MySQL-建连过程\"><a href=\"#MySQL-建连过程\" class=\"headerlink\" title=\"MySQL 建连过程\"></a>MySQL 建连过程</h2><p>MySQL 建连过程可以分为以下几个步骤：</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> Connection_acceptor&lt;Mysqld_socket_listener&gt; *mysqld_socket_acceptor = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> <span class=\"title\">network_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">/* 解析网络配置信息 */</span></span><br><span class=\"line\">  Mysqld_socket_listener *mysqld_socket_listener = <span class=\"keyword\">new</span> (<span class=\"built_in\">std</span>::nothrow)</span><br><span class=\"line\">      Mysqld_socket_listener(bind_addresses_info, mysqld_port,</span><br><span class=\"line\">                             admin_address_info, mysqld_admin_port,</span><br><span class=\"line\">                             listen_admin_interface_in_separate_thread,</span><br><span class=\"line\">                             back_log, mysqld_port_timeout, unix_sock_name);</span><br><span class=\"line\"></span><br><span class=\"line\">  mysqld_socket_acceptor = <span class=\"keyword\">new</span> (<span class=\"built_in\">std</span>::nothrow)</span><br><span class=\"line\">      Connection_acceptor&lt;Mysqld_socket_listener&gt;(mysqld_socket_listener);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">/* 初始化监听端口 */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mysqld_socket_acceptor-&gt;init_connection_acceptor())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">init_connection_acceptor</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_listener-&gt;setup_listener(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Mysqld_socket_listener::setup_listener</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (m_tcp_port) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> &amp;bind_address_info : m_bind_addresses) &#123;</span><br><span class=\"line\">      <span class=\"function\">TCP_socket <span class=\"title\">tcp_socket</span><span class=\"params\">(bind_address_info.address,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            bind_address_info.network_namespace, m_tcp_port,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            m_backlog, m_port_timeout)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/* socket 初始化，底层调用的还是 socket/bind/listen 函数 */</span></span><br><span class=\"line\">      MYSQL_SOCKET mysql_socket = tcp_socket.get_listener_socket();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (mysql_socket.fd == INVALID_SOCKET) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\">Socket_attr <span class=\"title\">s</span><span class=\"params\">(Socket_type::TCP_SOCKET,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    bind_address_info.network_namespace)</span></span>;</span><br><span class=\"line\">      m_socket_map.insert(</span><br><span class=\"line\">          <span class=\"built_in\">std</span>::pair&lt;MYSQL_SOCKET, Socket_attr&gt;(mysql_socket, s));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* 将所有监听的 socket 信息加入到 m_poll_info 中 */</span></span><br><span class=\"line\">  setup_connection_events(m_socket_map);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* socker 初始化 */</span></span><br><span class=\"line\"><span class=\"function\">MYSQL_SOCKET <span class=\"title\">TCP_socket::get_listener_socket</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  MYSQL_SOCKET listener_socket = create_socket(ai_ptr.<span class=\"built_in\">get</span>(), AF_INET, &amp;a);</span><br><span class=\"line\">  mysql_socket_bind(listener_socket, a-&gt;ai_addr, a-&gt;ai_addrlen);</span><br><span class=\"line\">  mysql_socket_listen(listener_socket, <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(m_backlog);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Mysqld_socket_listener::setup_connection_events(</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">socket_map_t</span> &amp;socket_map) &#123;</span><br><span class=\"line\">#ifdef HAVE_POLL</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">socket_map_t</span>::size_type total_number_of_addresses_to_bind =</span><br><span class=\"line\">      socket_map.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">  m_poll_info.m_fds.reserve(total_number_of_addresses_to_bind);</span><br><span class=\"line\">  m_poll_info.m_pfs_fds.reserve(total_number_of_addresses_to_bind);</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> &amp;element : socket_map) add_socket_to_listener(element.first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Mysqld_socket_listener::add_socket_to_listener(</span><br><span class=\"line\">    MYSQL_SOCKET listen_socket) &#123;</span><br><span class=\"line\">  mysql_socket_set_thread_owner(listen_socket);</span><br><span class=\"line\"></span><br><span class=\"line\">#ifdef HAVE_POLL</span><br><span class=\"line\">  m_poll_info.m_fds.emplace_back(</span><br><span class=\"line\">      pollfd&#123;mysql_socket_getfd(listen_socket), POLLIN, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">  m_poll_info.m_pfs_fds.push_back(listen_socket);</span><br><span class=\"line\">#<span class=\"keyword\">else</span></span><br><span class=\"line\">  FD_SET(mysql_socket_getfd(listen_socket), &amp;m_select_info.m_client_fds);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((uint)mysql_socket_getfd(listen_socket) &gt;</span><br><span class=\"line\">      m_select_info.m_max_used_connection)</span><br><span class=\"line\">    m_select_info.m_max_used_connection = mysql_socket_getfd(listen_socket);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"连接建立\"><a href=\"#连接建立\" class=\"headerlink\" title=\"连接建立\"></a>连接建立</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mysqld_main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  mysqld_socket_acceptor-&gt;connection_event_loop();</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">connection_event_loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Connection_handler_manager *mgr =</span><br><span class=\"line\">    Connection_handler_manager::get_instance();</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!connection_events_loop_aborted()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 监听到连接事件，开始 channel 处理 */</span></span><br><span class=\"line\">    Channel_info *channel_info = m_listener-&gt;listen_for_connection_event();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (channel_info != <span class=\"literal\">NULL</span>) mgr-&gt;process_new_connection(channel_info);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Channel_info *<span class=\"title\">Mysqld_socket_listener::listen_for_connection_event</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> HAVE_POLL</span></span><br><span class=\"line\">  <span class=\"comment\">/* 通过 poll 机制进行监听 */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> retval = poll(&amp;m_poll_info.m_fds[<span class=\"number\">0</span>], m_socket_map.<span class=\"built_in\">size</span>(), <span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">  m_select_info.m_read_fds = m_select_info.m_client_fds;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> retval = select((<span class=\"keyword\">int</span>)m_select_info.m_max_used_connection,</span><br><span class=\"line\">                      &amp;m_select_info.m_read_fds, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> is_unix_socket = <span class=\"literal\">false</span>, is_admin_sock;</span><br><span class=\"line\">  <span class=\"comment\">/* 获取到一个 ready 的 socket */</span></span><br><span class=\"line\">  MYSQL_SOCKET listen_sock = get_ready_socket(&amp;is_unix_socket, &amp;is_admin_sock);</span><br><span class=\"line\">  DBUG_ASSERT(mysql_socket_getfd(listen_sock) != INVALID_SOCKET);</span><br><span class=\"line\">  </span><br><span class=\"line\">  MYSQL_SOCKET connect_sock;</span><br><span class=\"line\">  accept_connection(listen_sock, &amp;connect_sock);</span><br><span class=\"line\"></span><br><span class=\"line\">  Channel_info *channel_info = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (is_unix_socket)</span><br><span class=\"line\">    channel_info = <span class=\"keyword\">new</span> (<span class=\"built_in\">std</span>::nothrow) Channel_info_local_socket(connect_sock);</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    channel_info = <span class=\"keyword\">new</span> (<span class=\"built_in\">std</span>::nothrow)</span><br><span class=\"line\">        Channel_info_tcpip_socket(connect_sock, is_admin_sock);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Connection_handler_manager::process_new_connection</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    Channel_info *channel_info)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (m_connection_handler-&gt;add_connection(channel_info)) &#123;</span><br><span class=\"line\">    inc_aborted_connects();</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> channel_info;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 一对一处理模式 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Per_thread_connection_handler::add_connection</span><span class=\"params\">(Channel_info *channel_info)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">/* 检查是否有空闲的线程 */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!check_idle_thread_and_enqueue_connection(channel_info)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  channel_info-&gt;set_prior_thr_create_utime();</span><br><span class=\"line\">  <span class=\"comment\">/* 新建一个线程进行处理 */</span></span><br><span class=\"line\">  error =</span><br><span class=\"line\">      mysql_thread_create(key_thread_one_connection, &amp;id, &amp;connection_attrib,</span><br><span class=\"line\">                          handle_connection, (<span class=\"keyword\">void</span> *)channel_info);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">    connection_errors_internal++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!create_thd_err_log_throttle.<span class=\"built_in\">log</span>())</span><br><span class=\"line\">      LogErr(ERROR_LEVEL, ER_CONN_PER_THREAD_NO_THREAD, error);</span><br><span class=\"line\">    channel_info-&gt;send_error_and_close_channel(ER_CANT_CREATE_THREAD, error,</span><br><span class=\"line\">                                               <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    im::global_manager_dec_connection(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *<span class=\"title\">handle_connection</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  Channel_info *channel_info = <span class=\"keyword\">static_cast</span>&lt;Channel_info *&gt;(arg);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (my_thread_init()) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    THD *thd = init_new_thd(channel_info);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (thd_connection_alive(thd)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* 开始请求处理 */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (do_command(thd)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">/* thread 复用 */</span></span><br><span class=\"line\">    channel_info = Per_thread_connection_handler::block_until_new_connection();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"请求处理\"><a href=\"#请求处理\" class=\"headerlink\" title=\"请求处理\"></a>请求处理</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">do_command</span><span class=\"params\">(THD *thd,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">bool</span>(THD *, <span class=\"keyword\">const</span> COM_DATA *,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                   <span class=\"keyword\">enum</span> enum_server_command)&gt; *dispatcher)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  thd-&gt;m_server_idle = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  rc = thd-&gt;get_protocol()-&gt;get_command(&amp;com_data, &amp;command);</span><br><span class=\"line\">  thd-&gt;m_server_idle = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  return_value = dispatch_command(thd, &amp;com_data, command);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dispatch_command</span><span class=\"params\">(THD *thd, <span class=\"keyword\">const</span> COM_DATA *com_data,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      <span class=\"keyword\">enum</span> enum_server_command command)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  thd-&gt;set_command(command);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (command) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">case</span> COM_QUERY: &#123;...&#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h2><p>MySQL 5.7 可以参考：<a href=\"http://mysql.taobao.org/monthly/2016/07/04/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2016/07/04/</a></p>\n","site":{"data":{}},"excerpt":"<p>本文结合 MySQL 8.0 的源码对 MySQL 的连接处理过程进行一个介绍，其它版本与 8.0 版本基本类似。</p>","more":"<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>在介绍 MySQL 建连过程之前，先整体看一下相关类的关系：</p>\n<img src=\"/images/connection-handler-1.jpg\" width=\"88%\"/>\n\n<p>MySQL 8.0 在 Linux 平台下使用的是 poll 机制，默认情况下每个用户连接会使用一个单独的线程进行处理。</p>\n<h2 id=\"MySQL-建连过程\"><a href=\"#MySQL-建连过程\" class=\"headerlink\" title=\"MySQL 建连过程\"></a>MySQL 建连过程</h2><p>MySQL 建连过程可以分为以下几个步骤：</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> Connection_acceptor&lt;Mysqld_socket_listener&gt; *mysqld_socket_acceptor = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> <span class=\"title\">network_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">/* 解析网络配置信息 */</span></span><br><span class=\"line\">  Mysqld_socket_listener *mysqld_socket_listener = <span class=\"keyword\">new</span> (<span class=\"built_in\">std</span>::nothrow)</span><br><span class=\"line\">      Mysqld_socket_listener(bind_addresses_info, mysqld_port,</span><br><span class=\"line\">                             admin_address_info, mysqld_admin_port,</span><br><span class=\"line\">                             listen_admin_interface_in_separate_thread,</span><br><span class=\"line\">                             back_log, mysqld_port_timeout, unix_sock_name);</span><br><span class=\"line\"></span><br><span class=\"line\">  mysqld_socket_acceptor = <span class=\"keyword\">new</span> (<span class=\"built_in\">std</span>::nothrow)</span><br><span class=\"line\">      Connection_acceptor&lt;Mysqld_socket_listener&gt;(mysqld_socket_listener);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">/* 初始化监听端口 */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mysqld_socket_acceptor-&gt;init_connection_acceptor())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">init_connection_acceptor</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_listener-&gt;setup_listener(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Mysqld_socket_listener::setup_listener</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (m_tcp_port) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> &amp;bind_address_info : m_bind_addresses) &#123;</span><br><span class=\"line\">      <span class=\"function\">TCP_socket <span class=\"title\">tcp_socket</span><span class=\"params\">(bind_address_info.address,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            bind_address_info.network_namespace, m_tcp_port,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            m_backlog, m_port_timeout)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/* socket 初始化，底层调用的还是 socket/bind/listen 函数 */</span></span><br><span class=\"line\">      MYSQL_SOCKET mysql_socket = tcp_socket.get_listener_socket();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (mysql_socket.fd == INVALID_SOCKET) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\">Socket_attr <span class=\"title\">s</span><span class=\"params\">(Socket_type::TCP_SOCKET,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    bind_address_info.network_namespace)</span></span>;</span><br><span class=\"line\">      m_socket_map.insert(</span><br><span class=\"line\">          <span class=\"built_in\">std</span>::pair&lt;MYSQL_SOCKET, Socket_attr&gt;(mysql_socket, s));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* 将所有监听的 socket 信息加入到 m_poll_info 中 */</span></span><br><span class=\"line\">  setup_connection_events(m_socket_map);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* socker 初始化 */</span></span><br><span class=\"line\"><span class=\"function\">MYSQL_SOCKET <span class=\"title\">TCP_socket::get_listener_socket</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  MYSQL_SOCKET listener_socket = create_socket(ai_ptr.<span class=\"built_in\">get</span>(), AF_INET, &amp;a);</span><br><span class=\"line\">  mysql_socket_bind(listener_socket, a-&gt;ai_addr, a-&gt;ai_addrlen);</span><br><span class=\"line\">  mysql_socket_listen(listener_socket, <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(m_backlog);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Mysqld_socket_listener::setup_connection_events(</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">socket_map_t</span> &amp;socket_map) &#123;</span><br><span class=\"line\">#ifdef HAVE_POLL</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">socket_map_t</span>::size_type total_number_of_addresses_to_bind =</span><br><span class=\"line\">      socket_map.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">  m_poll_info.m_fds.reserve(total_number_of_addresses_to_bind);</span><br><span class=\"line\">  m_poll_info.m_pfs_fds.reserve(total_number_of_addresses_to_bind);</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> &amp;element : socket_map) add_socket_to_listener(element.first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Mysqld_socket_listener::add_socket_to_listener(</span><br><span class=\"line\">    MYSQL_SOCKET listen_socket) &#123;</span><br><span class=\"line\">  mysql_socket_set_thread_owner(listen_socket);</span><br><span class=\"line\"></span><br><span class=\"line\">#ifdef HAVE_POLL</span><br><span class=\"line\">  m_poll_info.m_fds.emplace_back(</span><br><span class=\"line\">      pollfd&#123;mysql_socket_getfd(listen_socket), POLLIN, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">  m_poll_info.m_pfs_fds.push_back(listen_socket);</span><br><span class=\"line\">#<span class=\"keyword\">else</span></span><br><span class=\"line\">  FD_SET(mysql_socket_getfd(listen_socket), &amp;m_select_info.m_client_fds);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((uint)mysql_socket_getfd(listen_socket) &gt;</span><br><span class=\"line\">      m_select_info.m_max_used_connection)</span><br><span class=\"line\">    m_select_info.m_max_used_connection = mysql_socket_getfd(listen_socket);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"连接建立\"><a href=\"#连接建立\" class=\"headerlink\" title=\"连接建立\"></a>连接建立</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mysqld_main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  mysqld_socket_acceptor-&gt;connection_event_loop();</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">connection_event_loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Connection_handler_manager *mgr =</span><br><span class=\"line\">    Connection_handler_manager::get_instance();</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!connection_events_loop_aborted()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 监听到连接事件，开始 channel 处理 */</span></span><br><span class=\"line\">    Channel_info *channel_info = m_listener-&gt;listen_for_connection_event();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (channel_info != <span class=\"literal\">NULL</span>) mgr-&gt;process_new_connection(channel_info);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Channel_info *<span class=\"title\">Mysqld_socket_listener::listen_for_connection_event</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> HAVE_POLL</span></span><br><span class=\"line\">  <span class=\"comment\">/* 通过 poll 机制进行监听 */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> retval = poll(&amp;m_poll_info.m_fds[<span class=\"number\">0</span>], m_socket_map.<span class=\"built_in\">size</span>(), <span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">  m_select_info.m_read_fds = m_select_info.m_client_fds;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> retval = select((<span class=\"keyword\">int</span>)m_select_info.m_max_used_connection,</span><br><span class=\"line\">                      &amp;m_select_info.m_read_fds, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> is_unix_socket = <span class=\"literal\">false</span>, is_admin_sock;</span><br><span class=\"line\">  <span class=\"comment\">/* 获取到一个 ready 的 socket */</span></span><br><span class=\"line\">  MYSQL_SOCKET listen_sock = get_ready_socket(&amp;is_unix_socket, &amp;is_admin_sock);</span><br><span class=\"line\">  DBUG_ASSERT(mysql_socket_getfd(listen_sock) != INVALID_SOCKET);</span><br><span class=\"line\">  </span><br><span class=\"line\">  MYSQL_SOCKET connect_sock;</span><br><span class=\"line\">  accept_connection(listen_sock, &amp;connect_sock);</span><br><span class=\"line\"></span><br><span class=\"line\">  Channel_info *channel_info = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (is_unix_socket)</span><br><span class=\"line\">    channel_info = <span class=\"keyword\">new</span> (<span class=\"built_in\">std</span>::nothrow) Channel_info_local_socket(connect_sock);</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    channel_info = <span class=\"keyword\">new</span> (<span class=\"built_in\">std</span>::nothrow)</span><br><span class=\"line\">        Channel_info_tcpip_socket(connect_sock, is_admin_sock);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Connection_handler_manager::process_new_connection</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    Channel_info *channel_info)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (m_connection_handler-&gt;add_connection(channel_info)) &#123;</span><br><span class=\"line\">    inc_aborted_connects();</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> channel_info;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 一对一处理模式 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Per_thread_connection_handler::add_connection</span><span class=\"params\">(Channel_info *channel_info)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">/* 检查是否有空闲的线程 */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!check_idle_thread_and_enqueue_connection(channel_info)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  channel_info-&gt;set_prior_thr_create_utime();</span><br><span class=\"line\">  <span class=\"comment\">/* 新建一个线程进行处理 */</span></span><br><span class=\"line\">  error =</span><br><span class=\"line\">      mysql_thread_create(key_thread_one_connection, &amp;id, &amp;connection_attrib,</span><br><span class=\"line\">                          handle_connection, (<span class=\"keyword\">void</span> *)channel_info);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">    connection_errors_internal++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!create_thd_err_log_throttle.<span class=\"built_in\">log</span>())</span><br><span class=\"line\">      LogErr(ERROR_LEVEL, ER_CONN_PER_THREAD_NO_THREAD, error);</span><br><span class=\"line\">    channel_info-&gt;send_error_and_close_channel(ER_CANT_CREATE_THREAD, error,</span><br><span class=\"line\">                                               <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    im::global_manager_dec_connection(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *<span class=\"title\">handle_connection</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  Channel_info *channel_info = <span class=\"keyword\">static_cast</span>&lt;Channel_info *&gt;(arg);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (my_thread_init()) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    THD *thd = init_new_thd(channel_info);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (thd_connection_alive(thd)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* 开始请求处理 */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (do_command(thd)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">/* thread 复用 */</span></span><br><span class=\"line\">    channel_info = Per_thread_connection_handler::block_until_new_connection();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"请求处理\"><a href=\"#请求处理\" class=\"headerlink\" title=\"请求处理\"></a>请求处理</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">do_command</span><span class=\"params\">(THD *thd,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">bool</span>(THD *, <span class=\"keyword\">const</span> COM_DATA *,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                   <span class=\"keyword\">enum</span> enum_server_command)&gt; *dispatcher)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  thd-&gt;m_server_idle = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  rc = thd-&gt;get_protocol()-&gt;get_command(&amp;com_data, &amp;command);</span><br><span class=\"line\">  thd-&gt;m_server_idle = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  return_value = dispatch_command(thd, &amp;com_data, command);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dispatch_command</span><span class=\"params\">(THD *thd, <span class=\"keyword\">const</span> COM_DATA *com_data,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      <span class=\"keyword\">enum</span> enum_server_command command)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  thd-&gt;set_command(command);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (command) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">case</span> COM_QUERY: &#123;...&#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h2><p>MySQL 5.7 可以参考：<a href=\"http://mysql.taobao.org/monthly/2016/07/04/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2016/07/04/</a></p>"},{"title":"MySQL Online DDL","date":"2020-11-18T14:26:22.000Z","_content":"\n关于 MySQL 的 Online DDL，网上有很多文章进行介绍，但是笔者浏览了部分文章，发现很多介绍都比较模糊，理解起来比较费劲。本文试图从使用者的角度对 MySQL Online DDL 进行一个直观的介绍。\n\n<!-- more -->\n\n## 各版本支持情况\n\n> https://dev.mysql.com/doc/refman/5.6/en/innodb-online-ddl-operations.html\n>\n> https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-operations.html\n>\n> https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html\n\n截止 20201118 社区各个版本的支持情况：\n\n<img src=\"/images/online-ddl-1.jpg\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<img src=\"/images/online-ddl-2.jpg\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<img src=\"/images/online-ddl-3.jpg\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n结合上面的表格，对 MySQL 当前 DDL 的执行模式总结如下：\n\n1. Instance DDL 是 MySQL 8.0 引入的新功能，当前支持的范围较小，包括：\n\n   - 修改二级索引的类型\n   - 新增列\n   - 修改列的默认值\n   - 重命名表\n\n2. 在执行 DDL 操作时，MySQL 内部对于 algorithm 的选择策略是：如果用户显式指定了 algorithm，那么使用用户指定的选项；如果用户未指定，那么如果该操作支持 inplace 则优先选择 inplace，否则选择 copy；当前不支持 inplace 的操作主要有：\n\n   - 删除主键\n   - 修改列的数据类型\n   - 修改表的字符集\n\n3. 我们常说的 Online DDL，其实是从 DML 操作的角度描述的，如果 DDL 操作不阻塞 DML 操作，那么这个 DDL 就是 Online 的。当前非 Online 的 DDL 其实已经比较少了，主要有：\n\n   - 新增全文索引\n   - 新增空间索引\n   - 删除主键\n   - 修改列的数据类型\n   - 指定表的字符集\n   - 修改表的字符集\n\n更多详细的示例请参考上面的官方文档的地址。\n\n## 两个问题\n\n最后讨论两个非常容易混淆的问题：\n\n1. Online DDL 不会锁表，可以随意的执行。\n2. 对于支持 inplace 算法的 DDL，DDL 操作是原地修改数据，不需要额外的数据空间。\n\n### Q1: Online DDL 会不会锁表\n\nOnline DDL 会不会锁表？要回答这个问题，首先要明确“锁表”的含义。很多 MySQL 用户经常在表无法正常的进行 DML 时就觉得是锁表了，这种说法其实过于宽泛，实际上能够影响 DML 操作的锁至少包括以下几种（默认为 InnoDB 表）：\n\n- MDL 锁\n- 表锁\n- 行锁\n- GAP 锁\n\n其中除了 MDL 锁是在 Server 层加的之外，其它三种都是在 InnoDB 层加的。具体的加锁逻辑不在此进行展开，但是需要明确一点：所有的操作（不管是 DDL 还是 DML 还是查询语句）都需要先拿 Server 层的 MDL 锁，然后再去拿 InnoDB 层的某个需要的锁。一个 DDL 的基本过程是这样的：\n\n1. 首选，在开始进行 DDL 时，需要拿到对应表的 MDL X 锁，然后进行一系列的准备工作；\n2. 然后将 MDL X 锁降级为 MDL S 锁，进行真正的 DDL 操作；\n3. 最后再次将 MDL S 锁升级为 MDL X 锁，完成 DDL 操作，释放 MDL 锁；\n\n所以在真正执行 DDL 操作期间，确实是不会“锁表”的，但是如果在第一阶段拿 MDL X 锁时无法正常获取，那就可能真的会“锁表了”。一个简单的例子如下：\n\n```sql\n# session 1\nselect sleep(300) from mytest.t1;\n\n# session 2\noptimize table mytest.t1;\n\n# session 3\nselect * from mytest.t1;\n```\n\nsession 1 模拟了一个慢查询，然后 session 2 开始进行 DDL 操作，无法拿到 MDL X 锁，处于等到中。此时 session 3 需要执行一个查询，发现无法执行。实际上，在 session 1 介绍前，表 t1 的所有操作都无法进行了，也可以说表 t1 “锁表”了。\n\n明确了上面的概念之后，再回到我们的问题，Online DDL 是不是不锁表？如果非要回答，那么只能说，Online DDL 并不是绝对安全，更不是可以随意的执行。线上操作还是需要在业务低峰期谨慎操作。\n\n### Q2: inplace DDL 需不需要额外的数据空间\n\n前面我们提到过，MySQL 内部对于 DDL 的 algorithm 有两种选择：inplace 和 copy。copy 算法理解起来相对简单一点：创建一张临时表，然后将原表的数据 copy 到临时表中，最后再用临时表替换原表。对于上面的步骤，由于需要将原表的数据 copy 到临时表中，所以肯定需要消耗额外的数据空间。\n\n那么对于支持 inplace 算法的 DDL，是不是不需要额外的数据空间？答案是：需要。其实之所以会问这个问题，还是因为对 inplace 本身的理解出现了偏差。简单来说：inplace 描述的是表，而不是数据文件。只要不创建临时表，那么都是 inplace 的。\n\n实际上，很多 inplace DDL 都会重建表（会创建临时的数据文件），所以都会需要额外的数据空间，例如：\n\n- 添加主键\n- 删除并重新添加主键\n- 新增列（8.0 支持 instance DDL，不需要）\n- 删除列\n- 重新排序列\n- 删除列的默认值\n- 增加列的默认值\n- 修改表的 row_format\n- optimize table\n\n以上只是对 MySQL Online DDL 的一个简单的总结，更多细节的内容还需要大家去发掘。\n\n","source":"_posts/mysql/online-ddl.md","raw":"---\ntitle: MySQL Online DDL\ndate: 2020-11-18 22:26:22\ntags:\n- Feature\ncategories: \n- MySQL\n\n---\n\n关于 MySQL 的 Online DDL，网上有很多文章进行介绍，但是笔者浏览了部分文章，发现很多介绍都比较模糊，理解起来比较费劲。本文试图从使用者的角度对 MySQL Online DDL 进行一个直观的介绍。\n\n<!-- more -->\n\n## 各版本支持情况\n\n> https://dev.mysql.com/doc/refman/5.6/en/innodb-online-ddl-operations.html\n>\n> https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-operations.html\n>\n> https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html\n\n截止 20201118 社区各个版本的支持情况：\n\n<img src=\"/images/online-ddl-1.jpg\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<img src=\"/images/online-ddl-2.jpg\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<img src=\"/images/online-ddl-3.jpg\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n结合上面的表格，对 MySQL 当前 DDL 的执行模式总结如下：\n\n1. Instance DDL 是 MySQL 8.0 引入的新功能，当前支持的范围较小，包括：\n\n   - 修改二级索引的类型\n   - 新增列\n   - 修改列的默认值\n   - 重命名表\n\n2. 在执行 DDL 操作时，MySQL 内部对于 algorithm 的选择策略是：如果用户显式指定了 algorithm，那么使用用户指定的选项；如果用户未指定，那么如果该操作支持 inplace 则优先选择 inplace，否则选择 copy；当前不支持 inplace 的操作主要有：\n\n   - 删除主键\n   - 修改列的数据类型\n   - 修改表的字符集\n\n3. 我们常说的 Online DDL，其实是从 DML 操作的角度描述的，如果 DDL 操作不阻塞 DML 操作，那么这个 DDL 就是 Online 的。当前非 Online 的 DDL 其实已经比较少了，主要有：\n\n   - 新增全文索引\n   - 新增空间索引\n   - 删除主键\n   - 修改列的数据类型\n   - 指定表的字符集\n   - 修改表的字符集\n\n更多详细的示例请参考上面的官方文档的地址。\n\n## 两个问题\n\n最后讨论两个非常容易混淆的问题：\n\n1. Online DDL 不会锁表，可以随意的执行。\n2. 对于支持 inplace 算法的 DDL，DDL 操作是原地修改数据，不需要额外的数据空间。\n\n### Q1: Online DDL 会不会锁表\n\nOnline DDL 会不会锁表？要回答这个问题，首先要明确“锁表”的含义。很多 MySQL 用户经常在表无法正常的进行 DML 时就觉得是锁表了，这种说法其实过于宽泛，实际上能够影响 DML 操作的锁至少包括以下几种（默认为 InnoDB 表）：\n\n- MDL 锁\n- 表锁\n- 行锁\n- GAP 锁\n\n其中除了 MDL 锁是在 Server 层加的之外，其它三种都是在 InnoDB 层加的。具体的加锁逻辑不在此进行展开，但是需要明确一点：所有的操作（不管是 DDL 还是 DML 还是查询语句）都需要先拿 Server 层的 MDL 锁，然后再去拿 InnoDB 层的某个需要的锁。一个 DDL 的基本过程是这样的：\n\n1. 首选，在开始进行 DDL 时，需要拿到对应表的 MDL X 锁，然后进行一系列的准备工作；\n2. 然后将 MDL X 锁降级为 MDL S 锁，进行真正的 DDL 操作；\n3. 最后再次将 MDL S 锁升级为 MDL X 锁，完成 DDL 操作，释放 MDL 锁；\n\n所以在真正执行 DDL 操作期间，确实是不会“锁表”的，但是如果在第一阶段拿 MDL X 锁时无法正常获取，那就可能真的会“锁表了”。一个简单的例子如下：\n\n```sql\n# session 1\nselect sleep(300) from mytest.t1;\n\n# session 2\noptimize table mytest.t1;\n\n# session 3\nselect * from mytest.t1;\n```\n\nsession 1 模拟了一个慢查询，然后 session 2 开始进行 DDL 操作，无法拿到 MDL X 锁，处于等到中。此时 session 3 需要执行一个查询，发现无法执行。实际上，在 session 1 介绍前，表 t1 的所有操作都无法进行了，也可以说表 t1 “锁表”了。\n\n明确了上面的概念之后，再回到我们的问题，Online DDL 是不是不锁表？如果非要回答，那么只能说，Online DDL 并不是绝对安全，更不是可以随意的执行。线上操作还是需要在业务低峰期谨慎操作。\n\n### Q2: inplace DDL 需不需要额外的数据空间\n\n前面我们提到过，MySQL 内部对于 DDL 的 algorithm 有两种选择：inplace 和 copy。copy 算法理解起来相对简单一点：创建一张临时表，然后将原表的数据 copy 到临时表中，最后再用临时表替换原表。对于上面的步骤，由于需要将原表的数据 copy 到临时表中，所以肯定需要消耗额外的数据空间。\n\n那么对于支持 inplace 算法的 DDL，是不是不需要额外的数据空间？答案是：需要。其实之所以会问这个问题，还是因为对 inplace 本身的理解出现了偏差。简单来说：inplace 描述的是表，而不是数据文件。只要不创建临时表，那么都是 inplace 的。\n\n实际上，很多 inplace DDL 都会重建表（会创建临时的数据文件），所以都会需要额外的数据空间，例如：\n\n- 添加主键\n- 删除并重新添加主键\n- 新增列（8.0 支持 instance DDL，不需要）\n- 删除列\n- 重新排序列\n- 删除列的默认值\n- 增加列的默认值\n- 修改表的 row_format\n- optimize table\n\n以上只是对 MySQL Online DDL 的一个简单的总结，更多细节的内容还需要大家去发掘。\n\n","slug":"mysql/online-ddl","published":1,"updated":"2020-12-05T12:02:24.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4xo001bgugm6uha3wln","content":"<p>关于 MySQL 的 Online DDL，网上有很多文章进行介绍，但是笔者浏览了部分文章，发现很多介绍都比较模糊，理解起来比较费劲。本文试图从使用者的角度对 MySQL Online DDL 进行一个直观的介绍。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"各版本支持情况\"><a href=\"#各版本支持情况\" class=\"headerlink\" title=\"各版本支持情况\"></a>各版本支持情况</h2><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.6/en/innodb-online-ddl-operations.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/5.6/en/innodb-online-ddl-operations.html</a></p>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-operations.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-operations.html</a></p>\n<p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html</a></p>\n</blockquote>\n<p>截止 20201118 社区各个版本的支持情况：</p>\n<img src=\"/images/online-ddl-1.jpg\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<img src=\"/images/online-ddl-2.jpg\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<img src=\"/images/online-ddl-3.jpg\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>结合上面的表格，对 MySQL 当前 DDL 的执行模式总结如下：</p>\n<ol>\n<li><p>Instance DDL 是 MySQL 8.0 引入的新功能，当前支持的范围较小，包括：</p>\n<ul>\n<li>修改二级索引的类型</li>\n<li>新增列</li>\n<li>修改列的默认值</li>\n<li>重命名表</li>\n</ul>\n</li>\n<li><p>在执行 DDL 操作时，MySQL 内部对于 algorithm 的选择策略是：如果用户显式指定了 algorithm，那么使用用户指定的选项；如果用户未指定，那么如果该操作支持 inplace 则优先选择 inplace，否则选择 copy；当前不支持 inplace 的操作主要有：</p>\n<ul>\n<li>删除主键</li>\n<li>修改列的数据类型</li>\n<li>修改表的字符集</li>\n</ul>\n</li>\n<li><p>我们常说的 Online DDL，其实是从 DML 操作的角度描述的，如果 DDL 操作不阻塞 DML 操作，那么这个 DDL 就是 Online 的。当前非 Online 的 DDL 其实已经比较少了，主要有：</p>\n<ul>\n<li>新增全文索引</li>\n<li>新增空间索引</li>\n<li>删除主键</li>\n<li>修改列的数据类型</li>\n<li>指定表的字符集</li>\n<li>修改表的字符集</li>\n</ul>\n</li>\n</ol>\n<p>更多详细的示例请参考上面的官方文档的地址。</p>\n<h2 id=\"两个问题\"><a href=\"#两个问题\" class=\"headerlink\" title=\"两个问题\"></a>两个问题</h2><p>最后讨论两个非常容易混淆的问题：</p>\n<ol>\n<li>Online DDL 不会锁表，可以随意的执行。</li>\n<li>对于支持 inplace 算法的 DDL，DDL 操作是原地修改数据，不需要额外的数据空间。</li>\n</ol>\n<h3 id=\"Q1-Online-DDL-会不会锁表\"><a href=\"#Q1-Online-DDL-会不会锁表\" class=\"headerlink\" title=\"Q1: Online DDL 会不会锁表\"></a>Q1: Online DDL 会不会锁表</h3><p>Online DDL 会不会锁表？要回答这个问题，首先要明确“锁表”的含义。很多 MySQL 用户经常在表无法正常的进行 DML 时就觉得是锁表了，这种说法其实过于宽泛，实际上能够影响 DML 操作的锁至少包括以下几种（默认为 InnoDB 表）：</p>\n<ul>\n<li>MDL 锁</li>\n<li>表锁</li>\n<li>行锁</li>\n<li>GAP 锁</li>\n</ul>\n<p>其中除了 MDL 锁是在 Server 层加的之外，其它三种都是在 InnoDB 层加的。具体的加锁逻辑不在此进行展开，但是需要明确一点：所有的操作（不管是 DDL 还是 DML 还是查询语句）都需要先拿 Server 层的 MDL 锁，然后再去拿 InnoDB 层的某个需要的锁。一个 DDL 的基本过程是这样的：</p>\n<ol>\n<li>首选，在开始进行 DDL 时，需要拿到对应表的 MDL X 锁，然后进行一系列的准备工作；</li>\n<li>然后将 MDL X 锁降级为 MDL S 锁，进行真正的 DDL 操作；</li>\n<li>最后再次将 MDL S 锁升级为 MDL X 锁，完成 DDL 操作，释放 MDL 锁；</li>\n</ol>\n<p>所以在真正执行 DDL 操作期间，确实是不会“锁表”的，但是如果在第一阶段拿 MDL X 锁时无法正常获取，那就可能真的会“锁表了”。一个简单的例子如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># session 1</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">sleep</span>(<span class=\"number\">300</span>) <span class=\"keyword\">from</span> mytest.t1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># session 2</span></span><br><span class=\"line\"><span class=\"keyword\">optimize</span> <span class=\"keyword\">table</span> mytest.t1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># session 3</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> mytest.t1;</span><br></pre></td></tr></table></figure>\n\n<p>session 1 模拟了一个慢查询，然后 session 2 开始进行 DDL 操作，无法拿到 MDL X 锁，处于等到中。此时 session 3 需要执行一个查询，发现无法执行。实际上，在 session 1 介绍前，表 t1 的所有操作都无法进行了，也可以说表 t1 “锁表”了。</p>\n<p>明确了上面的概念之后，再回到我们的问题，Online DDL 是不是不锁表？如果非要回答，那么只能说，Online DDL 并不是绝对安全，更不是可以随意的执行。线上操作还是需要在业务低峰期谨慎操作。</p>\n<h3 id=\"Q2-inplace-DDL-需不需要额外的数据空间\"><a href=\"#Q2-inplace-DDL-需不需要额外的数据空间\" class=\"headerlink\" title=\"Q2: inplace DDL 需不需要额外的数据空间\"></a>Q2: inplace DDL 需不需要额外的数据空间</h3><p>前面我们提到过，MySQL 内部对于 DDL 的 algorithm 有两种选择：inplace 和 copy。copy 算法理解起来相对简单一点：创建一张临时表，然后将原表的数据 copy 到临时表中，最后再用临时表替换原表。对于上面的步骤，由于需要将原表的数据 copy 到临时表中，所以肯定需要消耗额外的数据空间。</p>\n<p>那么对于支持 inplace 算法的 DDL，是不是不需要额外的数据空间？答案是：需要。其实之所以会问这个问题，还是因为对 inplace 本身的理解出现了偏差。简单来说：inplace 描述的是表，而不是数据文件。只要不创建临时表，那么都是 inplace 的。</p>\n<p>实际上，很多 inplace DDL 都会重建表（会创建临时的数据文件），所以都会需要额外的数据空间，例如：</p>\n<ul>\n<li>添加主键</li>\n<li>删除并重新添加主键</li>\n<li>新增列（8.0 支持 instance DDL，不需要）</li>\n<li>删除列</li>\n<li>重新排序列</li>\n<li>删除列的默认值</li>\n<li>增加列的默认值</li>\n<li>修改表的 row_format</li>\n<li>optimize table</li>\n</ul>\n<p>以上只是对 MySQL Online DDL 的一个简单的总结，更多细节的内容还需要大家去发掘。</p>\n","site":{"data":{}},"excerpt":"<p>关于 MySQL 的 Online DDL，网上有很多文章进行介绍，但是笔者浏览了部分文章，发现很多介绍都比较模糊，理解起来比较费劲。本文试图从使用者的角度对 MySQL Online DDL 进行一个直观的介绍。</p>","more":"<h2 id=\"各版本支持情况\"><a href=\"#各版本支持情况\" class=\"headerlink\" title=\"各版本支持情况\"></a>各版本支持情况</h2><blockquote>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.6/en/innodb-online-ddl-operations.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/5.6/en/innodb-online-ddl-operations.html</a></p>\n<p><a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-operations.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-operations.html</a></p>\n<p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html</a></p>\n</blockquote>\n<p>截止 20201118 社区各个版本的支持情况：</p>\n<img src=\"/images/online-ddl-1.jpg\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<img src=\"/images/online-ddl-2.jpg\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<img src=\"/images/online-ddl-3.jpg\" width=\"680px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>结合上面的表格，对 MySQL 当前 DDL 的执行模式总结如下：</p>\n<ol>\n<li><p>Instance DDL 是 MySQL 8.0 引入的新功能，当前支持的范围较小，包括：</p>\n<ul>\n<li>修改二级索引的类型</li>\n<li>新增列</li>\n<li>修改列的默认值</li>\n<li>重命名表</li>\n</ul>\n</li>\n<li><p>在执行 DDL 操作时，MySQL 内部对于 algorithm 的选择策略是：如果用户显式指定了 algorithm，那么使用用户指定的选项；如果用户未指定，那么如果该操作支持 inplace 则优先选择 inplace，否则选择 copy；当前不支持 inplace 的操作主要有：</p>\n<ul>\n<li>删除主键</li>\n<li>修改列的数据类型</li>\n<li>修改表的字符集</li>\n</ul>\n</li>\n<li><p>我们常说的 Online DDL，其实是从 DML 操作的角度描述的，如果 DDL 操作不阻塞 DML 操作，那么这个 DDL 就是 Online 的。当前非 Online 的 DDL 其实已经比较少了，主要有：</p>\n<ul>\n<li>新增全文索引</li>\n<li>新增空间索引</li>\n<li>删除主键</li>\n<li>修改列的数据类型</li>\n<li>指定表的字符集</li>\n<li>修改表的字符集</li>\n</ul>\n</li>\n</ol>\n<p>更多详细的示例请参考上面的官方文档的地址。</p>\n<h2 id=\"两个问题\"><a href=\"#两个问题\" class=\"headerlink\" title=\"两个问题\"></a>两个问题</h2><p>最后讨论两个非常容易混淆的问题：</p>\n<ol>\n<li>Online DDL 不会锁表，可以随意的执行。</li>\n<li>对于支持 inplace 算法的 DDL，DDL 操作是原地修改数据，不需要额外的数据空间。</li>\n</ol>\n<h3 id=\"Q1-Online-DDL-会不会锁表\"><a href=\"#Q1-Online-DDL-会不会锁表\" class=\"headerlink\" title=\"Q1: Online DDL 会不会锁表\"></a>Q1: Online DDL 会不会锁表</h3><p>Online DDL 会不会锁表？要回答这个问题，首先要明确“锁表”的含义。很多 MySQL 用户经常在表无法正常的进行 DML 时就觉得是锁表了，这种说法其实过于宽泛，实际上能够影响 DML 操作的锁至少包括以下几种（默认为 InnoDB 表）：</p>\n<ul>\n<li>MDL 锁</li>\n<li>表锁</li>\n<li>行锁</li>\n<li>GAP 锁</li>\n</ul>\n<p>其中除了 MDL 锁是在 Server 层加的之外，其它三种都是在 InnoDB 层加的。具体的加锁逻辑不在此进行展开，但是需要明确一点：所有的操作（不管是 DDL 还是 DML 还是查询语句）都需要先拿 Server 层的 MDL 锁，然后再去拿 InnoDB 层的某个需要的锁。一个 DDL 的基本过程是这样的：</p>\n<ol>\n<li>首选，在开始进行 DDL 时，需要拿到对应表的 MDL X 锁，然后进行一系列的准备工作；</li>\n<li>然后将 MDL X 锁降级为 MDL S 锁，进行真正的 DDL 操作；</li>\n<li>最后再次将 MDL S 锁升级为 MDL X 锁，完成 DDL 操作，释放 MDL 锁；</li>\n</ol>\n<p>所以在真正执行 DDL 操作期间，确实是不会“锁表”的，但是如果在第一阶段拿 MDL X 锁时无法正常获取，那就可能真的会“锁表了”。一个简单的例子如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># session 1</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">sleep</span>(<span class=\"number\">300</span>) <span class=\"keyword\">from</span> mytest.t1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># session 2</span></span><br><span class=\"line\"><span class=\"keyword\">optimize</span> <span class=\"keyword\">table</span> mytest.t1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># session 3</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> mytest.t1;</span><br></pre></td></tr></table></figure>\n\n<p>session 1 模拟了一个慢查询，然后 session 2 开始进行 DDL 操作，无法拿到 MDL X 锁，处于等到中。此时 session 3 需要执行一个查询，发现无法执行。实际上，在 session 1 介绍前，表 t1 的所有操作都无法进行了，也可以说表 t1 “锁表”了。</p>\n<p>明确了上面的概念之后，再回到我们的问题，Online DDL 是不是不锁表？如果非要回答，那么只能说，Online DDL 并不是绝对安全，更不是可以随意的执行。线上操作还是需要在业务低峰期谨慎操作。</p>\n<h3 id=\"Q2-inplace-DDL-需不需要额外的数据空间\"><a href=\"#Q2-inplace-DDL-需不需要额外的数据空间\" class=\"headerlink\" title=\"Q2: inplace DDL 需不需要额外的数据空间\"></a>Q2: inplace DDL 需不需要额外的数据空间</h3><p>前面我们提到过，MySQL 内部对于 DDL 的 algorithm 有两种选择：inplace 和 copy。copy 算法理解起来相对简单一点：创建一张临时表，然后将原表的数据 copy 到临时表中，最后再用临时表替换原表。对于上面的步骤，由于需要将原表的数据 copy 到临时表中，所以肯定需要消耗额外的数据空间。</p>\n<p>那么对于支持 inplace 算法的 DDL，是不是不需要额外的数据空间？答案是：需要。其实之所以会问这个问题，还是因为对 inplace 本身的理解出现了偏差。简单来说：inplace 描述的是表，而不是数据文件。只要不创建临时表，那么都是 inplace 的。</p>\n<p>实际上，很多 inplace DDL 都会重建表（会创建临时的数据文件），所以都会需要额外的数据空间，例如：</p>\n<ul>\n<li>添加主键</li>\n<li>删除并重新添加主键</li>\n<li>新增列（8.0 支持 instance DDL，不需要）</li>\n<li>删除列</li>\n<li>重新排序列</li>\n<li>删除列的默认值</li>\n<li>增加列的默认值</li>\n<li>修改表的 row_format</li>\n<li>optimize table</li>\n</ul>\n<p>以上只是对 MySQL Online DDL 的一个简单的总结，更多细节的内容还需要大家去发掘。</p>"},{"title":"一条 SQL 的执行过程","date":"2020-07-04T11:22:11.000Z","_content":"\n现代数据库是一个复杂的系统工程，但是一个典型的数据库系统都是由固定的部分组成，本文以一条 SQL 的执行过程作为入口，对数据库系统的全貌进行一个简单介绍。\n\n<!-- more -->\n\n## 整体架构\n\n如图所示是一个关系型数据库系统的简单架构图，可以看到数据系系统是一个典型的 CS 架构。以 MySQL 为例，一个典型的数据库系统通常由两部分组成：Server 和 Storage Engine。Server 层按照功能划分又可以分为：连接处理（Connection handler）、语法解析（Parser）、优化器（Optimizer）、执行器（Executor）等部分。Storage Engine 也可以有不同的实现方式。\n\n<img src=\"/images/sql-execute-1.jpg\" width=\"780px\"/>\n\n## SQL 执行过程\n\n还是以 MySQL 为例，介绍一条 SQL 的完整执行过程，其它关系型数据库的执行过程与 MySQL 基本类似。\n\n### 连接处理\n\nMySQL 客户端和服务端之间支持多种通信方式，除了最常用的 TCP 通讯外，还支持命名管道和共享内存的方式。以 TCP 通讯为例，MySQL 客户端与服务端的交互主要分为两个阶段：握手认证阶段和命令执行阶段。一次正常的连接过程如下：\n\n```sql\n# 1. 建立 TCP 连接\n\n# 2. 建立 MySQL 连接，协议认证\n\n# 3. 认证通过，等待执行命令\n\n# 4. 断开 MySQL 连接\n\n# 5. 断开 TCP 连接\n```\n\n其中，协议认证过程阶段就会对连接进行 ACL 认证，具体的认证过程和逻辑在此不作过多介绍，认证通过之后，就可以开始正式执行命令了。关于 MySQL 通讯协议的更多介绍，可以参考[这篇文章](https://jin-yang.github.io/post/mysql-protocol.html)。\n\n### 语法解析\n\nSQL 语法的设计也是数据库流行的一个重要原因，相比于传统的检索方式，SQL 语法可以说是相当的简单而且可读性高。SQL 语法有一个语法标准，但是各个数据库在实现的时候都会有自己的特点，以 MySQL 为例，MySQL 也只是兼容了部分 SQL 标准，对此社区有一个[说明](https://dev.mysql.com/doc/refman/8.0/en/compatibility.html)。\n\n语法解析阶段其实包括了：词法分析和语法分析。当前最常用的语法解析方案是 [LEX & YACC](http://dinosaur.compilertools.net/) 的方案，这也是数据库系统里面用的最多的方案。MySQL 采用了一种比较有趣的组合，MySQL 并没有直接使用 LEX 作为词法分析的方案，而是手写了一套词法分析逻辑，但是语法分析依然采用了 YACC。关于 MySQL 语法解析的逻辑，后面会再写一篇文章来进行介绍。需要知道的是：语法解析过程会生成一棵语法树（Lex tree），原始 SQL 中的所有信息都会被记录在这棵树中。\n\n注意：并不是所有的语句都需要经过语法解析的阶段，MySQL 内部实现了一套 Query Cache 机制，针对查询语句进行缓存，当缓存命中时，可以直接返回结果，此时不需要经过语法解析。\n\n### 优化器\n\n顾名思义，优化器的目的就是对用户的查询语句进行优化，找到一个合理的执行计划。之所以说是合理的执行计划，因为优化器本身并不保证所有的执行计划是最优的，而是尽量找到一个可以接受的执行计划。近些年，随着数据的膨胀和数据库本身的发展，对于优化器的研究也变得越来越热门，传统的 OLTP 型数据库也开始借鉴 OLAP 型数据库的优化思路。回到优化器本身，其要做的事情是：确定数据的读取方式和数据的计算方式。\n\n一个最简单的例子，在使用数据库的过程中，当查询很慢的时候，DBA 首先会告诉你的就是：“看一下有没有有索引”。这里面索引的选择就是优化器的工作。\n\n### 执行器\n\n和优化器对应，执行器的工作是执行数据的读取和计算。和存储引擎的交互也都是在执行器内完成。在开始执行前，MySQL 会首先检查一下执行权限，如果没有对应表的权限，会直接返回没有权限的错误。如果有权限，则会根据表的引擎类型，按照优化器生成的执行计划，调用具体的接口进行处理。\n\n### 存储引擎\n\nMySQL 在设计之初就是一个支持多引擎的结构，MySQL 在执行器层定义了一个 handler 接口，接口内描述了所有执行器需要用到的基本操作，所有的存储引擎都需要实现相应的接口。常用的存储引擎包括：MyISAM、InnoDB、CSV、RocksDB等。多引擎的设计确实让 MySQL 拥有了很好的可扩展性，用户可以根据需要在表级指定存储引擎。但是随着 InnoDB 成为 MySQL  的默认引擎，特别是 8.0 版本开始使用 InnoDB 保存数据字典，这种多引擎的支持也会慢慢退出历史舞台。\n\n以上结合数据库的基本架构简单介绍了一条 SQL 的执行过程，当然实际的执行过程远比这个复杂，后续会对各个部分展开说明。","source":"_posts/mysql/sql-execute.md","raw":"---\ntitle: 一条 SQL 的执行过程\ndate: 2020-07-04 19:22:11\ntags:\n- 架构\ncategories: \n- MySQL\n\n---\n\n现代数据库是一个复杂的系统工程，但是一个典型的数据库系统都是由固定的部分组成，本文以一条 SQL 的执行过程作为入口，对数据库系统的全貌进行一个简单介绍。\n\n<!-- more -->\n\n## 整体架构\n\n如图所示是一个关系型数据库系统的简单架构图，可以看到数据系系统是一个典型的 CS 架构。以 MySQL 为例，一个典型的数据库系统通常由两部分组成：Server 和 Storage Engine。Server 层按照功能划分又可以分为：连接处理（Connection handler）、语法解析（Parser）、优化器（Optimizer）、执行器（Executor）等部分。Storage Engine 也可以有不同的实现方式。\n\n<img src=\"/images/sql-execute-1.jpg\" width=\"780px\"/>\n\n## SQL 执行过程\n\n还是以 MySQL 为例，介绍一条 SQL 的完整执行过程，其它关系型数据库的执行过程与 MySQL 基本类似。\n\n### 连接处理\n\nMySQL 客户端和服务端之间支持多种通信方式，除了最常用的 TCP 通讯外，还支持命名管道和共享内存的方式。以 TCP 通讯为例，MySQL 客户端与服务端的交互主要分为两个阶段：握手认证阶段和命令执行阶段。一次正常的连接过程如下：\n\n```sql\n# 1. 建立 TCP 连接\n\n# 2. 建立 MySQL 连接，协议认证\n\n# 3. 认证通过，等待执行命令\n\n# 4. 断开 MySQL 连接\n\n# 5. 断开 TCP 连接\n```\n\n其中，协议认证过程阶段就会对连接进行 ACL 认证，具体的认证过程和逻辑在此不作过多介绍，认证通过之后，就可以开始正式执行命令了。关于 MySQL 通讯协议的更多介绍，可以参考[这篇文章](https://jin-yang.github.io/post/mysql-protocol.html)。\n\n### 语法解析\n\nSQL 语法的设计也是数据库流行的一个重要原因，相比于传统的检索方式，SQL 语法可以说是相当的简单而且可读性高。SQL 语法有一个语法标准，但是各个数据库在实现的时候都会有自己的特点，以 MySQL 为例，MySQL 也只是兼容了部分 SQL 标准，对此社区有一个[说明](https://dev.mysql.com/doc/refman/8.0/en/compatibility.html)。\n\n语法解析阶段其实包括了：词法分析和语法分析。当前最常用的语法解析方案是 [LEX & YACC](http://dinosaur.compilertools.net/) 的方案，这也是数据库系统里面用的最多的方案。MySQL 采用了一种比较有趣的组合，MySQL 并没有直接使用 LEX 作为词法分析的方案，而是手写了一套词法分析逻辑，但是语法分析依然采用了 YACC。关于 MySQL 语法解析的逻辑，后面会再写一篇文章来进行介绍。需要知道的是：语法解析过程会生成一棵语法树（Lex tree），原始 SQL 中的所有信息都会被记录在这棵树中。\n\n注意：并不是所有的语句都需要经过语法解析的阶段，MySQL 内部实现了一套 Query Cache 机制，针对查询语句进行缓存，当缓存命中时，可以直接返回结果，此时不需要经过语法解析。\n\n### 优化器\n\n顾名思义，优化器的目的就是对用户的查询语句进行优化，找到一个合理的执行计划。之所以说是合理的执行计划，因为优化器本身并不保证所有的执行计划是最优的，而是尽量找到一个可以接受的执行计划。近些年，随着数据的膨胀和数据库本身的发展，对于优化器的研究也变得越来越热门，传统的 OLTP 型数据库也开始借鉴 OLAP 型数据库的优化思路。回到优化器本身，其要做的事情是：确定数据的读取方式和数据的计算方式。\n\n一个最简单的例子，在使用数据库的过程中，当查询很慢的时候，DBA 首先会告诉你的就是：“看一下有没有有索引”。这里面索引的选择就是优化器的工作。\n\n### 执行器\n\n和优化器对应，执行器的工作是执行数据的读取和计算。和存储引擎的交互也都是在执行器内完成。在开始执行前，MySQL 会首先检查一下执行权限，如果没有对应表的权限，会直接返回没有权限的错误。如果有权限，则会根据表的引擎类型，按照优化器生成的执行计划，调用具体的接口进行处理。\n\n### 存储引擎\n\nMySQL 在设计之初就是一个支持多引擎的结构，MySQL 在执行器层定义了一个 handler 接口，接口内描述了所有执行器需要用到的基本操作，所有的存储引擎都需要实现相应的接口。常用的存储引擎包括：MyISAM、InnoDB、CSV、RocksDB等。多引擎的设计确实让 MySQL 拥有了很好的可扩展性，用户可以根据需要在表级指定存储引擎。但是随着 InnoDB 成为 MySQL  的默认引擎，特别是 8.0 版本开始使用 InnoDB 保存数据字典，这种多引擎的支持也会慢慢退出历史舞台。\n\n以上结合数据库的基本架构简单介绍了一条 SQL 的执行过程，当然实际的执行过程远比这个复杂，后续会对各个部分展开说明。","slug":"mysql/sql-execute","published":1,"updated":"2020-12-05T12:02:34.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4xq001fgugmaf8g6e0c","content":"<p>现代数据库是一个复杂的系统工程，但是一个典型的数据库系统都是由固定的部分组成，本文以一条 SQL 的执行过程作为入口，对数据库系统的全貌进行一个简单介绍。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"整体架构\"><a href=\"#整体架构\" class=\"headerlink\" title=\"整体架构\"></a>整体架构</h2><p>如图所示是一个关系型数据库系统的简单架构图，可以看到数据系系统是一个典型的 CS 架构。以 MySQL 为例，一个典型的数据库系统通常由两部分组成：Server 和 Storage Engine。Server 层按照功能划分又可以分为：连接处理（Connection handler）、语法解析（Parser）、优化器（Optimizer）、执行器（Executor）等部分。Storage Engine 也可以有不同的实现方式。</p>\n<img src=\"/images/sql-execute-1.jpg\" width=\"780px\"/>\n\n<h2 id=\"SQL-执行过程\"><a href=\"#SQL-执行过程\" class=\"headerlink\" title=\"SQL 执行过程\"></a>SQL 执行过程</h2><p>还是以 MySQL 为例，介绍一条 SQL 的完整执行过程，其它关系型数据库的执行过程与 MySQL 基本类似。</p>\n<h3 id=\"连接处理\"><a href=\"#连接处理\" class=\"headerlink\" title=\"连接处理\"></a>连接处理</h3><p>MySQL 客户端和服务端之间支持多种通信方式，除了最常用的 TCP 通讯外，还支持命名管道和共享内存的方式。以 TCP 通讯为例，MySQL 客户端与服务端的交互主要分为两个阶段：握手认证阶段和命令执行阶段。一次正常的连接过程如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 建立 TCP 连接</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 建立 MySQL 连接，协议认证</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 认证通过，等待执行命令</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 断开 MySQL 连接</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 断开 TCP 连接</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，协议认证过程阶段就会对连接进行 ACL 认证，具体的认证过程和逻辑在此不作过多介绍，认证通过之后，就可以开始正式执行命令了。关于 MySQL 通讯协议的更多介绍，可以参考<a href=\"https://jin-yang.github.io/post/mysql-protocol.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<h3 id=\"语法解析\"><a href=\"#语法解析\" class=\"headerlink\" title=\"语法解析\"></a>语法解析</h3><p>SQL 语法的设计也是数据库流行的一个重要原因，相比于传统的检索方式，SQL 语法可以说是相当的简单而且可读性高。SQL 语法有一个语法标准，但是各个数据库在实现的时候都会有自己的特点，以 MySQL 为例，MySQL 也只是兼容了部分 SQL 标准，对此社区有一个<a href=\"https://dev.mysql.com/doc/refman/8.0/en/compatibility.html\" target=\"_blank\" rel=\"noopener\">说明</a>。</p>\n<p>语法解析阶段其实包括了：词法分析和语法分析。当前最常用的语法解析方案是 <a href=\"http://dinosaur.compilertools.net/\" target=\"_blank\" rel=\"noopener\">LEX &amp; YACC</a> 的方案，这也是数据库系统里面用的最多的方案。MySQL 采用了一种比较有趣的组合，MySQL 并没有直接使用 LEX 作为词法分析的方案，而是手写了一套词法分析逻辑，但是语法分析依然采用了 YACC。关于 MySQL 语法解析的逻辑，后面会再写一篇文章来进行介绍。需要知道的是：语法解析过程会生成一棵语法树（Lex tree），原始 SQL 中的所有信息都会被记录在这棵树中。</p>\n<p>注意：并不是所有的语句都需要经过语法解析的阶段，MySQL 内部实现了一套 Query Cache 机制，针对查询语句进行缓存，当缓存命中时，可以直接返回结果，此时不需要经过语法解析。</p>\n<h3 id=\"优化器\"><a href=\"#优化器\" class=\"headerlink\" title=\"优化器\"></a>优化器</h3><p>顾名思义，优化器的目的就是对用户的查询语句进行优化，找到一个合理的执行计划。之所以说是合理的执行计划，因为优化器本身并不保证所有的执行计划是最优的，而是尽量找到一个可以接受的执行计划。近些年，随着数据的膨胀和数据库本身的发展，对于优化器的研究也变得越来越热门，传统的 OLTP 型数据库也开始借鉴 OLAP 型数据库的优化思路。回到优化器本身，其要做的事情是：确定数据的读取方式和数据的计算方式。</p>\n<p>一个最简单的例子，在使用数据库的过程中，当查询很慢的时候，DBA 首先会告诉你的就是：“看一下有没有有索引”。这里面索引的选择就是优化器的工作。</p>\n<h3 id=\"执行器\"><a href=\"#执行器\" class=\"headerlink\" title=\"执行器\"></a>执行器</h3><p>和优化器对应，执行器的工作是执行数据的读取和计算。和存储引擎的交互也都是在执行器内完成。在开始执行前，MySQL 会首先检查一下执行权限，如果没有对应表的权限，会直接返回没有权限的错误。如果有权限，则会根据表的引擎类型，按照优化器生成的执行计划，调用具体的接口进行处理。</p>\n<h3 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h3><p>MySQL 在设计之初就是一个支持多引擎的结构，MySQL 在执行器层定义了一个 handler 接口，接口内描述了所有执行器需要用到的基本操作，所有的存储引擎都需要实现相应的接口。常用的存储引擎包括：MyISAM、InnoDB、CSV、RocksDB等。多引擎的设计确实让 MySQL 拥有了很好的可扩展性，用户可以根据需要在表级指定存储引擎。但是随着 InnoDB 成为 MySQL  的默认引擎，特别是 8.0 版本开始使用 InnoDB 保存数据字典，这种多引擎的支持也会慢慢退出历史舞台。</p>\n<p>以上结合数据库的基本架构简单介绍了一条 SQL 的执行过程，当然实际的执行过程远比这个复杂，后续会对各个部分展开说明。</p>\n","site":{"data":{}},"excerpt":"<p>现代数据库是一个复杂的系统工程，但是一个典型的数据库系统都是由固定的部分组成，本文以一条 SQL 的执行过程作为入口，对数据库系统的全貌进行一个简单介绍。</p>","more":"<h2 id=\"整体架构\"><a href=\"#整体架构\" class=\"headerlink\" title=\"整体架构\"></a>整体架构</h2><p>如图所示是一个关系型数据库系统的简单架构图，可以看到数据系系统是一个典型的 CS 架构。以 MySQL 为例，一个典型的数据库系统通常由两部分组成：Server 和 Storage Engine。Server 层按照功能划分又可以分为：连接处理（Connection handler）、语法解析（Parser）、优化器（Optimizer）、执行器（Executor）等部分。Storage Engine 也可以有不同的实现方式。</p>\n<img src=\"/images/sql-execute-1.jpg\" width=\"780px\"/>\n\n<h2 id=\"SQL-执行过程\"><a href=\"#SQL-执行过程\" class=\"headerlink\" title=\"SQL 执行过程\"></a>SQL 执行过程</h2><p>还是以 MySQL 为例，介绍一条 SQL 的完整执行过程，其它关系型数据库的执行过程与 MySQL 基本类似。</p>\n<h3 id=\"连接处理\"><a href=\"#连接处理\" class=\"headerlink\" title=\"连接处理\"></a>连接处理</h3><p>MySQL 客户端和服务端之间支持多种通信方式，除了最常用的 TCP 通讯外，还支持命名管道和共享内存的方式。以 TCP 通讯为例，MySQL 客户端与服务端的交互主要分为两个阶段：握手认证阶段和命令执行阶段。一次正常的连接过程如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 建立 TCP 连接</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 建立 MySQL 连接，协议认证</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 认证通过，等待执行命令</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 断开 MySQL 连接</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 断开 TCP 连接</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，协议认证过程阶段就会对连接进行 ACL 认证，具体的认证过程和逻辑在此不作过多介绍，认证通过之后，就可以开始正式执行命令了。关于 MySQL 通讯协议的更多介绍，可以参考<a href=\"https://jin-yang.github.io/post/mysql-protocol.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<h3 id=\"语法解析\"><a href=\"#语法解析\" class=\"headerlink\" title=\"语法解析\"></a>语法解析</h3><p>SQL 语法的设计也是数据库流行的一个重要原因，相比于传统的检索方式，SQL 语法可以说是相当的简单而且可读性高。SQL 语法有一个语法标准，但是各个数据库在实现的时候都会有自己的特点，以 MySQL 为例，MySQL 也只是兼容了部分 SQL 标准，对此社区有一个<a href=\"https://dev.mysql.com/doc/refman/8.0/en/compatibility.html\" target=\"_blank\" rel=\"noopener\">说明</a>。</p>\n<p>语法解析阶段其实包括了：词法分析和语法分析。当前最常用的语法解析方案是 <a href=\"http://dinosaur.compilertools.net/\" target=\"_blank\" rel=\"noopener\">LEX &amp; YACC</a> 的方案，这也是数据库系统里面用的最多的方案。MySQL 采用了一种比较有趣的组合，MySQL 并没有直接使用 LEX 作为词法分析的方案，而是手写了一套词法分析逻辑，但是语法分析依然采用了 YACC。关于 MySQL 语法解析的逻辑，后面会再写一篇文章来进行介绍。需要知道的是：语法解析过程会生成一棵语法树（Lex tree），原始 SQL 中的所有信息都会被记录在这棵树中。</p>\n<p>注意：并不是所有的语句都需要经过语法解析的阶段，MySQL 内部实现了一套 Query Cache 机制，针对查询语句进行缓存，当缓存命中时，可以直接返回结果，此时不需要经过语法解析。</p>\n<h3 id=\"优化器\"><a href=\"#优化器\" class=\"headerlink\" title=\"优化器\"></a>优化器</h3><p>顾名思义，优化器的目的就是对用户的查询语句进行优化，找到一个合理的执行计划。之所以说是合理的执行计划，因为优化器本身并不保证所有的执行计划是最优的，而是尽量找到一个可以接受的执行计划。近些年，随着数据的膨胀和数据库本身的发展，对于优化器的研究也变得越来越热门，传统的 OLTP 型数据库也开始借鉴 OLAP 型数据库的优化思路。回到优化器本身，其要做的事情是：确定数据的读取方式和数据的计算方式。</p>\n<p>一个最简单的例子，在使用数据库的过程中，当查询很慢的时候，DBA 首先会告诉你的就是：“看一下有没有有索引”。这里面索引的选择就是优化器的工作。</p>\n<h3 id=\"执行器\"><a href=\"#执行器\" class=\"headerlink\" title=\"执行器\"></a>执行器</h3><p>和优化器对应，执行器的工作是执行数据的读取和计算。和存储引擎的交互也都是在执行器内完成。在开始执行前，MySQL 会首先检查一下执行权限，如果没有对应表的权限，会直接返回没有权限的错误。如果有权限，则会根据表的引擎类型，按照优化器生成的执行计划，调用具体的接口进行处理。</p>\n<h3 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h3><p>MySQL 在设计之初就是一个支持多引擎的结构，MySQL 在执行器层定义了一个 handler 接口，接口内描述了所有执行器需要用到的基本操作，所有的存储引擎都需要实现相应的接口。常用的存储引擎包括：MyISAM、InnoDB、CSV、RocksDB等。多引擎的设计确实让 MySQL 拥有了很好的可扩展性，用户可以根据需要在表级指定存储引擎。但是随着 InnoDB 成为 MySQL  的默认引擎，特别是 8.0 版本开始使用 InnoDB 保存数据字典，这种多引擎的支持也会慢慢退出历史舞台。</p>\n<p>以上结合数据库的基本架构简单介绍了一条 SQL 的执行过程，当然实际的执行过程远比这个复杂，后续会对各个部分展开说明。</p>"},{"title":"MySQL Atomic DDL","date":"2020-12-05T12:03:12.000Z","_content":"\nAtomic DDL 是 MySQL 8.0 的重要特征之一，关于 Atomic DDL 的介绍文档，流传比较广泛的就是参考文献中提到的两篇文章，文章中对 Atomic DDL 的实现思想和基本过程进行了介绍，建议大家阅读一下。本文尝试对完整的建表/删表过程进行分析。\n\n<!-- more -->\n\n## 建表过程\n\n```c++\n|--> mysql_create_table\n|    |--> open_tables\n|    |    |--> open_and_process_table\n|    |    |    |--> open_table  // 打开表\n|    |    |    |    |--> check_if_table_exists\n|    |    |    |    |    |--> dd::table_exists\n|    |    |    |    |    |    |--> client->acquire // dd::Abstract_table\n|    |    |    |    |\n|    |    |    |    |--> tc->get_table  //  从 Table_cache_manager 查找\n|    |    |    |    |\n|    |    |    |    |--> get_table_share_with_discover  // 构建 TABLE_SHARE\n|    |    |    |    |    |--> get_table_share\n|    |    |    |    |    |    |--> table_def_cache->find  // 从 Table_definition_cache 查找\n|    |    |    |    |    |    |--> process_found_table_share\n|    |    |    |    |    |    |\n|    |    |    |    |    |    |--> alloc_table_share\n|    |    |    |    |    |    |--> table_def_cache->emplace  // 维护 Table_definition_cache\n|    |    |    |    |    |    |\n|    |    |    |    |    |    |--> thd->dd_client()->acquire\n|    |    |    |    |    |    |--> open_table_def\n|    |    |    |    |\n|    |    |    |    |--> open_table_from_share  // 通过 TABLE_SHARE 打开 TABLE\n|    |    |    |    |    |--> ha_open\n|    |    |    |    |    |    |--> ha_innobase::open // 打开一个 innodb 表\n|    |    |    |    |    |    |    |--> lookup_table_handler\n|    |    |    |    |    |    |    |--> dict_table_check_if_in_cache_low\n|    |    |    |    |    |    |    |--> dd_open_table\n|    |    |    |    |    |    |    |    |--> dd_open_table_one\n|    |    |    |    |    |    |    |\n|    |    |    |    |    |    |    |--> row_create_prebuilt\n|    |    |    |    |    |    |    |--> info(...)\n|    |    |    |    |    |    |    |    |--> info_low\n|    |    |    |    |    |    |    |    |    |--> update_thd\n|    |    |    |    |    |    |    |    |    |    |--> row_update_prebuilt_trx\n|    |    |    |    |\n|    |    |    |    |--> tc->add_used_table  // 添加到 Table_cache_manager\n|    |    |    |    |\n|    |    |    |    |--> thd->set_open_tables\n|    |    |    |    |--> table->init\n|    |\n|    |--> mysql_create_table_no_lock\n|    |    |--> create_table_impl\n|    |    |    |--> check_engine\n|    |    |    |--> set_table_default_charset\n|    |    |    |--> get_new_handler\n|    |    |    |\n|    |    |    |--> check_if_table_exists\n|    |    |    |\n|    |    |    |--> mysql_prepare_create_table\n|    |    |    |\n|    |    |    |--> rea_create_base_table\n|    |    |    |    |--> dd::create_table\n|    |    |    |    |    |--> dict->get_dd_table\n|    |    |    |    |    |--> create_dd_user_table\n|    |    |    |    |    |--> fill_dd_table_from_create_info\n|    |    |    |    |    |    |--> fill_dd_columns_from_create_fields\n|    |    |    |    |    |    |--> fill_dd_indexes_from_keyinfo\n|    |    |    |    |    |    |--> file->get_extra_columns_and_keys\n|    |    |    |    |\n|    |    |    |    |--> thd->dd_client()->store // dd::Table\n|    |    |    |    |--> thd->dd_client()->acquire_for_modification\n|    |    |    |    |\n|    |    |    |    |--> ha_create_table\n|    |\n|    |--> trans_commit_stmt\n|    |--> trans_commit_implicit\n|    |    |--> thd->dd_client()->commit_modified_objects\n|    |    |    |--> remove_uncommitted_objects // dd::Abstract_table + dd::Tablespace\n|    |    |    |    |--> invalidate\n|    |\n|    |--> trans_rollback_stmt\n|    |--> trans_rollback\n|    |    |--> thd->dd_client()->rollback_modified_objects\n|    |    |    |--> remove_uncommitted_objects\n|    |\n|    |--> post_ddl\n```\n\n\n\n```c++\n|--> create_impl\n|    |--> create_table\n|    |    |--> create_table_def\n|    |    |    |--> dict_mem_table_create\n|    |    |    |--> row_create_table_for_mysql\n|    |    |    |    |--> dict_build_table_def\n|    |    |    |    |    |--> dict_build_table_space_for_table\n|    |    |    |    |    |    |--> log_ddl->write_delete_space_log\n|    |    |    |    |    |    |--> fil_ibd_create\n|    |    |    |    |\n|    |    |    |    |--> dict_table_add_system_columns\n|    |    |    |    |\n|    |    |    |    |--> dict_table_add_to_cache\n|    |    |    |    |--> log_ddl->write_remove_cache_log\n|    |    |\n|    |    |--> create_index\n|    |    |    |--> dict_mem_index_create\n|    |    |    |--> row_create_index_for_mysql\n|    |    |    |    |--> dict_build_index_def\n|    |    |    |    |\n|    |    |    |    |--> dict_index_add_to_cache_w_vcol\n|    |    |    |    |    |--> dict_index_build_internal_clust\n|    |    |    |    |    |--> dict_index_build_internal_non_clust\n|    |    |    |    |\n|    |    |    |    |--> dict_create_index_tree_in_mem\n|    |    |    |    |    |--> btr_create\n|    |    |    |    |    |--> log_ddl->write_free_tree_log\n|    |\n|    |--> create_table_update_global_dd\n|    |    |--> dd_create_implicit_tablespace\n|    |    |    |--> dd_create_tablespace\n|    |    |    |    |--> dd_client->store // dd::Tablespace\n|    |\n|    |--> create_table_update_dict\n```\n\n\n\n```c++\n/* Dictionary_client 操作 */\n\n|--> acquire\n|    |--> acquire_uncommitted\n|    |\n|    |--> m_registry_committed.get\n|    |\n|    |--> Shared_dictionary_cache::instance()->get\n|    |    |--> m_map<T>()->get\n|    |    |\n|    |    |--> get_uncached\n|    |    |    |--> Storage_adapter::get\n|    |    |    |    |--> instance()->core_get\n|    |    |    |    |    |--> m_core_registry.get\n|    |    |    |    |\n|    |    |    |    |--> trx.otx.get_table // 从系统表读取\n|    |    |\n|    |    |--> m_map<T>()->put\n|    |\n|    |--> m_registry_committed.put\n\n\n\n|--> store\n|    |--> m_registry_committed.get // 检查\n|    |\n|    |--> Storage_adapter::store // 保存\n|    |    |--> instance()->core_store\n|    |    |    |--> m_core_registry.put\n|    |    |\n|    |    |--> object->impl()->store // 保存到系统表\n|    |    |--> sdi::store\n|    |\n|    |--> register_uncommitted_object\n|    |    |--> m_registry_committed.get\n|    |    |--> m_registry_dropped.get\n|    |    |--> m_registry_uncommitted.put\n```\n\n## 删表过程\n\n```c++\n|--> mysql_rm_table\n|    |--> mysql_rm_table_no_locks\n|    |    |--> drop_base_table\n|    |    |    |--> ha_delete_table\n|    |    |    |\n|    |    |    |--> dd::drop_table\n|    |    |\n|    |    |--> post_ddl\n```\n\n\n\n```c++\n|--> delete_impl\n|    |--> row_drop_table_for_mysql\n|    |    |--> row_drop_table_from_cache\n|    |    |--> log_ddl->write_drop_log\n|    |    |--> log_ddl->write_delete_space_log\n|    |\n|    |--> dd_drop_tablespace\n```\n\n## 参考文献\n\n> http://mysql.taobao.org/monthly/2018/03/02/\n>\n> http://mysql.taobao.org/monthly/2018/07/02/","source":"_posts/mysql/atomic-ddl.md","raw":"---\ntitle: MySQL Atomic DDL\ndate: 2020-12-05 20:03:12\ntags:\n- Feature\ncategories: \n- MySQL\n\n---\n\nAtomic DDL 是 MySQL 8.0 的重要特征之一，关于 Atomic DDL 的介绍文档，流传比较广泛的就是参考文献中提到的两篇文章，文章中对 Atomic DDL 的实现思想和基本过程进行了介绍，建议大家阅读一下。本文尝试对完整的建表/删表过程进行分析。\n\n<!-- more -->\n\n## 建表过程\n\n```c++\n|--> mysql_create_table\n|    |--> open_tables\n|    |    |--> open_and_process_table\n|    |    |    |--> open_table  // 打开表\n|    |    |    |    |--> check_if_table_exists\n|    |    |    |    |    |--> dd::table_exists\n|    |    |    |    |    |    |--> client->acquire // dd::Abstract_table\n|    |    |    |    |\n|    |    |    |    |--> tc->get_table  //  从 Table_cache_manager 查找\n|    |    |    |    |\n|    |    |    |    |--> get_table_share_with_discover  // 构建 TABLE_SHARE\n|    |    |    |    |    |--> get_table_share\n|    |    |    |    |    |    |--> table_def_cache->find  // 从 Table_definition_cache 查找\n|    |    |    |    |    |    |--> process_found_table_share\n|    |    |    |    |    |    |\n|    |    |    |    |    |    |--> alloc_table_share\n|    |    |    |    |    |    |--> table_def_cache->emplace  // 维护 Table_definition_cache\n|    |    |    |    |    |    |\n|    |    |    |    |    |    |--> thd->dd_client()->acquire\n|    |    |    |    |    |    |--> open_table_def\n|    |    |    |    |\n|    |    |    |    |--> open_table_from_share  // 通过 TABLE_SHARE 打开 TABLE\n|    |    |    |    |    |--> ha_open\n|    |    |    |    |    |    |--> ha_innobase::open // 打开一个 innodb 表\n|    |    |    |    |    |    |    |--> lookup_table_handler\n|    |    |    |    |    |    |    |--> dict_table_check_if_in_cache_low\n|    |    |    |    |    |    |    |--> dd_open_table\n|    |    |    |    |    |    |    |    |--> dd_open_table_one\n|    |    |    |    |    |    |    |\n|    |    |    |    |    |    |    |--> row_create_prebuilt\n|    |    |    |    |    |    |    |--> info(...)\n|    |    |    |    |    |    |    |    |--> info_low\n|    |    |    |    |    |    |    |    |    |--> update_thd\n|    |    |    |    |    |    |    |    |    |    |--> row_update_prebuilt_trx\n|    |    |    |    |\n|    |    |    |    |--> tc->add_used_table  // 添加到 Table_cache_manager\n|    |    |    |    |\n|    |    |    |    |--> thd->set_open_tables\n|    |    |    |    |--> table->init\n|    |\n|    |--> mysql_create_table_no_lock\n|    |    |--> create_table_impl\n|    |    |    |--> check_engine\n|    |    |    |--> set_table_default_charset\n|    |    |    |--> get_new_handler\n|    |    |    |\n|    |    |    |--> check_if_table_exists\n|    |    |    |\n|    |    |    |--> mysql_prepare_create_table\n|    |    |    |\n|    |    |    |--> rea_create_base_table\n|    |    |    |    |--> dd::create_table\n|    |    |    |    |    |--> dict->get_dd_table\n|    |    |    |    |    |--> create_dd_user_table\n|    |    |    |    |    |--> fill_dd_table_from_create_info\n|    |    |    |    |    |    |--> fill_dd_columns_from_create_fields\n|    |    |    |    |    |    |--> fill_dd_indexes_from_keyinfo\n|    |    |    |    |    |    |--> file->get_extra_columns_and_keys\n|    |    |    |    |\n|    |    |    |    |--> thd->dd_client()->store // dd::Table\n|    |    |    |    |--> thd->dd_client()->acquire_for_modification\n|    |    |    |    |\n|    |    |    |    |--> ha_create_table\n|    |\n|    |--> trans_commit_stmt\n|    |--> trans_commit_implicit\n|    |    |--> thd->dd_client()->commit_modified_objects\n|    |    |    |--> remove_uncommitted_objects // dd::Abstract_table + dd::Tablespace\n|    |    |    |    |--> invalidate\n|    |\n|    |--> trans_rollback_stmt\n|    |--> trans_rollback\n|    |    |--> thd->dd_client()->rollback_modified_objects\n|    |    |    |--> remove_uncommitted_objects\n|    |\n|    |--> post_ddl\n```\n\n\n\n```c++\n|--> create_impl\n|    |--> create_table\n|    |    |--> create_table_def\n|    |    |    |--> dict_mem_table_create\n|    |    |    |--> row_create_table_for_mysql\n|    |    |    |    |--> dict_build_table_def\n|    |    |    |    |    |--> dict_build_table_space_for_table\n|    |    |    |    |    |    |--> log_ddl->write_delete_space_log\n|    |    |    |    |    |    |--> fil_ibd_create\n|    |    |    |    |\n|    |    |    |    |--> dict_table_add_system_columns\n|    |    |    |    |\n|    |    |    |    |--> dict_table_add_to_cache\n|    |    |    |    |--> log_ddl->write_remove_cache_log\n|    |    |\n|    |    |--> create_index\n|    |    |    |--> dict_mem_index_create\n|    |    |    |--> row_create_index_for_mysql\n|    |    |    |    |--> dict_build_index_def\n|    |    |    |    |\n|    |    |    |    |--> dict_index_add_to_cache_w_vcol\n|    |    |    |    |    |--> dict_index_build_internal_clust\n|    |    |    |    |    |--> dict_index_build_internal_non_clust\n|    |    |    |    |\n|    |    |    |    |--> dict_create_index_tree_in_mem\n|    |    |    |    |    |--> btr_create\n|    |    |    |    |    |--> log_ddl->write_free_tree_log\n|    |\n|    |--> create_table_update_global_dd\n|    |    |--> dd_create_implicit_tablespace\n|    |    |    |--> dd_create_tablespace\n|    |    |    |    |--> dd_client->store // dd::Tablespace\n|    |\n|    |--> create_table_update_dict\n```\n\n\n\n```c++\n/* Dictionary_client 操作 */\n\n|--> acquire\n|    |--> acquire_uncommitted\n|    |\n|    |--> m_registry_committed.get\n|    |\n|    |--> Shared_dictionary_cache::instance()->get\n|    |    |--> m_map<T>()->get\n|    |    |\n|    |    |--> get_uncached\n|    |    |    |--> Storage_adapter::get\n|    |    |    |    |--> instance()->core_get\n|    |    |    |    |    |--> m_core_registry.get\n|    |    |    |    |\n|    |    |    |    |--> trx.otx.get_table // 从系统表读取\n|    |    |\n|    |    |--> m_map<T>()->put\n|    |\n|    |--> m_registry_committed.put\n\n\n\n|--> store\n|    |--> m_registry_committed.get // 检查\n|    |\n|    |--> Storage_adapter::store // 保存\n|    |    |--> instance()->core_store\n|    |    |    |--> m_core_registry.put\n|    |    |\n|    |    |--> object->impl()->store // 保存到系统表\n|    |    |--> sdi::store\n|    |\n|    |--> register_uncommitted_object\n|    |    |--> m_registry_committed.get\n|    |    |--> m_registry_dropped.get\n|    |    |--> m_registry_uncommitted.put\n```\n\n## 删表过程\n\n```c++\n|--> mysql_rm_table\n|    |--> mysql_rm_table_no_locks\n|    |    |--> drop_base_table\n|    |    |    |--> ha_delete_table\n|    |    |    |\n|    |    |    |--> dd::drop_table\n|    |    |\n|    |    |--> post_ddl\n```\n\n\n\n```c++\n|--> delete_impl\n|    |--> row_drop_table_for_mysql\n|    |    |--> row_drop_table_from_cache\n|    |    |--> log_ddl->write_drop_log\n|    |    |--> log_ddl->write_delete_space_log\n|    |\n|    |--> dd_drop_tablespace\n```\n\n## 参考文献\n\n> http://mysql.taobao.org/monthly/2018/03/02/\n>\n> http://mysql.taobao.org/monthly/2018/07/02/","slug":"mysql/atomic-ddl","published":1,"updated":"2020-12-05T12:05:16.179Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4xq001ggugm30n7gch9","content":"<p>Atomic DDL 是 MySQL 8.0 的重要特征之一，关于 Atomic DDL 的介绍文档，流传比较广泛的就是参考文献中提到的两篇文章，文章中对 Atomic DDL 的实现思想和基本过程进行了介绍，建议大家阅读一下。本文尝试对完整的建表/删表过程进行分析。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"建表过程\"><a href=\"#建表过程\" class=\"headerlink\" title=\"建表过程\"></a>建表过程</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; mysql_create_table</span><br><span class=\"line\">|    |--&gt; open_tables</span><br><span class=\"line\">|    |    |--&gt; open_and_process_table</span><br><span class=\"line\">|    |    |    |--&gt; open_table  <span class=\"comment\">// 打开表</span></span><br><span class=\"line\">|    |    |    |    |--&gt; check_if_table_exists</span><br><span class=\"line\">|    |    |    |    |    |--&gt; dd::table_exists</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; client-&gt;acquire <span class=\"comment\">// dd::Abstract_table</span></span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; tc-&gt;get_table  <span class=\"comment\">//  从 Table_cache_manager 查找</span></span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; get_table_share_with_discover  <span class=\"comment\">// 构建 TABLE_SHARE</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; get_table_share</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; table_def_cache-&gt;<span class=\"built_in\">find</span>  <span class=\"comment\">// 从 Table_definition_cache 查找</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; process_found_table_share</span><br><span class=\"line\">|    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; alloc_table_share</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; table_def_cache-&gt;emplace  <span class=\"comment\">// 维护 Table_definition_cache</span></span><br><span class=\"line\">|    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; thd-&gt;dd_client()-&gt;acquire</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; open_table_def</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; open_table_from_share  <span class=\"comment\">// 通过 TABLE_SHARE 打开 TABLE</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; ha_open</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; ha_innobase::<span class=\"built_in\">open</span> <span class=\"comment\">// 打开一个 innodb 表</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; lookup_table_handler</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; dict_table_check_if_in_cache_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; dd_open_table</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; dd_open_table_one</span><br><span class=\"line\">|    |    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_create_prebuilt</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; info(...)</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; info_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; update_thd</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |--&gt; row_update_prebuilt_trx</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; tc-&gt;add_used_table  <span class=\"comment\">// 添加到 Table_cache_manager</span></span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; thd-&gt;set_open_tables</span><br><span class=\"line\">|    |    |    |    |--&gt; table-&gt;init</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; mysql_create_table_no_lock</span><br><span class=\"line\">|    |    |--&gt; create_table_impl</span><br><span class=\"line\">|    |    |    |--&gt; check_engine</span><br><span class=\"line\">|    |    |    |--&gt; set_table_default_charset</span><br><span class=\"line\">|    |    |    |--&gt; get_new_handler</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; check_if_table_exists</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; mysql_prepare_create_table</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; rea_create_base_table</span><br><span class=\"line\">|    |    |    |    |--&gt; dd::create_table</span><br><span class=\"line\">|    |    |    |    |    |--&gt; dict-&gt;get_dd_table</span><br><span class=\"line\">|    |    |    |    |    |--&gt; create_dd_user_table</span><br><span class=\"line\">|    |    |    |    |    |--&gt; fill_dd_table_from_create_info</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; fill_dd_columns_from_create_fields</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; fill_dd_indexes_from_keyinfo</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; file-&gt;get_extra_columns_and_keys</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; thd-&gt;dd_client()-&gt;store <span class=\"comment\">// dd::Table</span></span><br><span class=\"line\">|    |    |    |    |--&gt; thd-&gt;dd_client()-&gt;acquire_for_modification</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; ha_create_table</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; trans_commit_stmt</span><br><span class=\"line\">|    |--&gt; trans_commit_implicit</span><br><span class=\"line\">|    |    |--&gt; thd-&gt;dd_client()-&gt;commit_modified_objects</span><br><span class=\"line\">|    |    |    |--&gt; remove_uncommitted_objects <span class=\"comment\">// dd::Abstract_table + dd::Tablespace</span></span><br><span class=\"line\">|    |    |    |    |--&gt; invalidate</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; trans_rollback_stmt</span><br><span class=\"line\">|    |--&gt; trans_rollback</span><br><span class=\"line\">|    |    |--&gt; thd-&gt;dd_client()-&gt;rollback_modified_objects</span><br><span class=\"line\">|    |    |    |--&gt; remove_uncommitted_objects</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; post_ddl</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; create_impl</span><br><span class=\"line\">|    |--&gt; create_table</span><br><span class=\"line\">|    |    |--&gt; create_table_def</span><br><span class=\"line\">|    |    |    |--&gt; dict_mem_table_create</span><br><span class=\"line\">|    |    |    |--&gt; row_create_table_for_mysql</span><br><span class=\"line\">|    |    |    |    |--&gt; dict_build_table_def</span><br><span class=\"line\">|    |    |    |    |    |--&gt; dict_build_table_space_for_table</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; log_ddl-&gt;write_delete_space_log</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; fil_ibd_create</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; dict_table_add_system_columns</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; dict_table_add_to_cache</span><br><span class=\"line\">|    |    |    |    |--&gt; log_ddl-&gt;write_remove_cache_log</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; create_index</span><br><span class=\"line\">|    |    |    |--&gt; dict_mem_index_create</span><br><span class=\"line\">|    |    |    |--&gt; row_create_index_for_mysql</span><br><span class=\"line\">|    |    |    |    |--&gt; dict_build_index_def</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; dict_index_add_to_cache_w_vcol</span><br><span class=\"line\">|    |    |    |    |    |--&gt; dict_index_build_internal_clust</span><br><span class=\"line\">|    |    |    |    |    |--&gt; dict_index_build_internal_non_clust</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; dict_create_index_tree_in_mem</span><br><span class=\"line\">|    |    |    |    |    |--&gt; btr_create</span><br><span class=\"line\">|    |    |    |    |    |--&gt; log_ddl-&gt;write_free_tree_log</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; create_table_update_global_dd</span><br><span class=\"line\">|    |    |--&gt; dd_create_implicit_tablespace</span><br><span class=\"line\">|    |    |    |--&gt; dd_create_tablespace</span><br><span class=\"line\">|    |    |    |    |--&gt; dd_client-&gt;store <span class=\"comment\">// dd::Tablespace</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; create_table_update_dict</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Dictionary_client 操作 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; acquire</span><br><span class=\"line\">|    |--&gt; acquire_uncommitted</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; m_registry_committed.<span class=\"built_in\">get</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; Shared_dictionary_cache::instance()-&gt;<span class=\"built_in\">get</span></span><br><span class=\"line\">|    |    |--&gt; m_map&lt;T&gt;()-&gt;<span class=\"built_in\">get</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; get_uncached</span><br><span class=\"line\">|    |    |    |--&gt; Storage_adapter::<span class=\"built_in\">get</span></span><br><span class=\"line\">|    |    |    |    |--&gt; instance()-&gt;core_get</span><br><span class=\"line\">|    |    |    |    |    |--&gt; m_core_registry.<span class=\"built_in\">get</span></span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; trx.otx.get_table <span class=\"comment\">// 从系统表读取</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; m_map&lt;T&gt;()-&gt;<span class=\"built_in\">put</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; m_registry_committed.<span class=\"built_in\">put</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; store</span><br><span class=\"line\">|    |--&gt; m_registry_committed.<span class=\"built_in\">get</span> <span class=\"comment\">// 检查</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; Storage_adapter::store <span class=\"comment\">// 保存</span></span><br><span class=\"line\">|    |    |--&gt; instance()-&gt;core_store</span><br><span class=\"line\">|    |    |    |--&gt; m_core_registry.<span class=\"built_in\">put</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; object-&gt;impl()-&gt;store <span class=\"comment\">// 保存到系统表</span></span><br><span class=\"line\">|    |    |--&gt; sdi::store</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; register_uncommitted_object</span><br><span class=\"line\">|    |    |--&gt; m_registry_committed.<span class=\"built_in\">get</span></span><br><span class=\"line\">|    |    |--&gt; m_registry_dropped.<span class=\"built_in\">get</span></span><br><span class=\"line\">|    |    |--&gt; m_registry_uncommitted.<span class=\"built_in\">put</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删表过程\"><a href=\"#删表过程\" class=\"headerlink\" title=\"删表过程\"></a>删表过程</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; mysql_rm_table</span><br><span class=\"line\">|    |--&gt; mysql_rm_table_no_locks</span><br><span class=\"line\">|    |    |--&gt; drop_base_table</span><br><span class=\"line\">|    |    |    |--&gt; ha_delete_table</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; dd::drop_table</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; post_ddl</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; delete_impl</span><br><span class=\"line\">|    |--&gt; row_drop_table_for_mysql</span><br><span class=\"line\">|    |    |--&gt; row_drop_table_from_cache</span><br><span class=\"line\">|    |    |--&gt; log_ddl-&gt;write_drop_log</span><br><span class=\"line\">|    |    |--&gt; log_ddl-&gt;write_delete_space_log</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; dd_drop_tablespace</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p><a href=\"http://mysql.taobao.org/monthly/2018/03/02/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2018/03/02/</a></p>\n<p><a href=\"http://mysql.taobao.org/monthly/2018/07/02/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2018/07/02/</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>Atomic DDL 是 MySQL 8.0 的重要特征之一，关于 Atomic DDL 的介绍文档，流传比较广泛的就是参考文献中提到的两篇文章，文章中对 Atomic DDL 的实现思想和基本过程进行了介绍，建议大家阅读一下。本文尝试对完整的建表/删表过程进行分析。</p>","more":"<h2 id=\"建表过程\"><a href=\"#建表过程\" class=\"headerlink\" title=\"建表过程\"></a>建表过程</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; mysql_create_table</span><br><span class=\"line\">|    |--&gt; open_tables</span><br><span class=\"line\">|    |    |--&gt; open_and_process_table</span><br><span class=\"line\">|    |    |    |--&gt; open_table  <span class=\"comment\">// 打开表</span></span><br><span class=\"line\">|    |    |    |    |--&gt; check_if_table_exists</span><br><span class=\"line\">|    |    |    |    |    |--&gt; dd::table_exists</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; client-&gt;acquire <span class=\"comment\">// dd::Abstract_table</span></span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; tc-&gt;get_table  <span class=\"comment\">//  从 Table_cache_manager 查找</span></span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; get_table_share_with_discover  <span class=\"comment\">// 构建 TABLE_SHARE</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; get_table_share</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; table_def_cache-&gt;<span class=\"built_in\">find</span>  <span class=\"comment\">// 从 Table_definition_cache 查找</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; process_found_table_share</span><br><span class=\"line\">|    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; alloc_table_share</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; table_def_cache-&gt;emplace  <span class=\"comment\">// 维护 Table_definition_cache</span></span><br><span class=\"line\">|    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; thd-&gt;dd_client()-&gt;acquire</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; open_table_def</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; open_table_from_share  <span class=\"comment\">// 通过 TABLE_SHARE 打开 TABLE</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; ha_open</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; ha_innobase::<span class=\"built_in\">open</span> <span class=\"comment\">// 打开一个 innodb 表</span></span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; lookup_table_handler</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; dict_table_check_if_in_cache_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; dd_open_table</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; dd_open_table_one</span><br><span class=\"line\">|    |    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; row_create_prebuilt</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; info(...)</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; info_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; update_thd</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |    |--&gt; row_update_prebuilt_trx</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; tc-&gt;add_used_table  <span class=\"comment\">// 添加到 Table_cache_manager</span></span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; thd-&gt;set_open_tables</span><br><span class=\"line\">|    |    |    |    |--&gt; table-&gt;init</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; mysql_create_table_no_lock</span><br><span class=\"line\">|    |    |--&gt; create_table_impl</span><br><span class=\"line\">|    |    |    |--&gt; check_engine</span><br><span class=\"line\">|    |    |    |--&gt; set_table_default_charset</span><br><span class=\"line\">|    |    |    |--&gt; get_new_handler</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; check_if_table_exists</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; mysql_prepare_create_table</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; rea_create_base_table</span><br><span class=\"line\">|    |    |    |    |--&gt; dd::create_table</span><br><span class=\"line\">|    |    |    |    |    |--&gt; dict-&gt;get_dd_table</span><br><span class=\"line\">|    |    |    |    |    |--&gt; create_dd_user_table</span><br><span class=\"line\">|    |    |    |    |    |--&gt; fill_dd_table_from_create_info</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; fill_dd_columns_from_create_fields</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; fill_dd_indexes_from_keyinfo</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; file-&gt;get_extra_columns_and_keys</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; thd-&gt;dd_client()-&gt;store <span class=\"comment\">// dd::Table</span></span><br><span class=\"line\">|    |    |    |    |--&gt; thd-&gt;dd_client()-&gt;acquire_for_modification</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; ha_create_table</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; trans_commit_stmt</span><br><span class=\"line\">|    |--&gt; trans_commit_implicit</span><br><span class=\"line\">|    |    |--&gt; thd-&gt;dd_client()-&gt;commit_modified_objects</span><br><span class=\"line\">|    |    |    |--&gt; remove_uncommitted_objects <span class=\"comment\">// dd::Abstract_table + dd::Tablespace</span></span><br><span class=\"line\">|    |    |    |    |--&gt; invalidate</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; trans_rollback_stmt</span><br><span class=\"line\">|    |--&gt; trans_rollback</span><br><span class=\"line\">|    |    |--&gt; thd-&gt;dd_client()-&gt;rollback_modified_objects</span><br><span class=\"line\">|    |    |    |--&gt; remove_uncommitted_objects</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; post_ddl</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; create_impl</span><br><span class=\"line\">|    |--&gt; create_table</span><br><span class=\"line\">|    |    |--&gt; create_table_def</span><br><span class=\"line\">|    |    |    |--&gt; dict_mem_table_create</span><br><span class=\"line\">|    |    |    |--&gt; row_create_table_for_mysql</span><br><span class=\"line\">|    |    |    |    |--&gt; dict_build_table_def</span><br><span class=\"line\">|    |    |    |    |    |--&gt; dict_build_table_space_for_table</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; log_ddl-&gt;write_delete_space_log</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; fil_ibd_create</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; dict_table_add_system_columns</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; dict_table_add_to_cache</span><br><span class=\"line\">|    |    |    |    |--&gt; log_ddl-&gt;write_remove_cache_log</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; create_index</span><br><span class=\"line\">|    |    |    |--&gt; dict_mem_index_create</span><br><span class=\"line\">|    |    |    |--&gt; row_create_index_for_mysql</span><br><span class=\"line\">|    |    |    |    |--&gt; dict_build_index_def</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; dict_index_add_to_cache_w_vcol</span><br><span class=\"line\">|    |    |    |    |    |--&gt; dict_index_build_internal_clust</span><br><span class=\"line\">|    |    |    |    |    |--&gt; dict_index_build_internal_non_clust</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; dict_create_index_tree_in_mem</span><br><span class=\"line\">|    |    |    |    |    |--&gt; btr_create</span><br><span class=\"line\">|    |    |    |    |    |--&gt; log_ddl-&gt;write_free_tree_log</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; create_table_update_global_dd</span><br><span class=\"line\">|    |    |--&gt; dd_create_implicit_tablespace</span><br><span class=\"line\">|    |    |    |--&gt; dd_create_tablespace</span><br><span class=\"line\">|    |    |    |    |--&gt; dd_client-&gt;store <span class=\"comment\">// dd::Tablespace</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; create_table_update_dict</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Dictionary_client 操作 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; acquire</span><br><span class=\"line\">|    |--&gt; acquire_uncommitted</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; m_registry_committed.<span class=\"built_in\">get</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; Shared_dictionary_cache::instance()-&gt;<span class=\"built_in\">get</span></span><br><span class=\"line\">|    |    |--&gt; m_map&lt;T&gt;()-&gt;<span class=\"built_in\">get</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; get_uncached</span><br><span class=\"line\">|    |    |    |--&gt; Storage_adapter::<span class=\"built_in\">get</span></span><br><span class=\"line\">|    |    |    |    |--&gt; instance()-&gt;core_get</span><br><span class=\"line\">|    |    |    |    |    |--&gt; m_core_registry.<span class=\"built_in\">get</span></span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; trx.otx.get_table <span class=\"comment\">// 从系统表读取</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; m_map&lt;T&gt;()-&gt;<span class=\"built_in\">put</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; m_registry_committed.<span class=\"built_in\">put</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; store</span><br><span class=\"line\">|    |--&gt; m_registry_committed.<span class=\"built_in\">get</span> <span class=\"comment\">// 检查</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; Storage_adapter::store <span class=\"comment\">// 保存</span></span><br><span class=\"line\">|    |    |--&gt; instance()-&gt;core_store</span><br><span class=\"line\">|    |    |    |--&gt; m_core_registry.<span class=\"built_in\">put</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; object-&gt;impl()-&gt;store <span class=\"comment\">// 保存到系统表</span></span><br><span class=\"line\">|    |    |--&gt; sdi::store</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; register_uncommitted_object</span><br><span class=\"line\">|    |    |--&gt; m_registry_committed.<span class=\"built_in\">get</span></span><br><span class=\"line\">|    |    |--&gt; m_registry_dropped.<span class=\"built_in\">get</span></span><br><span class=\"line\">|    |    |--&gt; m_registry_uncommitted.<span class=\"built_in\">put</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删表过程\"><a href=\"#删表过程\" class=\"headerlink\" title=\"删表过程\"></a>删表过程</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; mysql_rm_table</span><br><span class=\"line\">|    |--&gt; mysql_rm_table_no_locks</span><br><span class=\"line\">|    |    |--&gt; drop_base_table</span><br><span class=\"line\">|    |    |    |--&gt; ha_delete_table</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; dd::drop_table</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; post_ddl</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; delete_impl</span><br><span class=\"line\">|    |--&gt; row_drop_table_for_mysql</span><br><span class=\"line\">|    |    |--&gt; row_drop_table_from_cache</span><br><span class=\"line\">|    |    |--&gt; log_ddl-&gt;write_drop_log</span><br><span class=\"line\">|    |    |--&gt; log_ddl-&gt;write_delete_space_log</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; dd_drop_tablespace</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p><a href=\"http://mysql.taobao.org/monthly/2018/03/02/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2018/03/02/</a></p>\n<p><a href=\"http://mysql.taobao.org/monthly/2018/07/02/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2018/07/02/</a></p>\n</blockquote>"},{"title":"MySQL X Plugin","date":"2020-07-17T14:33:10.000Z","_content":"\n随着文档型数据库的持续火热，MySQL 也不甘寂寞，开始打起了文档型数据库的主义，全面支持 JSON 数据格式是其中一点，还有一点就是 X Plugin。\n\n<!-- more -->\n\n## What is X Plugin\n\n官方对于 X Plugin 的介绍非常含糊，说了一堆使用的方式，就是不说到底是什么东西。Percona 的一篇文章对此有一个说明，引用如下：\n\n> https://www.percona.com/blog/2019/01/07/understanding-mysql-x-all-flavors/\n\nWhat does the X stand for? Basically, it is a way to name the crossover between relational and document models with extended capabilities, and the X is used for naming the three components we are describing: the Plugin, the Protocol and the DevAPI.\n\n### X Plugin\n\nThis is the actual interface between MySQL server and the clients. By clients we can consider a variety of clients, not only the MySQL shell. It has to be installed in MySQL 5.7 versions via the INSTALL PLUGIN command but comes installed by default in MySQL 8. The plugin adds all the functionality, configuration variables, and status counters we need to use it.\n\nIt has the ability to work with both traditional SQL and Document objects, and also supports CRUD (Create, Read, Update, Delete) operations, asynchronous query execution and so on – this provides a great capacity to extend the current way we work with MySQL.\n\n### X Protocol\n\nThis is a new client protocol created to talk between the X Plugin and Clients. I think it is fair to say this is an eXtended version of the MySQL protocol.\n\nIt was designed with the idea of having the capacity for asynchronous calls, meaning that you can send more than one query to server from same client without the need of waiting for first query to finish before sending the second and so. This improves the overall execution time by saving network round trips between clients and server.\n\nAdditionally, the protocol accepts CRUD operations and, of course, the handling of JSON documents and plain SQL. The protocol is fully implemented in MySQLShell and has several connectors for popular languages (Java and .Net for example)\n\n### X DevAPI\n\nThe last piece of this package is the X DevAPI protocol. Probably the best documented of these pieces is the API implemented on the MySQL Shell and connectors that supports the X Protocol. This API is designed to easily write programs from a given client using some popular languages. For example, we can easily create/test a program from MySQL Shell using Python or JavaScript.\n\n通过上面的描述，基本上可以对 X Plugin 有一个比较直观的认识：**X Plugin 是 MySQL 支持文档模型的一个扩展插件，为了保证对文档模型的操作友好，MySQL 提供了一种全新的协议 X Protocol，并且实现了一套相应的开发接口 X DevAPI**。官方的介绍文档地址如下：\n\n- X Plugin : https://dev.mysql.com/doc/refman/8.0/en/x-plugin.html\n- X Protocol : https://dev.mysql.com/doc/internals/en/x-protocol.html\n- X DevAPI : https://dev.mysql.com/doc/x-devapi-userguide/en/\n\n## How to use\n\n关于 X Plugin 的使用，一个简单的例子如下：\n\n> MySQL Shell Command : https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-configuring.html\n\n```shell\n#mysqlsh\nMySQL Shell 8.0.21\n\nCopyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.\nOracle is a registered trademark of Oracle Corporation and/or its affiliates.\nOther names may be trademarks of their respective owners.\n\nType '\\help' or '\\?' for help; '\\quit' to exit.\n MySQL  JS > \\py\nSwitching to Python mode...\n MySQL  Py >\n MySQL  Py > from mysqlsh import mysqlx\n MySQL  Py > mySession = mysqlx.get_session('test1:123456@127.0.0.1:49320')\n MySQL  Py > myDb = mySession.get_schema('mytest')\n MySQL  Py > myColl = myDb.create_collection('my_collection')\n MySQL  Py > myColl.add({'_id': '1', 'name': 'Laurie', 'age': 19}).execute()\nQuery OK, 1 item affected (0.0076 sec)\n MySQL  Py > myColl.add({'_id': '2', 'name': 'Nadya', 'age': 54}).execute()\nQuery OK, 1 item affected (0.0011 sec)\n MySQL  Py > myColl.add({'_id': '3', 'name': 'Lukas', 'age': 32}).execute()\nQuery OK, 1 item affected (0.0010 sec)\n MySQL  Py >\n MySQL  Py > myColl.find().execute()\n{\n    \"_id\": \"1\",\n    \"age\": 19,\n    \"name\": \"Laurie\"\n}\n{\n    \"_id\": \"2\",\n    \"age\": 54,\n    \"name\": \"Nadya\"\n}\n{\n    \"_id\": \"3\",\n    \"age\": 32,\n    \"name\": \"Lukas\"\n}\n3 documents in set (0.0004 sec)\n MySQL  Py >\n MySQL  Py > \\sql\nSwitching to SQL mode... Commands end with ;\n MySQL  SQL >\n MySQL  SQL > \\connect test1@127.0.0.1:4932\nCreating a session to 'test1@127.0.0.1:4932'\nPlease provide the password for 'test1@127.0.0.1:4932': ******\nFetching schema names for autocompletion... Press ^C to stop.\nYour MySQL connection id is 31\nServer version: 8.0.18-rds-dev Source distribution\nNo default schema selected; type \\use <schema> to set one.\n MySQL  127.0.0.1:4932 ssl  SQL > use mytest\nDefault schema set to `mytest`.\nFetching table and column names from `mytest` for auto-completion... Press ^C to stop.\n MySQL  127.0.0.1:4932 ssl  mytest  SQL > select * from my_collection;\n+-------------------------------------------+-----+\n| doc                                       | _id |\n+-------------------------------------------+-----+\n| {\"_id\": \"1\", \"age\": 19, \"name\": \"Laurie\"} | 1   |\n| {\"_id\": \"2\", \"age\": 54, \"name\": \"Nadya\"}  | 2   |\n| {\"_id\": \"3\", \"age\": 32, \"name\": \"Lukas\"}  | 3   |\n+-------------------------------------------+-----+\n3 rows in set (0.0006 sec)\n MySQL  127.0.0.1:4932 ssl  mytest  SQL > \\q\nBye!\n```\n\n\n\n注意事项：\n\n1. mysqlsh 是 MySQL 提供的一个新的命令行工具，下载地址见：https://dev.mysql.com/downloads/shell/\n2. mysqlsh 提供了丰富的命令操作，详见：https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-commands.html\n3. 使用 mysqlsh 连接时，可能出现如下报错：\n\n```shell\nTraceback (most recent call last):\n  File \"<string>\", line 1, in <module>\nmysqlsh.DBError: MySQL Error (5001): mysqlx.get_session: Capability prepare failed for 'tls'\n```\n\n这是因为 MySQL 没有配置 ssl，本地测试的话可以修改以下两个参数，自动生成证书：\n\n```shell\nauto_detect_certs = ON\nauto_generate_certs = ON\n```","source":"_posts/mysql/x-plugin.md","raw":"---\ntitle: MySQL X Plugin\ndate: 2020-07-17 22:33:10\ntags:\n- Feature\ncategories:\n- MySQL\n\n---\n\n随着文档型数据库的持续火热，MySQL 也不甘寂寞，开始打起了文档型数据库的主义，全面支持 JSON 数据格式是其中一点，还有一点就是 X Plugin。\n\n<!-- more -->\n\n## What is X Plugin\n\n官方对于 X Plugin 的介绍非常含糊，说了一堆使用的方式，就是不说到底是什么东西。Percona 的一篇文章对此有一个说明，引用如下：\n\n> https://www.percona.com/blog/2019/01/07/understanding-mysql-x-all-flavors/\n\nWhat does the X stand for? Basically, it is a way to name the crossover between relational and document models with extended capabilities, and the X is used for naming the three components we are describing: the Plugin, the Protocol and the DevAPI.\n\n### X Plugin\n\nThis is the actual interface between MySQL server and the clients. By clients we can consider a variety of clients, not only the MySQL shell. It has to be installed in MySQL 5.7 versions via the INSTALL PLUGIN command but comes installed by default in MySQL 8. The plugin adds all the functionality, configuration variables, and status counters we need to use it.\n\nIt has the ability to work with both traditional SQL and Document objects, and also supports CRUD (Create, Read, Update, Delete) operations, asynchronous query execution and so on – this provides a great capacity to extend the current way we work with MySQL.\n\n### X Protocol\n\nThis is a new client protocol created to talk between the X Plugin and Clients. I think it is fair to say this is an eXtended version of the MySQL protocol.\n\nIt was designed with the idea of having the capacity for asynchronous calls, meaning that you can send more than one query to server from same client without the need of waiting for first query to finish before sending the second and so. This improves the overall execution time by saving network round trips between clients and server.\n\nAdditionally, the protocol accepts CRUD operations and, of course, the handling of JSON documents and plain SQL. The protocol is fully implemented in MySQLShell and has several connectors for popular languages (Java and .Net for example)\n\n### X DevAPI\n\nThe last piece of this package is the X DevAPI protocol. Probably the best documented of these pieces is the API implemented on the MySQL Shell and connectors that supports the X Protocol. This API is designed to easily write programs from a given client using some popular languages. For example, we can easily create/test a program from MySQL Shell using Python or JavaScript.\n\n通过上面的描述，基本上可以对 X Plugin 有一个比较直观的认识：**X Plugin 是 MySQL 支持文档模型的一个扩展插件，为了保证对文档模型的操作友好，MySQL 提供了一种全新的协议 X Protocol，并且实现了一套相应的开发接口 X DevAPI**。官方的介绍文档地址如下：\n\n- X Plugin : https://dev.mysql.com/doc/refman/8.0/en/x-plugin.html\n- X Protocol : https://dev.mysql.com/doc/internals/en/x-protocol.html\n- X DevAPI : https://dev.mysql.com/doc/x-devapi-userguide/en/\n\n## How to use\n\n关于 X Plugin 的使用，一个简单的例子如下：\n\n> MySQL Shell Command : https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-configuring.html\n\n```shell\n#mysqlsh\nMySQL Shell 8.0.21\n\nCopyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.\nOracle is a registered trademark of Oracle Corporation and/or its affiliates.\nOther names may be trademarks of their respective owners.\n\nType '\\help' or '\\?' for help; '\\quit' to exit.\n MySQL  JS > \\py\nSwitching to Python mode...\n MySQL  Py >\n MySQL  Py > from mysqlsh import mysqlx\n MySQL  Py > mySession = mysqlx.get_session('test1:123456@127.0.0.1:49320')\n MySQL  Py > myDb = mySession.get_schema('mytest')\n MySQL  Py > myColl = myDb.create_collection('my_collection')\n MySQL  Py > myColl.add({'_id': '1', 'name': 'Laurie', 'age': 19}).execute()\nQuery OK, 1 item affected (0.0076 sec)\n MySQL  Py > myColl.add({'_id': '2', 'name': 'Nadya', 'age': 54}).execute()\nQuery OK, 1 item affected (0.0011 sec)\n MySQL  Py > myColl.add({'_id': '3', 'name': 'Lukas', 'age': 32}).execute()\nQuery OK, 1 item affected (0.0010 sec)\n MySQL  Py >\n MySQL  Py > myColl.find().execute()\n{\n    \"_id\": \"1\",\n    \"age\": 19,\n    \"name\": \"Laurie\"\n}\n{\n    \"_id\": \"2\",\n    \"age\": 54,\n    \"name\": \"Nadya\"\n}\n{\n    \"_id\": \"3\",\n    \"age\": 32,\n    \"name\": \"Lukas\"\n}\n3 documents in set (0.0004 sec)\n MySQL  Py >\n MySQL  Py > \\sql\nSwitching to SQL mode... Commands end with ;\n MySQL  SQL >\n MySQL  SQL > \\connect test1@127.0.0.1:4932\nCreating a session to 'test1@127.0.0.1:4932'\nPlease provide the password for 'test1@127.0.0.1:4932': ******\nFetching schema names for autocompletion... Press ^C to stop.\nYour MySQL connection id is 31\nServer version: 8.0.18-rds-dev Source distribution\nNo default schema selected; type \\use <schema> to set one.\n MySQL  127.0.0.1:4932 ssl  SQL > use mytest\nDefault schema set to `mytest`.\nFetching table and column names from `mytest` for auto-completion... Press ^C to stop.\n MySQL  127.0.0.1:4932 ssl  mytest  SQL > select * from my_collection;\n+-------------------------------------------+-----+\n| doc                                       | _id |\n+-------------------------------------------+-----+\n| {\"_id\": \"1\", \"age\": 19, \"name\": \"Laurie\"} | 1   |\n| {\"_id\": \"2\", \"age\": 54, \"name\": \"Nadya\"}  | 2   |\n| {\"_id\": \"3\", \"age\": 32, \"name\": \"Lukas\"}  | 3   |\n+-------------------------------------------+-----+\n3 rows in set (0.0006 sec)\n MySQL  127.0.0.1:4932 ssl  mytest  SQL > \\q\nBye!\n```\n\n\n\n注意事项：\n\n1. mysqlsh 是 MySQL 提供的一个新的命令行工具，下载地址见：https://dev.mysql.com/downloads/shell/\n2. mysqlsh 提供了丰富的命令操作，详见：https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-commands.html\n3. 使用 mysqlsh 连接时，可能出现如下报错：\n\n```shell\nTraceback (most recent call last):\n  File \"<string>\", line 1, in <module>\nmysqlsh.DBError: MySQL Error (5001): mysqlx.get_session: Capability prepare failed for 'tls'\n```\n\n这是因为 MySQL 没有配置 ssl，本地测试的话可以修改以下两个参数，自动生成证书：\n\n```shell\nauto_detect_certs = ON\nauto_generate_certs = ON\n```","slug":"mysql/x-plugin","published":1,"updated":"2020-12-05T12:02:31.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4xs001lgugm8okeefsp","content":"<p>随着文档型数据库的持续火热，MySQL 也不甘寂寞，开始打起了文档型数据库的主义，全面支持 JSON 数据格式是其中一点，还有一点就是 X Plugin。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"What-is-X-Plugin\"><a href=\"#What-is-X-Plugin\" class=\"headerlink\" title=\"What is X Plugin\"></a>What is X Plugin</h2><p>官方对于 X Plugin 的介绍非常含糊，说了一堆使用的方式，就是不说到底是什么东西。Percona 的一篇文章对此有一个说明，引用如下：</p>\n<blockquote>\n<p><a href=\"https://www.percona.com/blog/2019/01/07/understanding-mysql-x-all-flavors/\" target=\"_blank\" rel=\"noopener\">https://www.percona.com/blog/2019/01/07/understanding-mysql-x-all-flavors/</a></p>\n</blockquote>\n<p>What does the X stand for? Basically, it is a way to name the crossover between relational and document models with extended capabilities, and the X is used for naming the three components we are describing: the Plugin, the Protocol and the DevAPI.</p>\n<h3 id=\"X-Plugin\"><a href=\"#X-Plugin\" class=\"headerlink\" title=\"X Plugin\"></a>X Plugin</h3><p>This is the actual interface between MySQL server and the clients. By clients we can consider a variety of clients, not only the MySQL shell. It has to be installed in MySQL 5.7 versions via the INSTALL PLUGIN command but comes installed by default in MySQL 8. The plugin adds all the functionality, configuration variables, and status counters we need to use it.</p>\n<p>It has the ability to work with both traditional SQL and Document objects, and also supports CRUD (Create, Read, Update, Delete) operations, asynchronous query execution and so on – this provides a great capacity to extend the current way we work with MySQL.</p>\n<h3 id=\"X-Protocol\"><a href=\"#X-Protocol\" class=\"headerlink\" title=\"X Protocol\"></a>X Protocol</h3><p>This is a new client protocol created to talk between the X Plugin and Clients. I think it is fair to say this is an eXtended version of the MySQL protocol.</p>\n<p>It was designed with the idea of having the capacity for asynchronous calls, meaning that you can send more than one query to server from same client without the need of waiting for first query to finish before sending the second and so. This improves the overall execution time by saving network round trips between clients and server.</p>\n<p>Additionally, the protocol accepts CRUD operations and, of course, the handling of JSON documents and plain SQL. The protocol is fully implemented in MySQLShell and has several connectors for popular languages (Java and .Net for example)</p>\n<h3 id=\"X-DevAPI\"><a href=\"#X-DevAPI\" class=\"headerlink\" title=\"X DevAPI\"></a>X DevAPI</h3><p>The last piece of this package is the X DevAPI protocol. Probably the best documented of these pieces is the API implemented on the MySQL Shell and connectors that supports the X Protocol. This API is designed to easily write programs from a given client using some popular languages. For example, we can easily create/test a program from MySQL Shell using Python or JavaScript.</p>\n<p>通过上面的描述，基本上可以对 X Plugin 有一个比较直观的认识：<strong>X Plugin 是 MySQL 支持文档模型的一个扩展插件，为了保证对文档模型的操作友好，MySQL 提供了一种全新的协议 X Protocol，并且实现了一套相应的开发接口 X DevAPI</strong>。官方的介绍文档地址如下：</p>\n<ul>\n<li>X Plugin : <a href=\"https://dev.mysql.com/doc/refman/8.0/en/x-plugin.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/8.0/en/x-plugin.html</a></li>\n<li>X Protocol : <a href=\"https://dev.mysql.com/doc/internals/en/x-protocol.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/internals/en/x-protocol.html</a></li>\n<li>X DevAPI : <a href=\"https://dev.mysql.com/doc/x-devapi-userguide/en/\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/x-devapi-userguide/en/</a></li>\n</ul>\n<h2 id=\"How-to-use\"><a href=\"#How-to-use\" class=\"headerlink\" title=\"How to use\"></a>How to use</h2><p>关于 X Plugin 的使用，一个简单的例子如下：</p>\n<blockquote>\n<p>MySQL Shell Command : <a href=\"https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-configuring.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-configuring.html</a></p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">mysqlsh</span></span><br><span class=\"line\">MySQL Shell 8.0.21</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its affiliates.</span><br><span class=\"line\">Other names may be trademarks of their respective owners.</span><br><span class=\"line\"></span><br><span class=\"line\">Type '\\help' or '\\?' for help; '\\quit' to exit.</span><br><span class=\"line\"> MySQL  JS &gt; \\py</span><br><span class=\"line\">Switching to Python mode...</span><br><span class=\"line\"> MySQL  Py &gt;</span><br><span class=\"line\"> MySQL  Py &gt; from mysqlsh import mysqlx</span><br><span class=\"line\"> MySQL  Py &gt; mySession = mysqlx.get_session('test1:123456@127.0.0.1:49320')</span><br><span class=\"line\"> MySQL  Py &gt; myDb = mySession.get_schema('mytest')</span><br><span class=\"line\"> MySQL  Py &gt; myColl = myDb.create_collection('my_collection')</span><br><span class=\"line\"> MySQL  Py &gt; myColl.add(&#123;'_id': '1', 'name': 'Laurie', 'age': 19&#125;).execute()</span><br><span class=\"line\">Query OK, 1 item affected (0.0076 sec)</span><br><span class=\"line\"> MySQL  Py &gt; myColl.add(&#123;'_id': '2', 'name': 'Nadya', 'age': 54&#125;).execute()</span><br><span class=\"line\">Query OK, 1 item affected (0.0011 sec)</span><br><span class=\"line\"> MySQL  Py &gt; myColl.add(&#123;'_id': '3', 'name': 'Lukas', 'age': 32&#125;).execute()</span><br><span class=\"line\">Query OK, 1 item affected (0.0010 sec)</span><br><span class=\"line\"> MySQL  Py &gt;</span><br><span class=\"line\"> MySQL  Py &gt; myColl.find().execute()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"_id\": \"1\",</span><br><span class=\"line\">    \"age\": 19,</span><br><span class=\"line\">    \"name\": \"Laurie\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"_id\": \"2\",</span><br><span class=\"line\">    \"age\": 54,</span><br><span class=\"line\">    \"name\": \"Nadya\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"_id\": \"3\",</span><br><span class=\"line\">    \"age\": 32,</span><br><span class=\"line\">    \"name\": \"Lukas\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">3 documents in set (0.0004 sec)</span><br><span class=\"line\"> MySQL  Py &gt;</span><br><span class=\"line\"> MySQL  Py &gt; \\sql</span><br><span class=\"line\">Switching to SQL mode... Commands end with ;</span><br><span class=\"line\"> MySQL  SQL &gt;</span><br><span class=\"line\"> MySQL  SQL &gt; \\connect test1@127.0.0.1:4932</span><br><span class=\"line\">Creating a session to 'test1@127.0.0.1:4932'</span><br><span class=\"line\">Please provide the password for 'test1@127.0.0.1:4932': ******</span><br><span class=\"line\">Fetching schema names for autocompletion... Press ^C to stop.</span><br><span class=\"line\">Your MySQL connection id is 31</span><br><span class=\"line\">Server version: 8.0.18-rds-dev Source distribution</span><br><span class=\"line\">No default schema selected; type \\use &lt;schema&gt; to set one.</span><br><span class=\"line\"> MySQL  127.0.0.1:4932 ssl  SQL &gt; use mytest</span><br><span class=\"line\">Default schema set to `mytest`.</span><br><span class=\"line\">Fetching table and column names from `mytest` for auto-completion... Press ^C to stop.</span><br><span class=\"line\"> MySQL  127.0.0.1:4932 ssl  mytest  SQL &gt; select * from my_collection;</span><br><span class=\"line\">+-------------------------------------------+-----+</span><br><span class=\"line\">| doc                                       | _id |</span><br><span class=\"line\">+-------------------------------------------+-----+</span><br><span class=\"line\">| &#123;\"_id\": \"1\", \"age\": 19, \"name\": \"Laurie\"&#125; | 1   |</span><br><span class=\"line\">| &#123;\"_id\": \"2\", \"age\": 54, \"name\": \"Nadya\"&#125;  | 2   |</span><br><span class=\"line\">| &#123;\"_id\": \"3\", \"age\": 32, \"name\": \"Lukas\"&#125;  | 3   |</span><br><span class=\"line\">+-------------------------------------------+-----+</span><br><span class=\"line\">3 rows in set (0.0006 sec)</span><br><span class=\"line\"> MySQL  127.0.0.1:4932 ssl  mytest  SQL &gt; \\q</span><br><span class=\"line\">Bye!</span><br></pre></td></tr></table></figure>\n\n\n\n<p>注意事项：</p>\n<ol>\n<li>mysqlsh 是 MySQL 提供的一个新的命令行工具，下载地址见：<a href=\"https://dev.mysql.com/downloads/shell/\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/downloads/shell/</a></li>\n<li>mysqlsh 提供了丰富的命令操作，详见：<a href=\"https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-commands.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-commands.html</a></li>\n<li>使用 mysqlsh 连接时，可能出现如下报错：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File \"&lt;string&gt;\", line 1, in &lt;module&gt;</span><br><span class=\"line\">mysqlsh.DBError: MySQL Error (5001): mysqlx.get_session: Capability prepare failed for 'tls'</span><br></pre></td></tr></table></figure>\n\n<p>这是因为 MySQL 没有配置 ssl，本地测试的话可以修改以下两个参数，自动生成证书：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto_detect_certs = ON</span><br><span class=\"line\">auto_generate_certs = ON</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>随着文档型数据库的持续火热，MySQL 也不甘寂寞，开始打起了文档型数据库的主义，全面支持 JSON 数据格式是其中一点，还有一点就是 X Plugin。</p>","more":"<h2 id=\"What-is-X-Plugin\"><a href=\"#What-is-X-Plugin\" class=\"headerlink\" title=\"What is X Plugin\"></a>What is X Plugin</h2><p>官方对于 X Plugin 的介绍非常含糊，说了一堆使用的方式，就是不说到底是什么东西。Percona 的一篇文章对此有一个说明，引用如下：</p>\n<blockquote>\n<p><a href=\"https://www.percona.com/blog/2019/01/07/understanding-mysql-x-all-flavors/\" target=\"_blank\" rel=\"noopener\">https://www.percona.com/blog/2019/01/07/understanding-mysql-x-all-flavors/</a></p>\n</blockquote>\n<p>What does the X stand for? Basically, it is a way to name the crossover between relational and document models with extended capabilities, and the X is used for naming the three components we are describing: the Plugin, the Protocol and the DevAPI.</p>\n<h3 id=\"X-Plugin\"><a href=\"#X-Plugin\" class=\"headerlink\" title=\"X Plugin\"></a>X Plugin</h3><p>This is the actual interface between MySQL server and the clients. By clients we can consider a variety of clients, not only the MySQL shell. It has to be installed in MySQL 5.7 versions via the INSTALL PLUGIN command but comes installed by default in MySQL 8. The plugin adds all the functionality, configuration variables, and status counters we need to use it.</p>\n<p>It has the ability to work with both traditional SQL and Document objects, and also supports CRUD (Create, Read, Update, Delete) operations, asynchronous query execution and so on – this provides a great capacity to extend the current way we work with MySQL.</p>\n<h3 id=\"X-Protocol\"><a href=\"#X-Protocol\" class=\"headerlink\" title=\"X Protocol\"></a>X Protocol</h3><p>This is a new client protocol created to talk between the X Plugin and Clients. I think it is fair to say this is an eXtended version of the MySQL protocol.</p>\n<p>It was designed with the idea of having the capacity for asynchronous calls, meaning that you can send more than one query to server from same client without the need of waiting for first query to finish before sending the second and so. This improves the overall execution time by saving network round trips between clients and server.</p>\n<p>Additionally, the protocol accepts CRUD operations and, of course, the handling of JSON documents and plain SQL. The protocol is fully implemented in MySQLShell and has several connectors for popular languages (Java and .Net for example)</p>\n<h3 id=\"X-DevAPI\"><a href=\"#X-DevAPI\" class=\"headerlink\" title=\"X DevAPI\"></a>X DevAPI</h3><p>The last piece of this package is the X DevAPI protocol. Probably the best documented of these pieces is the API implemented on the MySQL Shell and connectors that supports the X Protocol. This API is designed to easily write programs from a given client using some popular languages. For example, we can easily create/test a program from MySQL Shell using Python or JavaScript.</p>\n<p>通过上面的描述，基本上可以对 X Plugin 有一个比较直观的认识：<strong>X Plugin 是 MySQL 支持文档模型的一个扩展插件，为了保证对文档模型的操作友好，MySQL 提供了一种全新的协议 X Protocol，并且实现了一套相应的开发接口 X DevAPI</strong>。官方的介绍文档地址如下：</p>\n<ul>\n<li>X Plugin : <a href=\"https://dev.mysql.com/doc/refman/8.0/en/x-plugin.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/8.0/en/x-plugin.html</a></li>\n<li>X Protocol : <a href=\"https://dev.mysql.com/doc/internals/en/x-protocol.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/internals/en/x-protocol.html</a></li>\n<li>X DevAPI : <a href=\"https://dev.mysql.com/doc/x-devapi-userguide/en/\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/x-devapi-userguide/en/</a></li>\n</ul>\n<h2 id=\"How-to-use\"><a href=\"#How-to-use\" class=\"headerlink\" title=\"How to use\"></a>How to use</h2><p>关于 X Plugin 的使用，一个简单的例子如下：</p>\n<blockquote>\n<p>MySQL Shell Command : <a href=\"https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-configuring.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-configuring.html</a></p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">mysqlsh</span></span><br><span class=\"line\">MySQL Shell 8.0.21</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its affiliates.</span><br><span class=\"line\">Other names may be trademarks of their respective owners.</span><br><span class=\"line\"></span><br><span class=\"line\">Type '\\help' or '\\?' for help; '\\quit' to exit.</span><br><span class=\"line\"> MySQL  JS &gt; \\py</span><br><span class=\"line\">Switching to Python mode...</span><br><span class=\"line\"> MySQL  Py &gt;</span><br><span class=\"line\"> MySQL  Py &gt; from mysqlsh import mysqlx</span><br><span class=\"line\"> MySQL  Py &gt; mySession = mysqlx.get_session('test1:123456@127.0.0.1:49320')</span><br><span class=\"line\"> MySQL  Py &gt; myDb = mySession.get_schema('mytest')</span><br><span class=\"line\"> MySQL  Py &gt; myColl = myDb.create_collection('my_collection')</span><br><span class=\"line\"> MySQL  Py &gt; myColl.add(&#123;'_id': '1', 'name': 'Laurie', 'age': 19&#125;).execute()</span><br><span class=\"line\">Query OK, 1 item affected (0.0076 sec)</span><br><span class=\"line\"> MySQL  Py &gt; myColl.add(&#123;'_id': '2', 'name': 'Nadya', 'age': 54&#125;).execute()</span><br><span class=\"line\">Query OK, 1 item affected (0.0011 sec)</span><br><span class=\"line\"> MySQL  Py &gt; myColl.add(&#123;'_id': '3', 'name': 'Lukas', 'age': 32&#125;).execute()</span><br><span class=\"line\">Query OK, 1 item affected (0.0010 sec)</span><br><span class=\"line\"> MySQL  Py &gt;</span><br><span class=\"line\"> MySQL  Py &gt; myColl.find().execute()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"_id\": \"1\",</span><br><span class=\"line\">    \"age\": 19,</span><br><span class=\"line\">    \"name\": \"Laurie\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"_id\": \"2\",</span><br><span class=\"line\">    \"age\": 54,</span><br><span class=\"line\">    \"name\": \"Nadya\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"_id\": \"3\",</span><br><span class=\"line\">    \"age\": 32,</span><br><span class=\"line\">    \"name\": \"Lukas\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">3 documents in set (0.0004 sec)</span><br><span class=\"line\"> MySQL  Py &gt;</span><br><span class=\"line\"> MySQL  Py &gt; \\sql</span><br><span class=\"line\">Switching to SQL mode... Commands end with ;</span><br><span class=\"line\"> MySQL  SQL &gt;</span><br><span class=\"line\"> MySQL  SQL &gt; \\connect test1@127.0.0.1:4932</span><br><span class=\"line\">Creating a session to 'test1@127.0.0.1:4932'</span><br><span class=\"line\">Please provide the password for 'test1@127.0.0.1:4932': ******</span><br><span class=\"line\">Fetching schema names for autocompletion... Press ^C to stop.</span><br><span class=\"line\">Your MySQL connection id is 31</span><br><span class=\"line\">Server version: 8.0.18-rds-dev Source distribution</span><br><span class=\"line\">No default schema selected; type \\use &lt;schema&gt; to set one.</span><br><span class=\"line\"> MySQL  127.0.0.1:4932 ssl  SQL &gt; use mytest</span><br><span class=\"line\">Default schema set to `mytest`.</span><br><span class=\"line\">Fetching table and column names from `mytest` for auto-completion... Press ^C to stop.</span><br><span class=\"line\"> MySQL  127.0.0.1:4932 ssl  mytest  SQL &gt; select * from my_collection;</span><br><span class=\"line\">+-------------------------------------------+-----+</span><br><span class=\"line\">| doc                                       | _id |</span><br><span class=\"line\">+-------------------------------------------+-----+</span><br><span class=\"line\">| &#123;\"_id\": \"1\", \"age\": 19, \"name\": \"Laurie\"&#125; | 1   |</span><br><span class=\"line\">| &#123;\"_id\": \"2\", \"age\": 54, \"name\": \"Nadya\"&#125;  | 2   |</span><br><span class=\"line\">| &#123;\"_id\": \"3\", \"age\": 32, \"name\": \"Lukas\"&#125;  | 3   |</span><br><span class=\"line\">+-------------------------------------------+-----+</span><br><span class=\"line\">3 rows in set (0.0006 sec)</span><br><span class=\"line\"> MySQL  127.0.0.1:4932 ssl  mytest  SQL &gt; \\q</span><br><span class=\"line\">Bye!</span><br></pre></td></tr></table></figure>\n\n\n\n<p>注意事项：</p>\n<ol>\n<li>mysqlsh 是 MySQL 提供的一个新的命令行工具，下载地址见：<a href=\"https://dev.mysql.com/downloads/shell/\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/downloads/shell/</a></li>\n<li>mysqlsh 提供了丰富的命令操作，详见：<a href=\"https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-commands.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-commands.html</a></li>\n<li>使用 mysqlsh 连接时，可能出现如下报错：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File \"&lt;string&gt;\", line 1, in &lt;module&gt;</span><br><span class=\"line\">mysqlsh.DBError: MySQL Error (5001): mysqlx.get_session: Capability prepare failed for 'tls'</span><br></pre></td></tr></table></figure>\n\n<p>这是因为 MySQL 没有配置 ssl，本地测试的话可以修改以下两个参数，自动生成证书：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto_detect_certs = ON</span><br><span class=\"line\">auto_generate_certs = ON</span><br></pre></td></tr></table></figure>"},{"title":"磁盘 IO 性能分析","date":"2020-09-13T09:32:55.000Z","_content":"\n数据库管理系统是基于文件系统建立起来的，在考虑数据库性能的时候，一个重要的考虑指标就是磁盘的 IO 性能，本篇文章就传统的机械磁盘（HDD）、固态硬盘（SSD）的 IO 性能进行定量的分析。\n\n<!-- more -->\n\n> https://cloud.tencent.com/developer/article/1159044\n>\n> https://juejin.im/post/6844904088715411463\n>\n> https://zhuanlan.zhihu.com/p/59514527\n\n","source":"_posts/others/io-performance.md","raw":"---\ntitle: 磁盘 IO 性能分析\ndate: 2020-09-13 17:32:55\ncategories: \n- 其它\n\n---\n\n数据库管理系统是基于文件系统建立起来的，在考虑数据库性能的时候，一个重要的考虑指标就是磁盘的 IO 性能，本篇文章就传统的机械磁盘（HDD）、固态硬盘（SSD）的 IO 性能进行定量的分析。\n\n<!-- more -->\n\n> https://cloud.tencent.com/developer/article/1159044\n>\n> https://juejin.im/post/6844904088715411463\n>\n> https://zhuanlan.zhihu.com/p/59514527\n\n","slug":"others/io-performance","published":1,"updated":"2020-12-05T12:03:08.177Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4xs001ngugm6hoohs61","content":"<p>数据库管理系统是基于文件系统建立起来的，在考虑数据库性能的时候，一个重要的考虑指标就是磁盘的 IO 性能，本篇文章就传统的机械磁盘（HDD）、固态硬盘（SSD）的 IO 性能进行定量的分析。</p>\n<a id=\"more\"></a>\n\n<blockquote>\n<p><a href=\"https://cloud.tencent.com/developer/article/1159044\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/article/1159044</a></p>\n<p><a href=\"https://juejin.im/post/6844904088715411463\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/6844904088715411463</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/59514527\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/59514527</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>数据库管理系统是基于文件系统建立起来的，在考虑数据库性能的时候，一个重要的考虑指标就是磁盘的 IO 性能，本篇文章就传统的机械磁盘（HDD）、固态硬盘（SSD）的 IO 性能进行定量的分析。</p>","more":"<blockquote>\n<p><a href=\"https://cloud.tencent.com/developer/article/1159044\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/article/1159044</a></p>\n<p><a href=\"https://juejin.im/post/6844904088715411463\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/6844904088715411463</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/59514527\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/59514527</a></p>\n</blockquote>"},{"title":"MySQL 事务提交过程","date":"2020-12-05T11:44:18.000Z","_content":"\n关于 MySQL 的事务提交过程，其实已经有很多文章进行过介绍，本文之所以还想再总结一遍是因为之前的文章都是从某一个或者某几个角度进行介绍，本文尝试从：binlog、gtid、semi-sync、undo、redo、trx等多个角度一起，将 MySQL 事务提交过程串联起来。\n\n<!-- more -->\n\n## 整体入门\n\n> 一条 SQL 的执行：https://time.geekbang.org/column/article/68633\n>\n> 日志相关问题：https://time.geekbang.org/column/article/73161\n>\n> 如何保证数据不丢：https://time.geekbang.org/column/article/76161\n>\n> 如何保证主备一致：https://time.geekbang.org/column/article/76446\n\n上面的文章是丁奇《MySQL实战45讲》中的部分内容，作者深入浅出的对 MySQL 的基本原理进行了介绍，非常适合对于 MySQL 的整体入门，本文中使用的图片也全部来自上述文章。通过上面的文章，需要对下面的问题有一个基本的概念：\n\n1. 事务提交的基本流程\n2. 为什么需要两阶段提交协议\n3. Crash Safe 是如何保障的\n4. 主备间如何进行同步\n5. GTID 的作用\n\n本文主要就上面几个问题分别进行展开说明。\n\n## 事务提交的基本流程\n\n以最简单的单行更新操作为例，数据的更新过程如下图：\n\n<img src=\"/images/server-trx-1.png\"  width=\"380px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n如上图所示，一个简单的更新操作包含了一下几个部分：\n\n1. 修改内存中的数据页。对于 InnoDB 来说，所有的内存页都是由 Buffer Pool 进行管理，修改数据页之前需要先记录 undo。undo 页和数据页的修改又都需要通过 redo 进行保护。\n2. 提交修改。不管是 auto-commit 模式还是手动提交，提交过程都需要完成以下几件事情：\n\n- - 将步骤 1 中生成的 redo 持久化（WAL）\n  - 记录 binlog\n  - 修改事务状态\n\n从图中可以看到，MySQL 内部将事务提交的过程分成了 3 个部分：\n\n1. 写 redo，修改事务状态为 prepared\n2. 写 binlog\n3. 修改事务状态为 commited\n\n关于提交过程，更详细的过程如下图：\n\n<img src=\"/images/server-trx-2.png\"  width=\"380px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n前面提到过，undo 页和数据页在内存中的数据结构都是通过 Buffer Pool 进行管理的；但是 redo log 和 binlog 使用了操作系统的 page cache 机制，即，write 操作只写入到 page cache 中，sync 操作才会持久化到磁盘。通过上图可以看到，在真实的提交过程中，通过拆解 redo log prepare 的过程来提高写入的性能，这里面涉及到了组提交（group commit）的概念，详细的过程后续再做介绍。下面结合代码进行分析：\n\n```c++\n|--> ha_commit_trans\n|    |--> tc_log->prepare  // MYSQL_BIN_LOG::prepare\n|    |    |--> ha_prepare_low\n|    |    |    |--> innobase_xa_prepare\n|    |\n|    |--> tc_log->commit  // MYSQL_BIN_LOG::commit\n|    |    |--> cache_mngr->trx_cache.finalize  // XID event\n|    |    |\n|    |    |--> ordered_commit\n|    |    |    |    // step 1\n|    |    |    |--> process_flush_stage_queue\n|    |    |    |    |--> assign_automatic_gtids_to_flush_group\n|    |    |    |    |    |--> generate_automatic_gtid\n|    |    |    |    |    |    |--> acquire_ownership\n|    |    |    |    |    |    |    |--> add_gtid_owner\n|    |    |    |    |--> flush_thread_caches\n|    |    |    |    |    |..> MYSQL_BIN_LOG::write_gtid  // GTID event\n|    |    |    |    |    |..> MYSQL_BIN_LOG::write_cache\n|    |    |    |--> flush_cache_to_file\n|    |    |    |\n|    |    |    |    // step 2\n|    |    |    |--> sync_binlog_file\n|    |    |    |--> update_binlog_end_pos\n|    |    |    |\n|    |    |    |    // step 3\n|    |    |    |--> call_after_sync_hook\n|    |    |    |--> process_commit_stage_queue\n|    |    |    |    |--> ha_commit_low\n|    |    |    |    |    |--> innobase_commit\n|    |    |    |--> process_after_commit_stage_queue\n|    |    |    |\n|    |    |    |--> finish_commit\n|    |    |    |    |--> gtid_state->update_on_commit\n|    |    |    |    |    |--> update_gtids_impl\n```\n\n回到事务提交的过程，整个事务提交的过程中有以下参与方：\n\n1. binlog ：逻辑日志\n2. innodb ：存储引擎\n3. XA ：XA 事务\n4. GTID：全局事务 ID\n\n这些内容会在后面部分分别进行详细介绍。\n\n## 为什么需要两阶段提交协议\n\n为什么需要两阶段提交协议？这个问题相信很多阅读 MySQL 代码的同学都会问到。从结果上来说，两阶段提交协议保证了 binlog 和 innodb 数据的完整性。换个角度，如果没有两阶段提交协议，可能会出现什么结果？可能的情况无非下面两种：\n\n1. 先写 binlog 成功，后写 redo 失败。\n2. 先写 redo 成功，后写 binlog 失败。\n\n对于第一种情况，若本机的实例 crash 后重启，需要通过 redo 进行恢复，由于写 redo 的时候失败了，所以无法进行恢复；对于第二种情况，备库接收到的 binlog 不完整，导致主备不一致。同样，利用 binlog 进行恢复时也会造成数据不完整。\n\n然而，两阶段提交过程本身真的是必须的吗？前面讨论两阶段提交必要性的时候，一个前提条件是：binlog 和 redo 的完整性。binlog 日志是 server 层记录的逻辑日志，提供归档能力；redo 是 innodb 层的物理日志，提供 crash-safe 能力。这个限制也是 MySQL 设计之初带来的。如果抛开这个限制，两阶段提交是否还是必须的？当前比较流性的存储-计算分离型数据库，包括：Aurora、PolarDB 等都采用了物理复制的方案，直接通过 redo 进行主备的同步。\n\n## Crash Safe 是如何保障的\n\n关于 crash-safe 的保障，再次引用一张图片进行说明：\n\n<img src=\"/images/server-trx-3.png\"  width=\"380px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n图中标注了系统可能出现故障的点，下面分别进行分析：\n\n1. 时刻 A 发生故障，此时事务状态还未修改完成，binlog 也未写入，恢复时对应的事务可以安全回滚；\n2. 时刻 B 发生故障，恢复时需要结合 binlog 的状态进行判断：如果 binlog 里面的内容完整，那么事务可以正常提交；否则需要进行回滚。如何判断 binlog 的内容是否完整呢？这里需要借助前面提到的 XID，server 层在记录 binlog 时，会在事务提交阶段写入一个 XID event，里面包含了当前事务的 XID 信息。如果在重放 redo 的过程中（redo 中无 commit 记录），在 binlog 中能够找到对应的 XID event，则说明对应的 binlog 内容完整，事务可以提交。\n\n一个简单的例子：\n\n```bash\nMySQL [(none)]> show master status;\n+------------------+----------+--------------+------------------+-------------------------------------------+\n| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                         |\n+------------------+----------+--------------+------------------+-------------------------------------------+\n| mysql-bin.000002 |      195 |              |                  | f778c1cc-24a9-11eb-9911-b8599f3009a8:1-15 |\n+------------------+----------+--------------+------------------+-------------------------------------------+\n1 row in set (0.00 sec)\n\nMySQL [mytest]> update t2 set c2 = 10 where id = 1;\nQuery OK, 1 row affected (11.62 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n\nMySQL [mytest]> show binlog events in 'mysql-bin.000002';\n+------------------+-----+----------------+------------+-------------+--------------------------------------------------------------------+\n| Log_name         | Pos | Event_type     | Server_id  | End_log_pos | Info                                                               |\n+------------------+-----+----------------+------------+-------------+--------------------------------------------------------------------+\n| mysql-bin.000002 |   4 | Format_desc    | 2762931378 |         124 | Server ver: 8.0.18-rds-dev-debug, Binlog ver: 4                    |\n| mysql-bin.000002 | 124 | Previous_gtids | 2762931378 |         195 | f778c1cc-24a9-11eb-9911-b8599f3009a8:1-15                          |\n| mysql-bin.000002 | 195 | Gtid           | 2762931378 |         274 | SET @@SESSION.GTID_NEXT= 'f778c1cc-24a9-11eb-9911-b8599f3009a8:16' |\n| mysql-bin.000002 | 274 | Query          | 2762931378 |         360 | BEGIN                                                              |\n| mysql-bin.000002 | 360 | Table_map      | 2762931378 |         412 | table_id: 87 (mytest.t2)                                           |\n| mysql-bin.000002 | 412 | Update_rows_v1 | 2762931378 |         472 | table_id: 87 flags: STMT_END_F                                     |\n| mysql-bin.000002 | 472 | Xid            | 2762931378 |         503 | COMMIT /* xid=14 */                                                |\n+------------------+-----+----------------+------------+-------------+--------------------------------------------------------------------+\n7 rows in set (0.00 sec)\n\nMySQL [mytest]> show master status;\n+------------------+----------+--------------+------------------+-------------------------------------------+\n| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                         |\n+------------------+----------+--------------+------------------+-------------------------------------------+\n| mysql-bin.000002 |      503 |              |                  | f778c1cc-24a9-11eb-9911-b8599f3009a8:1-16 |\n+------------------+----------+--------------+------------------+-------------------------------------------+\n1 row in set (0.00 sec)\n```\n\n对应的 binlog 文件内容：\n\n```bash\n$/flash3/guoqing.mgq/lizard-2.0/bin/mysqlbinlog -vvv mysql-bin.000002\n/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;\n/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;\nDELIMITER /*!*/;\n# at 4\n#201116  9:45:22 server id 2762931378  end_log_pos 124 CRC32 0x8169654a     Start: binlog v 4, server v 8.0.18-rds-dev-debug created 201116  9:45:22 at startup\n# Warning: this binlog is either in use or was not closed properly.\nROLLBACK/*!*/;\nBINLOG '\nstmxXw+y/K6keAAAAHwAAAABAAQAOC4wLjE4LXJkcy1kZXYtZGVidWcAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAACy2bFfEwANAAgAAAAABAAEAAAAYAAEGggAAAAICAgCAAAACgoKKioAEjQA\nCgFKZWmB\n'/*!*/;\n# at 124\n#201116  9:45:22 server id 2762931378  end_log_pos 195 CRC32 0x2fdbb3d5     Previous-GTIDs\n# f778c1cc-24a9-11eb-9911-b8599f3009a8:1-15\n# at 195\n#201116  9:49:07 server id 2762931378  end_log_pos 274 CRC32 0xd877c4e7     GTID    last_committed=0    sequence_number=1   rbr_only=yes    original_committed_timestamp=1605491358802675   immediate_commit_timestamp=1605491358802675 transaction_length=308\n/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;\n# original_commit_timestamp=1605491358802675 (2020-11-16 09:49:18.802675 CST)\n# immediate_commit_timestamp=1605491358802675 (2020-11-16 09:49:18.802675 CST)\n/*!80001 SET @@session.original_commit_timestamp=1605491358802675*//*!*/;\n/*!80014 SET @@session.original_server_version=80018*//*!*/;\n/*!80014 SET @@session.immediate_server_version=80018*//*!*/;\nSET @@SESSION.GTID_NEXT= 'f778c1cc-24a9-11eb-9911-b8599f3009a8:16'/*!*/;\n# at 274\n#201116  9:49:07 server id 2762931378  end_log_pos 360 CRC32 0x9d456972     Query   thread_id=8 exec_time=0 error_code=0\nSET TIMESTAMP=1605491347/*!*/;\nSET @@session.pseudo_thread_id=8/*!*/;\nSET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;\nSET @@session.sql_mode=0/*!*/;\nSET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;\n/*!\\C utf8 *//*!*/;\nSET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=33/*!*/;\nSET @@session.lc_time_names=0/*!*/;\nSET @@session.collation_database=DEFAULT/*!*/;\n/*!80011 SET @@session.default_collation_for_utf8mb4=255*//*!*/;\nBEGIN\n/*!*/;\n# at 360\n#201116  9:49:07 server id 2762931378  end_log_pos 412 CRC32 0xb6d1f3c1     Table_map: `mytest`.`t2` mapped to number 87\n# at 412\n#201116  9:49:07 server id 2762931378  end_log_pos 472 CRC32 0xb9c2d35e     Update_rows_v1: table id 87 flags: STMT_END_F\n\nBINLOG '\nk9qxXxOy/K6kNAAAAJwBAAAAAFcAAAAAAAEABm15dGVzdAACdDIAAwMDAwAGAQEAwfPRtg==\nk9qxXxiy/K6kPAAAANgBAAAAAFcAAAAAAAEAA///AAEAAAABAAAAAQAAAAABAAAAAQAAAAoAAABe\n08K5\n'/*!*/;\n### UPDATE `mytest`.`t2`\n### WHERE\n###   @1=1 /* INT meta=0 nullable=0 is_null=0 */\n###   @2=1 /* INT meta=0 nullable=1 is_null=0 */\n###   @3=1 /* INT meta=0 nullable=1 is_null=0 */\n### SET\n###   @1=1 /* INT meta=0 nullable=0 is_null=0 */\n###   @2=1 /* INT meta=0 nullable=1 is_null=0 */\n###   @3=10 /* INT meta=0 nullable=1 is_null=0 */\n# at 472\n#201116  9:49:07 server id 2762931378  end_log_pos 503 CRC32 0x027351e3     Xid = 14\nCOMMIT/*!*/;\nSET @@SESSION.GTID_NEXT= 'AUTOMATIC' /* added by mysqlbinlog */ /*!*/;\nDELIMITER ;\n# End of log file\n/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;\n/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;\n```\n\n## 主备间如何进行同步\n\nMySQL 通过 binlog 实现主备之间的同步，基本流程如下图：\n\n<img src=\"/images/server-trx-4.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n简单来说，MySQL 内部通过三个独立的线程来保证主备之间的 binlog 同步：\n\n1. dump 线程（主）：在事务提交过程中，写完 binlog 后会去更新当前 binlog 的位置，dump 线程根据该位置，向备节点发送新的 binlog；\n2. io 线程（备）：备节点上的 io 线程接收到主节点发来的 binlog，保存到本地的 relaylog，并向主节点进行回复；\n3. ack 线程（主）：接收备节点返回的确认消息，确定事务是否可以提交（WAIT_AFTER_SYNC 模式下）；\n\n在实际的同步过程中，主要通过以下的参数控制主备间的同步效率：\n\n- rpl_semi_sync_master_wait_point ：[WAIT_AFTER_COMMIT | WAIT_AFTER_SYNC] 同步等待的位点\n- rpl_semi_sync_master_timeout ：同步等待超时时间\n- sync_binlog ：binlog 刷盘策略\n- sync_relay_log ：relay log 刷盘策略\n\n## GTID 的作用\n\n前面已经提到了，MySQL 通过 binlog 来实现主备节点间的同步。在早期的版本中，进行同步前，需要在备节点上指定主节点的 binlog 位点信息，基本的语法如下：\n\n```sql\nCHANGE MASTER TO master_host='127.0.0.1',\nmaster_port=3932,\nmaster_user='replicator',\nmaster_password='123456',\nmaster_log_file='mysql-binlog.000001',\nmaster_log_pos=155;\n```\n\n备节点根据指定的位点信息从主节点进行同步。这种方式的主要问题是：当主备节点发生切换时，需要手动的修改 binlog 位点，运维比较麻烦，GTID 应运而生。关于 GTID 的入门，可以参考[这篇文章](https://dbaplus.cn/news-11-857-1.html)，本文尝试用比较简单的方式进行归纳。首先，GTID 作为全局事务 ID，有 source_id:transaction_id 组成，可以简单的理解为某个 MySQL 节点上的某个事务。在前面的例子中也可以看到，在每个事务（读写事务）执行时，binlog 都会记录一个类型为 gtid 的 event 用于指定接下来要执行的事务的 GTID。与此同时，MySQL 内部有一个专门的线程 clone_gtid_thread 负责将已经执行的 GTID 进行持久化，保存到 mysql 库下的 gtid_executed 表中。\n\n```c++\n|--> srv_start_threads_after_ddl_recovery\n|    |--> gtid_persistor.start()\n|    |    |--> os_thread_create(clone_gtid_thread)\n\n\n|--> clone_gtid_thread\n|    |--> persist_gtid->periodic_write\n|    |    |--> flush_gtids  // loop\n|    |    |    |--> gtid_table_persistor->fetch_gtids\n|    |    |    |\n|    |    |    |--> write_to_table  // 持久化到 gtid_executed 表\n|    |    |    |    |--> gtid_table_persistor->save\n|    |    |    |    |    |--> write_row\n|    |    |    |\n|    |    |    |--> trx_sys_oldest_trx_no\n|    |    |    |--> update_gtid_trx_no\n|    |    |    |    |--> trx_sys_persist_gtid_num  // 持久化到 trx_sys page\n|    |    |    |    |--> srv_purge_wakeup\n```\n\n接下来，备节点在收到对应的 binlog 后，会分别统计已接收到的 gtid 集合和已执行的 gtid 集合。备节点与主节点进行同步时，也会将上述 gtid 的集合发送到主节点，主节点根据备节点上已有的 gtid 信息，确定还需要发送哪些 binlog 给备节点，不再需要手动的修改同步位点。\n\n```sql\nCHANGE MASTER TO master_host='127.0.0.1',\nmaster_port=5932,\nmaster_user='replicator',\nmaster_password='123456',\nmaster_auto_position=1;\n```\n\n## 参考文献\n\nXA 与两阶段提交\n\n> http://mysql.taobao.org/monthly/2020/05/07/\n\nBinlog\n\n> http://mysql.taobao.org/monthly/2020/02/06/\n\n半同步复制\n\n> http://mysql.taobao.org/monthly/2017/04/01/\n>\n> http://mysql.taobao.org/monthly/2016/08/01/\n\nGTID\n\n> https://dbaplus.cn/news-11-857-1.html\n>\n> https://keithlan.github.io/2016/06/23/gtid/\n>\n> http://mysql.taobao.org/monthly/2020/05/09/\n>\n> https://www.cnblogs.com/MYSQLZOUQI/p/3850578.html\n\nInnoDB 事务子系统\n\n> http://mysql.taobao.org/monthly/2015/12/01/\n>\n> http://mysql.taobao.org/monthly/2017/12/01/","source":"_posts/mysql/transaction-commit.md","raw":"---\ntitle: MySQL 事务提交过程\ndate: 2020-12-05 19:44:18\ntags:\n- 事务\ncategories: \n- MySQL\n\n---\n\n关于 MySQL 的事务提交过程，其实已经有很多文章进行过介绍，本文之所以还想再总结一遍是因为之前的文章都是从某一个或者某几个角度进行介绍，本文尝试从：binlog、gtid、semi-sync、undo、redo、trx等多个角度一起，将 MySQL 事务提交过程串联起来。\n\n<!-- more -->\n\n## 整体入门\n\n> 一条 SQL 的执行：https://time.geekbang.org/column/article/68633\n>\n> 日志相关问题：https://time.geekbang.org/column/article/73161\n>\n> 如何保证数据不丢：https://time.geekbang.org/column/article/76161\n>\n> 如何保证主备一致：https://time.geekbang.org/column/article/76446\n\n上面的文章是丁奇《MySQL实战45讲》中的部分内容，作者深入浅出的对 MySQL 的基本原理进行了介绍，非常适合对于 MySQL 的整体入门，本文中使用的图片也全部来自上述文章。通过上面的文章，需要对下面的问题有一个基本的概念：\n\n1. 事务提交的基本流程\n2. 为什么需要两阶段提交协议\n3. Crash Safe 是如何保障的\n4. 主备间如何进行同步\n5. GTID 的作用\n\n本文主要就上面几个问题分别进行展开说明。\n\n## 事务提交的基本流程\n\n以最简单的单行更新操作为例，数据的更新过程如下图：\n\n<img src=\"/images/server-trx-1.png\"  width=\"380px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n如上图所示，一个简单的更新操作包含了一下几个部分：\n\n1. 修改内存中的数据页。对于 InnoDB 来说，所有的内存页都是由 Buffer Pool 进行管理，修改数据页之前需要先记录 undo。undo 页和数据页的修改又都需要通过 redo 进行保护。\n2. 提交修改。不管是 auto-commit 模式还是手动提交，提交过程都需要完成以下几件事情：\n\n- - 将步骤 1 中生成的 redo 持久化（WAL）\n  - 记录 binlog\n  - 修改事务状态\n\n从图中可以看到，MySQL 内部将事务提交的过程分成了 3 个部分：\n\n1. 写 redo，修改事务状态为 prepared\n2. 写 binlog\n3. 修改事务状态为 commited\n\n关于提交过程，更详细的过程如下图：\n\n<img src=\"/images/server-trx-2.png\"  width=\"380px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n前面提到过，undo 页和数据页在内存中的数据结构都是通过 Buffer Pool 进行管理的；但是 redo log 和 binlog 使用了操作系统的 page cache 机制，即，write 操作只写入到 page cache 中，sync 操作才会持久化到磁盘。通过上图可以看到，在真实的提交过程中，通过拆解 redo log prepare 的过程来提高写入的性能，这里面涉及到了组提交（group commit）的概念，详细的过程后续再做介绍。下面结合代码进行分析：\n\n```c++\n|--> ha_commit_trans\n|    |--> tc_log->prepare  // MYSQL_BIN_LOG::prepare\n|    |    |--> ha_prepare_low\n|    |    |    |--> innobase_xa_prepare\n|    |\n|    |--> tc_log->commit  // MYSQL_BIN_LOG::commit\n|    |    |--> cache_mngr->trx_cache.finalize  // XID event\n|    |    |\n|    |    |--> ordered_commit\n|    |    |    |    // step 1\n|    |    |    |--> process_flush_stage_queue\n|    |    |    |    |--> assign_automatic_gtids_to_flush_group\n|    |    |    |    |    |--> generate_automatic_gtid\n|    |    |    |    |    |    |--> acquire_ownership\n|    |    |    |    |    |    |    |--> add_gtid_owner\n|    |    |    |    |--> flush_thread_caches\n|    |    |    |    |    |..> MYSQL_BIN_LOG::write_gtid  // GTID event\n|    |    |    |    |    |..> MYSQL_BIN_LOG::write_cache\n|    |    |    |--> flush_cache_to_file\n|    |    |    |\n|    |    |    |    // step 2\n|    |    |    |--> sync_binlog_file\n|    |    |    |--> update_binlog_end_pos\n|    |    |    |\n|    |    |    |    // step 3\n|    |    |    |--> call_after_sync_hook\n|    |    |    |--> process_commit_stage_queue\n|    |    |    |    |--> ha_commit_low\n|    |    |    |    |    |--> innobase_commit\n|    |    |    |--> process_after_commit_stage_queue\n|    |    |    |\n|    |    |    |--> finish_commit\n|    |    |    |    |--> gtid_state->update_on_commit\n|    |    |    |    |    |--> update_gtids_impl\n```\n\n回到事务提交的过程，整个事务提交的过程中有以下参与方：\n\n1. binlog ：逻辑日志\n2. innodb ：存储引擎\n3. XA ：XA 事务\n4. GTID：全局事务 ID\n\n这些内容会在后面部分分别进行详细介绍。\n\n## 为什么需要两阶段提交协议\n\n为什么需要两阶段提交协议？这个问题相信很多阅读 MySQL 代码的同学都会问到。从结果上来说，两阶段提交协议保证了 binlog 和 innodb 数据的完整性。换个角度，如果没有两阶段提交协议，可能会出现什么结果？可能的情况无非下面两种：\n\n1. 先写 binlog 成功，后写 redo 失败。\n2. 先写 redo 成功，后写 binlog 失败。\n\n对于第一种情况，若本机的实例 crash 后重启，需要通过 redo 进行恢复，由于写 redo 的时候失败了，所以无法进行恢复；对于第二种情况，备库接收到的 binlog 不完整，导致主备不一致。同样，利用 binlog 进行恢复时也会造成数据不完整。\n\n然而，两阶段提交过程本身真的是必须的吗？前面讨论两阶段提交必要性的时候，一个前提条件是：binlog 和 redo 的完整性。binlog 日志是 server 层记录的逻辑日志，提供归档能力；redo 是 innodb 层的物理日志，提供 crash-safe 能力。这个限制也是 MySQL 设计之初带来的。如果抛开这个限制，两阶段提交是否还是必须的？当前比较流性的存储-计算分离型数据库，包括：Aurora、PolarDB 等都采用了物理复制的方案，直接通过 redo 进行主备的同步。\n\n## Crash Safe 是如何保障的\n\n关于 crash-safe 的保障，再次引用一张图片进行说明：\n\n<img src=\"/images/server-trx-3.png\"  width=\"380px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n图中标注了系统可能出现故障的点，下面分别进行分析：\n\n1. 时刻 A 发生故障，此时事务状态还未修改完成，binlog 也未写入，恢复时对应的事务可以安全回滚；\n2. 时刻 B 发生故障，恢复时需要结合 binlog 的状态进行判断：如果 binlog 里面的内容完整，那么事务可以正常提交；否则需要进行回滚。如何判断 binlog 的内容是否完整呢？这里需要借助前面提到的 XID，server 层在记录 binlog 时，会在事务提交阶段写入一个 XID event，里面包含了当前事务的 XID 信息。如果在重放 redo 的过程中（redo 中无 commit 记录），在 binlog 中能够找到对应的 XID event，则说明对应的 binlog 内容完整，事务可以提交。\n\n一个简单的例子：\n\n```bash\nMySQL [(none)]> show master status;\n+------------------+----------+--------------+------------------+-------------------------------------------+\n| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                         |\n+------------------+----------+--------------+------------------+-------------------------------------------+\n| mysql-bin.000002 |      195 |              |                  | f778c1cc-24a9-11eb-9911-b8599f3009a8:1-15 |\n+------------------+----------+--------------+------------------+-------------------------------------------+\n1 row in set (0.00 sec)\n\nMySQL [mytest]> update t2 set c2 = 10 where id = 1;\nQuery OK, 1 row affected (11.62 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n\nMySQL [mytest]> show binlog events in 'mysql-bin.000002';\n+------------------+-----+----------------+------------+-------------+--------------------------------------------------------------------+\n| Log_name         | Pos | Event_type     | Server_id  | End_log_pos | Info                                                               |\n+------------------+-----+----------------+------------+-------------+--------------------------------------------------------------------+\n| mysql-bin.000002 |   4 | Format_desc    | 2762931378 |         124 | Server ver: 8.0.18-rds-dev-debug, Binlog ver: 4                    |\n| mysql-bin.000002 | 124 | Previous_gtids | 2762931378 |         195 | f778c1cc-24a9-11eb-9911-b8599f3009a8:1-15                          |\n| mysql-bin.000002 | 195 | Gtid           | 2762931378 |         274 | SET @@SESSION.GTID_NEXT= 'f778c1cc-24a9-11eb-9911-b8599f3009a8:16' |\n| mysql-bin.000002 | 274 | Query          | 2762931378 |         360 | BEGIN                                                              |\n| mysql-bin.000002 | 360 | Table_map      | 2762931378 |         412 | table_id: 87 (mytest.t2)                                           |\n| mysql-bin.000002 | 412 | Update_rows_v1 | 2762931378 |         472 | table_id: 87 flags: STMT_END_F                                     |\n| mysql-bin.000002 | 472 | Xid            | 2762931378 |         503 | COMMIT /* xid=14 */                                                |\n+------------------+-----+----------------+------------+-------------+--------------------------------------------------------------------+\n7 rows in set (0.00 sec)\n\nMySQL [mytest]> show master status;\n+------------------+----------+--------------+------------------+-------------------------------------------+\n| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                         |\n+------------------+----------+--------------+------------------+-------------------------------------------+\n| mysql-bin.000002 |      503 |              |                  | f778c1cc-24a9-11eb-9911-b8599f3009a8:1-16 |\n+------------------+----------+--------------+------------------+-------------------------------------------+\n1 row in set (0.00 sec)\n```\n\n对应的 binlog 文件内容：\n\n```bash\n$/flash3/guoqing.mgq/lizard-2.0/bin/mysqlbinlog -vvv mysql-bin.000002\n/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;\n/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;\nDELIMITER /*!*/;\n# at 4\n#201116  9:45:22 server id 2762931378  end_log_pos 124 CRC32 0x8169654a     Start: binlog v 4, server v 8.0.18-rds-dev-debug created 201116  9:45:22 at startup\n# Warning: this binlog is either in use or was not closed properly.\nROLLBACK/*!*/;\nBINLOG '\nstmxXw+y/K6keAAAAHwAAAABAAQAOC4wLjE4LXJkcy1kZXYtZGVidWcAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAACy2bFfEwANAAgAAAAABAAEAAAAYAAEGggAAAAICAgCAAAACgoKKioAEjQA\nCgFKZWmB\n'/*!*/;\n# at 124\n#201116  9:45:22 server id 2762931378  end_log_pos 195 CRC32 0x2fdbb3d5     Previous-GTIDs\n# f778c1cc-24a9-11eb-9911-b8599f3009a8:1-15\n# at 195\n#201116  9:49:07 server id 2762931378  end_log_pos 274 CRC32 0xd877c4e7     GTID    last_committed=0    sequence_number=1   rbr_only=yes    original_committed_timestamp=1605491358802675   immediate_commit_timestamp=1605491358802675 transaction_length=308\n/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;\n# original_commit_timestamp=1605491358802675 (2020-11-16 09:49:18.802675 CST)\n# immediate_commit_timestamp=1605491358802675 (2020-11-16 09:49:18.802675 CST)\n/*!80001 SET @@session.original_commit_timestamp=1605491358802675*//*!*/;\n/*!80014 SET @@session.original_server_version=80018*//*!*/;\n/*!80014 SET @@session.immediate_server_version=80018*//*!*/;\nSET @@SESSION.GTID_NEXT= 'f778c1cc-24a9-11eb-9911-b8599f3009a8:16'/*!*/;\n# at 274\n#201116  9:49:07 server id 2762931378  end_log_pos 360 CRC32 0x9d456972     Query   thread_id=8 exec_time=0 error_code=0\nSET TIMESTAMP=1605491347/*!*/;\nSET @@session.pseudo_thread_id=8/*!*/;\nSET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;\nSET @@session.sql_mode=0/*!*/;\nSET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;\n/*!\\C utf8 *//*!*/;\nSET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=33/*!*/;\nSET @@session.lc_time_names=0/*!*/;\nSET @@session.collation_database=DEFAULT/*!*/;\n/*!80011 SET @@session.default_collation_for_utf8mb4=255*//*!*/;\nBEGIN\n/*!*/;\n# at 360\n#201116  9:49:07 server id 2762931378  end_log_pos 412 CRC32 0xb6d1f3c1     Table_map: `mytest`.`t2` mapped to number 87\n# at 412\n#201116  9:49:07 server id 2762931378  end_log_pos 472 CRC32 0xb9c2d35e     Update_rows_v1: table id 87 flags: STMT_END_F\n\nBINLOG '\nk9qxXxOy/K6kNAAAAJwBAAAAAFcAAAAAAAEABm15dGVzdAACdDIAAwMDAwAGAQEAwfPRtg==\nk9qxXxiy/K6kPAAAANgBAAAAAFcAAAAAAAEAA///AAEAAAABAAAAAQAAAAABAAAAAQAAAAoAAABe\n08K5\n'/*!*/;\n### UPDATE `mytest`.`t2`\n### WHERE\n###   @1=1 /* INT meta=0 nullable=0 is_null=0 */\n###   @2=1 /* INT meta=0 nullable=1 is_null=0 */\n###   @3=1 /* INT meta=0 nullable=1 is_null=0 */\n### SET\n###   @1=1 /* INT meta=0 nullable=0 is_null=0 */\n###   @2=1 /* INT meta=0 nullable=1 is_null=0 */\n###   @3=10 /* INT meta=0 nullable=1 is_null=0 */\n# at 472\n#201116  9:49:07 server id 2762931378  end_log_pos 503 CRC32 0x027351e3     Xid = 14\nCOMMIT/*!*/;\nSET @@SESSION.GTID_NEXT= 'AUTOMATIC' /* added by mysqlbinlog */ /*!*/;\nDELIMITER ;\n# End of log file\n/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;\n/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;\n```\n\n## 主备间如何进行同步\n\nMySQL 通过 binlog 实现主备之间的同步，基本流程如下图：\n\n<img src=\"/images/server-trx-4.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n简单来说，MySQL 内部通过三个独立的线程来保证主备之间的 binlog 同步：\n\n1. dump 线程（主）：在事务提交过程中，写完 binlog 后会去更新当前 binlog 的位置，dump 线程根据该位置，向备节点发送新的 binlog；\n2. io 线程（备）：备节点上的 io 线程接收到主节点发来的 binlog，保存到本地的 relaylog，并向主节点进行回复；\n3. ack 线程（主）：接收备节点返回的确认消息，确定事务是否可以提交（WAIT_AFTER_SYNC 模式下）；\n\n在实际的同步过程中，主要通过以下的参数控制主备间的同步效率：\n\n- rpl_semi_sync_master_wait_point ：[WAIT_AFTER_COMMIT | WAIT_AFTER_SYNC] 同步等待的位点\n- rpl_semi_sync_master_timeout ：同步等待超时时间\n- sync_binlog ：binlog 刷盘策略\n- sync_relay_log ：relay log 刷盘策略\n\n## GTID 的作用\n\n前面已经提到了，MySQL 通过 binlog 来实现主备节点间的同步。在早期的版本中，进行同步前，需要在备节点上指定主节点的 binlog 位点信息，基本的语法如下：\n\n```sql\nCHANGE MASTER TO master_host='127.0.0.1',\nmaster_port=3932,\nmaster_user='replicator',\nmaster_password='123456',\nmaster_log_file='mysql-binlog.000001',\nmaster_log_pos=155;\n```\n\n备节点根据指定的位点信息从主节点进行同步。这种方式的主要问题是：当主备节点发生切换时，需要手动的修改 binlog 位点，运维比较麻烦，GTID 应运而生。关于 GTID 的入门，可以参考[这篇文章](https://dbaplus.cn/news-11-857-1.html)，本文尝试用比较简单的方式进行归纳。首先，GTID 作为全局事务 ID，有 source_id:transaction_id 组成，可以简单的理解为某个 MySQL 节点上的某个事务。在前面的例子中也可以看到，在每个事务（读写事务）执行时，binlog 都会记录一个类型为 gtid 的 event 用于指定接下来要执行的事务的 GTID。与此同时，MySQL 内部有一个专门的线程 clone_gtid_thread 负责将已经执行的 GTID 进行持久化，保存到 mysql 库下的 gtid_executed 表中。\n\n```c++\n|--> srv_start_threads_after_ddl_recovery\n|    |--> gtid_persistor.start()\n|    |    |--> os_thread_create(clone_gtid_thread)\n\n\n|--> clone_gtid_thread\n|    |--> persist_gtid->periodic_write\n|    |    |--> flush_gtids  // loop\n|    |    |    |--> gtid_table_persistor->fetch_gtids\n|    |    |    |\n|    |    |    |--> write_to_table  // 持久化到 gtid_executed 表\n|    |    |    |    |--> gtid_table_persistor->save\n|    |    |    |    |    |--> write_row\n|    |    |    |\n|    |    |    |--> trx_sys_oldest_trx_no\n|    |    |    |--> update_gtid_trx_no\n|    |    |    |    |--> trx_sys_persist_gtid_num  // 持久化到 trx_sys page\n|    |    |    |    |--> srv_purge_wakeup\n```\n\n接下来，备节点在收到对应的 binlog 后，会分别统计已接收到的 gtid 集合和已执行的 gtid 集合。备节点与主节点进行同步时，也会将上述 gtid 的集合发送到主节点，主节点根据备节点上已有的 gtid 信息，确定还需要发送哪些 binlog 给备节点，不再需要手动的修改同步位点。\n\n```sql\nCHANGE MASTER TO master_host='127.0.0.1',\nmaster_port=5932,\nmaster_user='replicator',\nmaster_password='123456',\nmaster_auto_position=1;\n```\n\n## 参考文献\n\nXA 与两阶段提交\n\n> http://mysql.taobao.org/monthly/2020/05/07/\n\nBinlog\n\n> http://mysql.taobao.org/monthly/2020/02/06/\n\n半同步复制\n\n> http://mysql.taobao.org/monthly/2017/04/01/\n>\n> http://mysql.taobao.org/monthly/2016/08/01/\n\nGTID\n\n> https://dbaplus.cn/news-11-857-1.html\n>\n> https://keithlan.github.io/2016/06/23/gtid/\n>\n> http://mysql.taobao.org/monthly/2020/05/09/\n>\n> https://www.cnblogs.com/MYSQLZOUQI/p/3850578.html\n\nInnoDB 事务子系统\n\n> http://mysql.taobao.org/monthly/2015/12/01/\n>\n> http://mysql.taobao.org/monthly/2017/12/01/","slug":"mysql/transaction-commit","published":1,"updated":"2020-12-05T12:02:15.109Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4xu001sgugmdccyeddd","content":"<p>关于 MySQL 的事务提交过程，其实已经有很多文章进行过介绍，本文之所以还想再总结一遍是因为之前的文章都是从某一个或者某几个角度进行介绍，本文尝试从：binlog、gtid、semi-sync、undo、redo、trx等多个角度一起，将 MySQL 事务提交过程串联起来。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"整体入门\"><a href=\"#整体入门\" class=\"headerlink\" title=\"整体入门\"></a>整体入门</h2><blockquote>\n<p>一条 SQL 的执行：<a href=\"https://time.geekbang.org/column/article/68633\" target=\"_blank\" rel=\"noopener\">https://time.geekbang.org/column/article/68633</a></p>\n<p>日志相关问题：<a href=\"https://time.geekbang.org/column/article/73161\" target=\"_blank\" rel=\"noopener\">https://time.geekbang.org/column/article/73161</a></p>\n<p>如何保证数据不丢：<a href=\"https://time.geekbang.org/column/article/76161\" target=\"_blank\" rel=\"noopener\">https://time.geekbang.org/column/article/76161</a></p>\n<p>如何保证主备一致：<a href=\"https://time.geekbang.org/column/article/76446\" target=\"_blank\" rel=\"noopener\">https://time.geekbang.org/column/article/76446</a></p>\n</blockquote>\n<p>上面的文章是丁奇《MySQL实战45讲》中的部分内容，作者深入浅出的对 MySQL 的基本原理进行了介绍，非常适合对于 MySQL 的整体入门，本文中使用的图片也全部来自上述文章。通过上面的文章，需要对下面的问题有一个基本的概念：</p>\n<ol>\n<li>事务提交的基本流程</li>\n<li>为什么需要两阶段提交协议</li>\n<li>Crash Safe 是如何保障的</li>\n<li>主备间如何进行同步</li>\n<li>GTID 的作用</li>\n</ol>\n<p>本文主要就上面几个问题分别进行展开说明。</p>\n<h2 id=\"事务提交的基本流程\"><a href=\"#事务提交的基本流程\" class=\"headerlink\" title=\"事务提交的基本流程\"></a>事务提交的基本流程</h2><p>以最简单的单行更新操作为例，数据的更新过程如下图：</p>\n<img src=\"/images/server-trx-1.png\"  width=\"380px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>如上图所示，一个简单的更新操作包含了一下几个部分：</p>\n<ol>\n<li>修改内存中的数据页。对于 InnoDB 来说，所有的内存页都是由 Buffer Pool 进行管理，修改数据页之前需要先记录 undo。undo 页和数据页的修改又都需要通过 redo 进行保护。</li>\n<li>提交修改。不管是 auto-commit 模式还是手动提交，提交过程都需要完成以下几件事情：</li>\n</ol>\n<ul>\n<li><ul>\n<li>将步骤 1 中生成的 redo 持久化（WAL）</li>\n<li>记录 binlog</li>\n<li>修改事务状态</li>\n</ul>\n</li>\n</ul>\n<p>从图中可以看到，MySQL 内部将事务提交的过程分成了 3 个部分：</p>\n<ol>\n<li>写 redo，修改事务状态为 prepared</li>\n<li>写 binlog</li>\n<li>修改事务状态为 commited</li>\n</ol>\n<p>关于提交过程，更详细的过程如下图：</p>\n<img src=\"/images/server-trx-2.png\"  width=\"380px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>前面提到过，undo 页和数据页在内存中的数据结构都是通过 Buffer Pool 进行管理的；但是 redo log 和 binlog 使用了操作系统的 page cache 机制，即，write 操作只写入到 page cache 中，sync 操作才会持久化到磁盘。通过上图可以看到，在真实的提交过程中，通过拆解 redo log prepare 的过程来提高写入的性能，这里面涉及到了组提交（group commit）的概念，详细的过程后续再做介绍。下面结合代码进行分析：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; ha_commit_trans</span><br><span class=\"line\">|    |--&gt; tc_log-&gt;<span class=\"built_in\">prepare</span>  <span class=\"comment\">// MYSQL_BIN_LOG::prepare</span></span><br><span class=\"line\">|    |    |--&gt; ha_prepare_low</span><br><span class=\"line\">|    |    |    |--&gt; innobase_xa_prepare</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; tc_log-&gt;commit  <span class=\"comment\">// MYSQL_BIN_LOG::commit</span></span><br><span class=\"line\">|    |    |--&gt; cache_mngr-&gt;trx_cache.finalize  <span class=\"comment\">// XID event</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; ordered_commit</span><br><span class=\"line\">|    |    |    |    <span class=\"comment\">// step 1</span></span><br><span class=\"line\">|    |    |    |--&gt; process_flush_stage_queue</span><br><span class=\"line\">|    |    |    |    |--&gt; assign_automatic_gtids_to_flush_group</span><br><span class=\"line\">|    |    |    |    |    |--&gt; generate_automatic_gtid</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; acquire_ownership</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; add_gtid_owner</span><br><span class=\"line\">|    |    |    |    |--&gt; flush_thread_caches</span><br><span class=\"line\">|    |    |    |    |    |..&gt; MYSQL_BIN_LOG::write_gtid  <span class=\"comment\">// GTID event</span></span><br><span class=\"line\">|    |    |    |    |    |..&gt; MYSQL_BIN_LOG::write_cache</span><br><span class=\"line\">|    |    |    |--&gt; flush_cache_to_file</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |    <span class=\"comment\">// step 2</span></span><br><span class=\"line\">|    |    |    |--&gt; sync_binlog_file</span><br><span class=\"line\">|    |    |    |--&gt; update_binlog_end_pos</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |    <span class=\"comment\">// step 3</span></span><br><span class=\"line\">|    |    |    |--&gt; call_after_sync_hook</span><br><span class=\"line\">|    |    |    |--&gt; process_commit_stage_queue</span><br><span class=\"line\">|    |    |    |    |--&gt; ha_commit_low</span><br><span class=\"line\">|    |    |    |    |    |--&gt; innobase_commit</span><br><span class=\"line\">|    |    |    |--&gt; process_after_commit_stage_queue</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; finish_commit</span><br><span class=\"line\">|    |    |    |    |--&gt; gtid_state-&gt;update_on_commit</span><br><span class=\"line\">|    |    |    |    |    |--&gt; update_gtids_impl</span><br></pre></td></tr></table></figure>\n\n<p>回到事务提交的过程，整个事务提交的过程中有以下参与方：</p>\n<ol>\n<li>binlog ：逻辑日志</li>\n<li>innodb ：存储引擎</li>\n<li>XA ：XA 事务</li>\n<li>GTID：全局事务 ID</li>\n</ol>\n<p>这些内容会在后面部分分别进行详细介绍。</p>\n<h2 id=\"为什么需要两阶段提交协议\"><a href=\"#为什么需要两阶段提交协议\" class=\"headerlink\" title=\"为什么需要两阶段提交协议\"></a>为什么需要两阶段提交协议</h2><p>为什么需要两阶段提交协议？这个问题相信很多阅读 MySQL 代码的同学都会问到。从结果上来说，两阶段提交协议保证了 binlog 和 innodb 数据的完整性。换个角度，如果没有两阶段提交协议，可能会出现什么结果？可能的情况无非下面两种：</p>\n<ol>\n<li>先写 binlog 成功，后写 redo 失败。</li>\n<li>先写 redo 成功，后写 binlog 失败。</li>\n</ol>\n<p>对于第一种情况，若本机的实例 crash 后重启，需要通过 redo 进行恢复，由于写 redo 的时候失败了，所以无法进行恢复；对于第二种情况，备库接收到的 binlog 不完整，导致主备不一致。同样，利用 binlog 进行恢复时也会造成数据不完整。</p>\n<p>然而，两阶段提交过程本身真的是必须的吗？前面讨论两阶段提交必要性的时候，一个前提条件是：binlog 和 redo 的完整性。binlog 日志是 server 层记录的逻辑日志，提供归档能力；redo 是 innodb 层的物理日志，提供 crash-safe 能力。这个限制也是 MySQL 设计之初带来的。如果抛开这个限制，两阶段提交是否还是必须的？当前比较流性的存储-计算分离型数据库，包括：Aurora、PolarDB 等都采用了物理复制的方案，直接通过 redo 进行主备的同步。</p>\n<h2 id=\"Crash-Safe-是如何保障的\"><a href=\"#Crash-Safe-是如何保障的\" class=\"headerlink\" title=\"Crash Safe 是如何保障的\"></a>Crash Safe 是如何保障的</h2><p>关于 crash-safe 的保障，再次引用一张图片进行说明：</p>\n<img src=\"/images/server-trx-3.png\"  width=\"380px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>图中标注了系统可能出现故障的点，下面分别进行分析：</p>\n<ol>\n<li>时刻 A 发生故障，此时事务状态还未修改完成，binlog 也未写入，恢复时对应的事务可以安全回滚；</li>\n<li>时刻 B 发生故障，恢复时需要结合 binlog 的状态进行判断：如果 binlog 里面的内容完整，那么事务可以正常提交；否则需要进行回滚。如何判断 binlog 的内容是否完整呢？这里需要借助前面提到的 XID，server 层在记录 binlog 时，会在事务提交阶段写入一个 XID event，里面包含了当前事务的 XID 信息。如果在重放 redo 的过程中（redo 中无 commit 记录），在 binlog 中能够找到对应的 XID event，则说明对应的 binlog 内容完整，事务可以提交。</li>\n</ol>\n<p>一个简单的例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MySQL [(none)]&gt; show master status;</span><br><span class=\"line\">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class=\"line\">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                         |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class=\"line\">| mysql-bin.000002 |      195 |              |                  | f778c1cc-24a9-11eb-9911-b8599f3009a8:1-15 |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class=\"line\">1 row <span class=\"keyword\">in</span> <span class=\"built_in\">set</span> (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">MySQL [mytest]&gt; update t2 <span class=\"built_in\">set</span> c2 = 10 <span class=\"built_in\">where</span> id = 1;</span><br><span class=\"line\">Query OK, 1 row affected (11.62 sec)</span><br><span class=\"line\">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class=\"line\"></span><br><span class=\"line\">MySQL [mytest]&gt; show binlog events <span class=\"keyword\">in</span> <span class=\"string\">'mysql-bin.000002'</span>;</span><br><span class=\"line\">+------------------+-----+----------------+------------+-------------+--------------------------------------------------------------------+</span><br><span class=\"line\">| Log_name         | Pos | Event_type     | Server_id  | End_log_pos | Info                                                               |</span><br><span class=\"line\">+------------------+-----+----------------+------------+-------------+--------------------------------------------------------------------+</span><br><span class=\"line\">| mysql-bin.000002 |   4 | Format_desc    | 2762931378 |         124 | Server ver: 8.0.18-rds-dev-debug, Binlog ver: 4                    |</span><br><span class=\"line\">| mysql-bin.000002 | 124 | Previous_gtids | 2762931378 |         195 | f778c1cc-24a9-11eb-9911-b8599f3009a8:1-15                          |</span><br><span class=\"line\">| mysql-bin.000002 | 195 | Gtid           | 2762931378 |         274 | SET @@SESSION.GTID_NEXT= <span class=\"string\">'f778c1cc-24a9-11eb-9911-b8599f3009a8:16'</span> |</span><br><span class=\"line\">| mysql-bin.000002 | 274 | Query          | 2762931378 |         360 | BEGIN                                                              |</span><br><span class=\"line\">| mysql-bin.000002 | 360 | Table_map      | 2762931378 |         412 | table_id: 87 (mytest.t2)                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 412 | Update_rows_v1 | 2762931378 |         472 | table_id: 87 flags: STMT_END_F                                     |</span><br><span class=\"line\">| mysql-bin.000002 | 472 | Xid            | 2762931378 |         503 | COMMIT /* xid=14 */                                                |</span><br><span class=\"line\">+------------------+-----+----------------+------------+-------------+--------------------------------------------------------------------+</span><br><span class=\"line\">7 rows <span class=\"keyword\">in</span> <span class=\"built_in\">set</span> (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">MySQL [mytest]&gt; show master status;</span><br><span class=\"line\">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class=\"line\">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                         |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class=\"line\">| mysql-bin.000002 |      503 |              |                  | f778c1cc-24a9-11eb-9911-b8599f3009a8:1-16 |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class=\"line\">1 row <span class=\"keyword\">in</span> <span class=\"built_in\">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>对应的 binlog 文件内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$/flash3/guoqing.mgq/lizard-2.0/bin/mysqlbinlog -vvv mysql-bin.000002</span><br><span class=\"line\">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;</span><br><span class=\"line\">/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;</span><br><span class=\"line\">DELIMITER /*!*/;</span><br><span class=\"line\"><span class=\"comment\"># at 4</span></span><br><span class=\"line\"><span class=\"comment\">#201116  9:45:22 server id 2762931378  end_log_pos 124 CRC32 0x8169654a     Start: binlog v 4, server v 8.0.18-rds-dev-debug created 201116  9:45:22 at startup</span></span><br><span class=\"line\"><span class=\"comment\"># Warning: this binlog is either in use or was not closed properly.</span></span><br><span class=\"line\">ROLLBACK/*!*/;</span><br><span class=\"line\">BINLOG <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">stmxXw+y/K6keAAAAHwAAAABAAQAOC4wLjE4LXJkcy1kZXYtZGVidWcAAAAAAAAAAAAAAAAAAAAA</span></span><br><span class=\"line\"><span class=\"string\">AAAAAAAAAAAAAAAAAACy2bFfEwANAAgAAAAABAAEAAAAYAAEGggAAAAICAgCAAAACgoKKioAEjQA</span></span><br><span class=\"line\"><span class=\"string\">CgFKZWmB</span></span><br><span class=\"line\"><span class=\"string\">'</span>/*!*/;</span><br><span class=\"line\"><span class=\"comment\"># at 124</span></span><br><span class=\"line\"><span class=\"comment\">#201116  9:45:22 server id 2762931378  end_log_pos 195 CRC32 0x2fdbb3d5     Previous-GTIDs</span></span><br><span class=\"line\"><span class=\"comment\"># f778c1cc-24a9-11eb-9911-b8599f3009a8:1-15</span></span><br><span class=\"line\"><span class=\"comment\"># at 195</span></span><br><span class=\"line\"><span class=\"comment\">#201116  9:49:07 server id 2762931378  end_log_pos 274 CRC32 0xd877c4e7     GTID    last_committed=0    sequence_number=1   rbr_only=yes    original_committed_timestamp=1605491358802675   immediate_commit_timestamp=1605491358802675 transaction_length=308</span></span><br><span class=\"line\">/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;</span><br><span class=\"line\"><span class=\"comment\"># original_commit_timestamp=1605491358802675 (2020-11-16 09:49:18.802675 CST)</span></span><br><span class=\"line\"><span class=\"comment\"># immediate_commit_timestamp=1605491358802675 (2020-11-16 09:49:18.802675 CST)</span></span><br><span class=\"line\">/*!80001 SET @@session.original_commit_timestamp=1605491358802675*//*!*/;</span><br><span class=\"line\">/*!80014 SET @@session.original_server_version=80018*//*!*/;</span><br><span class=\"line\">/*!80014 SET @@session.immediate_server_version=80018*//*!*/;</span><br><span class=\"line\">SET @@SESSION.GTID_NEXT= <span class=\"string\">'f778c1cc-24a9-11eb-9911-b8599f3009a8:16'</span>/*!*/;</span><br><span class=\"line\"><span class=\"comment\"># at 274</span></span><br><span class=\"line\"><span class=\"comment\">#201116  9:49:07 server id 2762931378  end_log_pos 360 CRC32 0x9d456972     Query   thread_id=8 exec_time=0 error_code=0</span></span><br><span class=\"line\">SET TIMESTAMP=1605491347/*!*/;</span><br><span class=\"line\">SET @@session.pseudo_thread_id=8/*!*/;</span><br><span class=\"line\">SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;</span><br><span class=\"line\">SET @@session.sql_mode=0/*!*/;</span><br><span class=\"line\">SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;</span><br><span class=\"line\">/*!\\C utf8 *//*!*/;</span><br><span class=\"line\">SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=33/*!*/;</span><br><span class=\"line\">SET @@session.lc_time_names=0/*!*/;</span><br><span class=\"line\">SET @@session.collation_database=DEFAULT/*!*/;</span><br><span class=\"line\">/*!80011 SET @@session.default_collation_for_utf8mb4=255*//*!*/;</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">/*!*/;</span><br><span class=\"line\"><span class=\"comment\"># at 360</span></span><br><span class=\"line\"><span class=\"comment\">#201116  9:49:07 server id 2762931378  end_log_pos 412 CRC32 0xb6d1f3c1     Table_map: `mytest`.`t2` mapped to number 87</span></span><br><span class=\"line\"><span class=\"comment\"># at 412</span></span><br><span class=\"line\"><span class=\"comment\">#201116  9:49:07 server id 2762931378  end_log_pos 472 CRC32 0xb9c2d35e     Update_rows_v1: table id 87 flags: STMT_END_F</span></span><br><span class=\"line\"></span><br><span class=\"line\">BINLOG <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">k9qxXxOy/K6kNAAAAJwBAAAAAFcAAAAAAAEABm15dGVzdAACdDIAAwMDAwAGAQEAwfPRtg==</span></span><br><span class=\"line\"><span class=\"string\">k9qxXxiy/K6kPAAAANgBAAAAAFcAAAAAAAEAA///AAEAAAABAAAAAQAAAAABAAAAAQAAAAoAAABe</span></span><br><span class=\"line\"><span class=\"string\">08K5</span></span><br><span class=\"line\"><span class=\"string\">'</span>/*!*/;</span><br><span class=\"line\"><span class=\"comment\">### UPDATE `mytest`.`t2`</span></span><br><span class=\"line\"><span class=\"comment\">### WHERE</span></span><br><span class=\"line\"><span class=\"comment\">###   @1=1 /* INT meta=0 nullable=0 is_null=0 */</span></span><br><span class=\"line\"><span class=\"comment\">###   @2=1 /* INT meta=0 nullable=1 is_null=0 */</span></span><br><span class=\"line\"><span class=\"comment\">###   @3=1 /* INT meta=0 nullable=1 is_null=0 */</span></span><br><span class=\"line\"><span class=\"comment\">### SET</span></span><br><span class=\"line\"><span class=\"comment\">###   @1=1 /* INT meta=0 nullable=0 is_null=0 */</span></span><br><span class=\"line\"><span class=\"comment\">###   @2=1 /* INT meta=0 nullable=1 is_null=0 */</span></span><br><span class=\"line\"><span class=\"comment\">###   @3=10 /* INT meta=0 nullable=1 is_null=0 */</span></span><br><span class=\"line\"><span class=\"comment\"># at 472</span></span><br><span class=\"line\"><span class=\"comment\">#201116  9:49:07 server id 2762931378  end_log_pos 503 CRC32 0x027351e3     Xid = 14</span></span><br><span class=\"line\">COMMIT/*!*/;</span><br><span class=\"line\">SET @@SESSION.GTID_NEXT= <span class=\"string\">'AUTOMATIC'</span> /* added by mysqlbinlog */ /*!*/;</span><br><span class=\"line\">DELIMITER ;</span><br><span class=\"line\"><span class=\"comment\"># End of log file</span></span><br><span class=\"line\">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;</span><br><span class=\"line\">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"主备间如何进行同步\"><a href=\"#主备间如何进行同步\" class=\"headerlink\" title=\"主备间如何进行同步\"></a>主备间如何进行同步</h2><p>MySQL 通过 binlog 实现主备之间的同步，基本流程如下图：</p>\n<img src=\"/images/server-trx-4.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>简单来说，MySQL 内部通过三个独立的线程来保证主备之间的 binlog 同步：</p>\n<ol>\n<li>dump 线程（主）：在事务提交过程中，写完 binlog 后会去更新当前 binlog 的位置，dump 线程根据该位置，向备节点发送新的 binlog；</li>\n<li>io 线程（备）：备节点上的 io 线程接收到主节点发来的 binlog，保存到本地的 relaylog，并向主节点进行回复；</li>\n<li>ack 线程（主）：接收备节点返回的确认消息，确定事务是否可以提交（WAIT_AFTER_SYNC 模式下）；</li>\n</ol>\n<p>在实际的同步过程中，主要通过以下的参数控制主备间的同步效率：</p>\n<ul>\n<li>rpl_semi_sync_master_wait_point ：[WAIT_AFTER_COMMIT | WAIT_AFTER_SYNC] 同步等待的位点</li>\n<li>rpl_semi_sync_master_timeout ：同步等待超时时间</li>\n<li>sync_binlog ：binlog 刷盘策略</li>\n<li>sync_relay_log ：relay log 刷盘策略</li>\n</ul>\n<h2 id=\"GTID-的作用\"><a href=\"#GTID-的作用\" class=\"headerlink\" title=\"GTID 的作用\"></a>GTID 的作用</h2><p>前面已经提到了，MySQL 通过 binlog 来实现主备节点间的同步。在早期的版本中，进行同步前，需要在备节点上指定主节点的 binlog 位点信息，基本的语法如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CHANGE</span> <span class=\"keyword\">MASTER</span> <span class=\"keyword\">TO</span> master_host=<span class=\"string\">'127.0.0.1'</span>,</span><br><span class=\"line\">master_port=<span class=\"number\">3932</span>,</span><br><span class=\"line\">master_user=<span class=\"string\">'replicator'</span>,</span><br><span class=\"line\">master_password=<span class=\"string\">'123456'</span>,</span><br><span class=\"line\">master_log_file=<span class=\"string\">'mysql-binlog.000001'</span>,</span><br><span class=\"line\">master_log_pos=<span class=\"number\">155</span>;</span><br></pre></td></tr></table></figure>\n\n<p>备节点根据指定的位点信息从主节点进行同步。这种方式的主要问题是：当主备节点发生切换时，需要手动的修改 binlog 位点，运维比较麻烦，GTID 应运而生。关于 GTID 的入门，可以参考<a href=\"https://dbaplus.cn/news-11-857-1.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，本文尝试用比较简单的方式进行归纳。首先，GTID 作为全局事务 ID，有 source_id:transaction_id 组成，可以简单的理解为某个 MySQL 节点上的某个事务。在前面的例子中也可以看到，在每个事务（读写事务）执行时，binlog 都会记录一个类型为 gtid 的 event 用于指定接下来要执行的事务的 GTID。与此同时，MySQL 内部有一个专门的线程 clone_gtid_thread 负责将已经执行的 GTID 进行持久化，保存到 mysql 库下的 gtid_executed 表中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; srv_start_threads_after_ddl_recovery</span><br><span class=\"line\">|    |--&gt; gtid_persistor.start()</span><br><span class=\"line\">|    |    |--&gt; os_thread_create(clone_gtid_thread)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; clone_gtid_thread</span><br><span class=\"line\">|    |--&gt; persist_gtid-&gt;periodic_write</span><br><span class=\"line\">|    |    |--&gt; flush_gtids  <span class=\"comment\">// loop</span></span><br><span class=\"line\">|    |    |    |--&gt; gtid_table_persistor-&gt;fetch_gtids</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; write_to_table  <span class=\"comment\">// 持久化到 gtid_executed 表</span></span><br><span class=\"line\">|    |    |    |    |--&gt; gtid_table_persistor-&gt;save</span><br><span class=\"line\">|    |    |    |    |    |--&gt; write_row</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; trx_sys_oldest_trx_no</span><br><span class=\"line\">|    |    |    |--&gt; update_gtid_trx_no</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_sys_persist_gtid_num  <span class=\"comment\">// 持久化到 trx_sys page</span></span><br><span class=\"line\">|    |    |    |    |--&gt; srv_purge_wakeup</span><br></pre></td></tr></table></figure>\n\n<p>接下来，备节点在收到对应的 binlog 后，会分别统计已接收到的 gtid 集合和已执行的 gtid 集合。备节点与主节点进行同步时，也会将上述 gtid 的集合发送到主节点，主节点根据备节点上已有的 gtid 信息，确定还需要发送哪些 binlog 给备节点，不再需要手动的修改同步位点。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CHANGE</span> <span class=\"keyword\">MASTER</span> <span class=\"keyword\">TO</span> master_host=<span class=\"string\">'127.0.0.1'</span>,</span><br><span class=\"line\">master_port=<span class=\"number\">5932</span>,</span><br><span class=\"line\">master_user=<span class=\"string\">'replicator'</span>,</span><br><span class=\"line\">master_password=<span class=\"string\">'123456'</span>,</span><br><span class=\"line\">master_auto_position=<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>XA 与两阶段提交</p>\n<blockquote>\n<p><a href=\"http://mysql.taobao.org/monthly/2020/05/07/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2020/05/07/</a></p>\n</blockquote>\n<p>Binlog</p>\n<blockquote>\n<p><a href=\"http://mysql.taobao.org/monthly/2020/02/06/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2020/02/06/</a></p>\n</blockquote>\n<p>半同步复制</p>\n<blockquote>\n<p><a href=\"http://mysql.taobao.org/monthly/2017/04/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2017/04/01/</a></p>\n<p><a href=\"http://mysql.taobao.org/monthly/2016/08/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2016/08/01/</a></p>\n</blockquote>\n<p>GTID</p>\n<blockquote>\n<p><a href=\"https://dbaplus.cn/news-11-857-1.html\" target=\"_blank\" rel=\"noopener\">https://dbaplus.cn/news-11-857-1.html</a></p>\n<p><a href=\"https://keithlan.github.io/2016/06/23/gtid/\" target=\"_blank\" rel=\"noopener\">https://keithlan.github.io/2016/06/23/gtid/</a></p>\n<p><a href=\"http://mysql.taobao.org/monthly/2020/05/09/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2020/05/09/</a></p>\n<p><a href=\"https://www.cnblogs.com/MYSQLZOUQI/p/3850578.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/MYSQLZOUQI/p/3850578.html</a></p>\n</blockquote>\n<p>InnoDB 事务子系统</p>\n<blockquote>\n<p><a href=\"http://mysql.taobao.org/monthly/2015/12/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2015/12/01/</a></p>\n<p><a href=\"http://mysql.taobao.org/monthly/2017/12/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2017/12/01/</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>关于 MySQL 的事务提交过程，其实已经有很多文章进行过介绍，本文之所以还想再总结一遍是因为之前的文章都是从某一个或者某几个角度进行介绍，本文尝试从：binlog、gtid、semi-sync、undo、redo、trx等多个角度一起，将 MySQL 事务提交过程串联起来。</p>","more":"<h2 id=\"整体入门\"><a href=\"#整体入门\" class=\"headerlink\" title=\"整体入门\"></a>整体入门</h2><blockquote>\n<p>一条 SQL 的执行：<a href=\"https://time.geekbang.org/column/article/68633\" target=\"_blank\" rel=\"noopener\">https://time.geekbang.org/column/article/68633</a></p>\n<p>日志相关问题：<a href=\"https://time.geekbang.org/column/article/73161\" target=\"_blank\" rel=\"noopener\">https://time.geekbang.org/column/article/73161</a></p>\n<p>如何保证数据不丢：<a href=\"https://time.geekbang.org/column/article/76161\" target=\"_blank\" rel=\"noopener\">https://time.geekbang.org/column/article/76161</a></p>\n<p>如何保证主备一致：<a href=\"https://time.geekbang.org/column/article/76446\" target=\"_blank\" rel=\"noopener\">https://time.geekbang.org/column/article/76446</a></p>\n</blockquote>\n<p>上面的文章是丁奇《MySQL实战45讲》中的部分内容，作者深入浅出的对 MySQL 的基本原理进行了介绍，非常适合对于 MySQL 的整体入门，本文中使用的图片也全部来自上述文章。通过上面的文章，需要对下面的问题有一个基本的概念：</p>\n<ol>\n<li>事务提交的基本流程</li>\n<li>为什么需要两阶段提交协议</li>\n<li>Crash Safe 是如何保障的</li>\n<li>主备间如何进行同步</li>\n<li>GTID 的作用</li>\n</ol>\n<p>本文主要就上面几个问题分别进行展开说明。</p>\n<h2 id=\"事务提交的基本流程\"><a href=\"#事务提交的基本流程\" class=\"headerlink\" title=\"事务提交的基本流程\"></a>事务提交的基本流程</h2><p>以最简单的单行更新操作为例，数据的更新过程如下图：</p>\n<img src=\"/images/server-trx-1.png\"  width=\"380px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>如上图所示，一个简单的更新操作包含了一下几个部分：</p>\n<ol>\n<li>修改内存中的数据页。对于 InnoDB 来说，所有的内存页都是由 Buffer Pool 进行管理，修改数据页之前需要先记录 undo。undo 页和数据页的修改又都需要通过 redo 进行保护。</li>\n<li>提交修改。不管是 auto-commit 模式还是手动提交，提交过程都需要完成以下几件事情：</li>\n</ol>\n<ul>\n<li><ul>\n<li>将步骤 1 中生成的 redo 持久化（WAL）</li>\n<li>记录 binlog</li>\n<li>修改事务状态</li>\n</ul>\n</li>\n</ul>\n<p>从图中可以看到，MySQL 内部将事务提交的过程分成了 3 个部分：</p>\n<ol>\n<li>写 redo，修改事务状态为 prepared</li>\n<li>写 binlog</li>\n<li>修改事务状态为 commited</li>\n</ol>\n<p>关于提交过程，更详细的过程如下图：</p>\n<img src=\"/images/server-trx-2.png\"  width=\"380px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>前面提到过，undo 页和数据页在内存中的数据结构都是通过 Buffer Pool 进行管理的；但是 redo log 和 binlog 使用了操作系统的 page cache 机制，即，write 操作只写入到 page cache 中，sync 操作才会持久化到磁盘。通过上图可以看到，在真实的提交过程中，通过拆解 redo log prepare 的过程来提高写入的性能，这里面涉及到了组提交（group commit）的概念，详细的过程后续再做介绍。下面结合代码进行分析：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; ha_commit_trans</span><br><span class=\"line\">|    |--&gt; tc_log-&gt;<span class=\"built_in\">prepare</span>  <span class=\"comment\">// MYSQL_BIN_LOG::prepare</span></span><br><span class=\"line\">|    |    |--&gt; ha_prepare_low</span><br><span class=\"line\">|    |    |    |--&gt; innobase_xa_prepare</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; tc_log-&gt;commit  <span class=\"comment\">// MYSQL_BIN_LOG::commit</span></span><br><span class=\"line\">|    |    |--&gt; cache_mngr-&gt;trx_cache.finalize  <span class=\"comment\">// XID event</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; ordered_commit</span><br><span class=\"line\">|    |    |    |    <span class=\"comment\">// step 1</span></span><br><span class=\"line\">|    |    |    |--&gt; process_flush_stage_queue</span><br><span class=\"line\">|    |    |    |    |--&gt; assign_automatic_gtids_to_flush_group</span><br><span class=\"line\">|    |    |    |    |    |--&gt; generate_automatic_gtid</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; acquire_ownership</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; add_gtid_owner</span><br><span class=\"line\">|    |    |    |    |--&gt; flush_thread_caches</span><br><span class=\"line\">|    |    |    |    |    |..&gt; MYSQL_BIN_LOG::write_gtid  <span class=\"comment\">// GTID event</span></span><br><span class=\"line\">|    |    |    |    |    |..&gt; MYSQL_BIN_LOG::write_cache</span><br><span class=\"line\">|    |    |    |--&gt; flush_cache_to_file</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |    <span class=\"comment\">// step 2</span></span><br><span class=\"line\">|    |    |    |--&gt; sync_binlog_file</span><br><span class=\"line\">|    |    |    |--&gt; update_binlog_end_pos</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |    <span class=\"comment\">// step 3</span></span><br><span class=\"line\">|    |    |    |--&gt; call_after_sync_hook</span><br><span class=\"line\">|    |    |    |--&gt; process_commit_stage_queue</span><br><span class=\"line\">|    |    |    |    |--&gt; ha_commit_low</span><br><span class=\"line\">|    |    |    |    |    |--&gt; innobase_commit</span><br><span class=\"line\">|    |    |    |--&gt; process_after_commit_stage_queue</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; finish_commit</span><br><span class=\"line\">|    |    |    |    |--&gt; gtid_state-&gt;update_on_commit</span><br><span class=\"line\">|    |    |    |    |    |--&gt; update_gtids_impl</span><br></pre></td></tr></table></figure>\n\n<p>回到事务提交的过程，整个事务提交的过程中有以下参与方：</p>\n<ol>\n<li>binlog ：逻辑日志</li>\n<li>innodb ：存储引擎</li>\n<li>XA ：XA 事务</li>\n<li>GTID：全局事务 ID</li>\n</ol>\n<p>这些内容会在后面部分分别进行详细介绍。</p>\n<h2 id=\"为什么需要两阶段提交协议\"><a href=\"#为什么需要两阶段提交协议\" class=\"headerlink\" title=\"为什么需要两阶段提交协议\"></a>为什么需要两阶段提交协议</h2><p>为什么需要两阶段提交协议？这个问题相信很多阅读 MySQL 代码的同学都会问到。从结果上来说，两阶段提交协议保证了 binlog 和 innodb 数据的完整性。换个角度，如果没有两阶段提交协议，可能会出现什么结果？可能的情况无非下面两种：</p>\n<ol>\n<li>先写 binlog 成功，后写 redo 失败。</li>\n<li>先写 redo 成功，后写 binlog 失败。</li>\n</ol>\n<p>对于第一种情况，若本机的实例 crash 后重启，需要通过 redo 进行恢复，由于写 redo 的时候失败了，所以无法进行恢复；对于第二种情况，备库接收到的 binlog 不完整，导致主备不一致。同样，利用 binlog 进行恢复时也会造成数据不完整。</p>\n<p>然而，两阶段提交过程本身真的是必须的吗？前面讨论两阶段提交必要性的时候，一个前提条件是：binlog 和 redo 的完整性。binlog 日志是 server 层记录的逻辑日志，提供归档能力；redo 是 innodb 层的物理日志，提供 crash-safe 能力。这个限制也是 MySQL 设计之初带来的。如果抛开这个限制，两阶段提交是否还是必须的？当前比较流性的存储-计算分离型数据库，包括：Aurora、PolarDB 等都采用了物理复制的方案，直接通过 redo 进行主备的同步。</p>\n<h2 id=\"Crash-Safe-是如何保障的\"><a href=\"#Crash-Safe-是如何保障的\" class=\"headerlink\" title=\"Crash Safe 是如何保障的\"></a>Crash Safe 是如何保障的</h2><p>关于 crash-safe 的保障，再次引用一张图片进行说明：</p>\n<img src=\"/images/server-trx-3.png\"  width=\"380px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>图中标注了系统可能出现故障的点，下面分别进行分析：</p>\n<ol>\n<li>时刻 A 发生故障，此时事务状态还未修改完成，binlog 也未写入，恢复时对应的事务可以安全回滚；</li>\n<li>时刻 B 发生故障，恢复时需要结合 binlog 的状态进行判断：如果 binlog 里面的内容完整，那么事务可以正常提交；否则需要进行回滚。如何判断 binlog 的内容是否完整呢？这里需要借助前面提到的 XID，server 层在记录 binlog 时，会在事务提交阶段写入一个 XID event，里面包含了当前事务的 XID 信息。如果在重放 redo 的过程中（redo 中无 commit 记录），在 binlog 中能够找到对应的 XID event，则说明对应的 binlog 内容完整，事务可以提交。</li>\n</ol>\n<p>一个简单的例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MySQL [(none)]&gt; show master status;</span><br><span class=\"line\">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class=\"line\">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                         |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class=\"line\">| mysql-bin.000002 |      195 |              |                  | f778c1cc-24a9-11eb-9911-b8599f3009a8:1-15 |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class=\"line\">1 row <span class=\"keyword\">in</span> <span class=\"built_in\">set</span> (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">MySQL [mytest]&gt; update t2 <span class=\"built_in\">set</span> c2 = 10 <span class=\"built_in\">where</span> id = 1;</span><br><span class=\"line\">Query OK, 1 row affected (11.62 sec)</span><br><span class=\"line\">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class=\"line\"></span><br><span class=\"line\">MySQL [mytest]&gt; show binlog events <span class=\"keyword\">in</span> <span class=\"string\">'mysql-bin.000002'</span>;</span><br><span class=\"line\">+------------------+-----+----------------+------------+-------------+--------------------------------------------------------------------+</span><br><span class=\"line\">| Log_name         | Pos | Event_type     | Server_id  | End_log_pos | Info                                                               |</span><br><span class=\"line\">+------------------+-----+----------------+------------+-------------+--------------------------------------------------------------------+</span><br><span class=\"line\">| mysql-bin.000002 |   4 | Format_desc    | 2762931378 |         124 | Server ver: 8.0.18-rds-dev-debug, Binlog ver: 4                    |</span><br><span class=\"line\">| mysql-bin.000002 | 124 | Previous_gtids | 2762931378 |         195 | f778c1cc-24a9-11eb-9911-b8599f3009a8:1-15                          |</span><br><span class=\"line\">| mysql-bin.000002 | 195 | Gtid           | 2762931378 |         274 | SET @@SESSION.GTID_NEXT= <span class=\"string\">'f778c1cc-24a9-11eb-9911-b8599f3009a8:16'</span> |</span><br><span class=\"line\">| mysql-bin.000002 | 274 | Query          | 2762931378 |         360 | BEGIN                                                              |</span><br><span class=\"line\">| mysql-bin.000002 | 360 | Table_map      | 2762931378 |         412 | table_id: 87 (mytest.t2)                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 412 | Update_rows_v1 | 2762931378 |         472 | table_id: 87 flags: STMT_END_F                                     |</span><br><span class=\"line\">| mysql-bin.000002 | 472 | Xid            | 2762931378 |         503 | COMMIT /* xid=14 */                                                |</span><br><span class=\"line\">+------------------+-----+----------------+------------+-------------+--------------------------------------------------------------------+</span><br><span class=\"line\">7 rows <span class=\"keyword\">in</span> <span class=\"built_in\">set</span> (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">MySQL [mytest]&gt; show master status;</span><br><span class=\"line\">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class=\"line\">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                         |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class=\"line\">| mysql-bin.000002 |      503 |              |                  | f778c1cc-24a9-11eb-9911-b8599f3009a8:1-16 |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+-------------------------------------------+</span><br><span class=\"line\">1 row <span class=\"keyword\">in</span> <span class=\"built_in\">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>对应的 binlog 文件内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$/flash3/guoqing.mgq/lizard-2.0/bin/mysqlbinlog -vvv mysql-bin.000002</span><br><span class=\"line\">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;</span><br><span class=\"line\">/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;</span><br><span class=\"line\">DELIMITER /*!*/;</span><br><span class=\"line\"><span class=\"comment\"># at 4</span></span><br><span class=\"line\"><span class=\"comment\">#201116  9:45:22 server id 2762931378  end_log_pos 124 CRC32 0x8169654a     Start: binlog v 4, server v 8.0.18-rds-dev-debug created 201116  9:45:22 at startup</span></span><br><span class=\"line\"><span class=\"comment\"># Warning: this binlog is either in use or was not closed properly.</span></span><br><span class=\"line\">ROLLBACK/*!*/;</span><br><span class=\"line\">BINLOG <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">stmxXw+y/K6keAAAAHwAAAABAAQAOC4wLjE4LXJkcy1kZXYtZGVidWcAAAAAAAAAAAAAAAAAAAAA</span></span><br><span class=\"line\"><span class=\"string\">AAAAAAAAAAAAAAAAAACy2bFfEwANAAgAAAAABAAEAAAAYAAEGggAAAAICAgCAAAACgoKKioAEjQA</span></span><br><span class=\"line\"><span class=\"string\">CgFKZWmB</span></span><br><span class=\"line\"><span class=\"string\">'</span>/*!*/;</span><br><span class=\"line\"><span class=\"comment\"># at 124</span></span><br><span class=\"line\"><span class=\"comment\">#201116  9:45:22 server id 2762931378  end_log_pos 195 CRC32 0x2fdbb3d5     Previous-GTIDs</span></span><br><span class=\"line\"><span class=\"comment\"># f778c1cc-24a9-11eb-9911-b8599f3009a8:1-15</span></span><br><span class=\"line\"><span class=\"comment\"># at 195</span></span><br><span class=\"line\"><span class=\"comment\">#201116  9:49:07 server id 2762931378  end_log_pos 274 CRC32 0xd877c4e7     GTID    last_committed=0    sequence_number=1   rbr_only=yes    original_committed_timestamp=1605491358802675   immediate_commit_timestamp=1605491358802675 transaction_length=308</span></span><br><span class=\"line\">/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;</span><br><span class=\"line\"><span class=\"comment\"># original_commit_timestamp=1605491358802675 (2020-11-16 09:49:18.802675 CST)</span></span><br><span class=\"line\"><span class=\"comment\"># immediate_commit_timestamp=1605491358802675 (2020-11-16 09:49:18.802675 CST)</span></span><br><span class=\"line\">/*!80001 SET @@session.original_commit_timestamp=1605491358802675*//*!*/;</span><br><span class=\"line\">/*!80014 SET @@session.original_server_version=80018*//*!*/;</span><br><span class=\"line\">/*!80014 SET @@session.immediate_server_version=80018*//*!*/;</span><br><span class=\"line\">SET @@SESSION.GTID_NEXT= <span class=\"string\">'f778c1cc-24a9-11eb-9911-b8599f3009a8:16'</span>/*!*/;</span><br><span class=\"line\"><span class=\"comment\"># at 274</span></span><br><span class=\"line\"><span class=\"comment\">#201116  9:49:07 server id 2762931378  end_log_pos 360 CRC32 0x9d456972     Query   thread_id=8 exec_time=0 error_code=0</span></span><br><span class=\"line\">SET TIMESTAMP=1605491347/*!*/;</span><br><span class=\"line\">SET @@session.pseudo_thread_id=8/*!*/;</span><br><span class=\"line\">SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;</span><br><span class=\"line\">SET @@session.sql_mode=0/*!*/;</span><br><span class=\"line\">SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;</span><br><span class=\"line\">/*!\\C utf8 *//*!*/;</span><br><span class=\"line\">SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=33/*!*/;</span><br><span class=\"line\">SET @@session.lc_time_names=0/*!*/;</span><br><span class=\"line\">SET @@session.collation_database=DEFAULT/*!*/;</span><br><span class=\"line\">/*!80011 SET @@session.default_collation_for_utf8mb4=255*//*!*/;</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">/*!*/;</span><br><span class=\"line\"><span class=\"comment\"># at 360</span></span><br><span class=\"line\"><span class=\"comment\">#201116  9:49:07 server id 2762931378  end_log_pos 412 CRC32 0xb6d1f3c1     Table_map: `mytest`.`t2` mapped to number 87</span></span><br><span class=\"line\"><span class=\"comment\"># at 412</span></span><br><span class=\"line\"><span class=\"comment\">#201116  9:49:07 server id 2762931378  end_log_pos 472 CRC32 0xb9c2d35e     Update_rows_v1: table id 87 flags: STMT_END_F</span></span><br><span class=\"line\"></span><br><span class=\"line\">BINLOG <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">k9qxXxOy/K6kNAAAAJwBAAAAAFcAAAAAAAEABm15dGVzdAACdDIAAwMDAwAGAQEAwfPRtg==</span></span><br><span class=\"line\"><span class=\"string\">k9qxXxiy/K6kPAAAANgBAAAAAFcAAAAAAAEAA///AAEAAAABAAAAAQAAAAABAAAAAQAAAAoAAABe</span></span><br><span class=\"line\"><span class=\"string\">08K5</span></span><br><span class=\"line\"><span class=\"string\">'</span>/*!*/;</span><br><span class=\"line\"><span class=\"comment\">### UPDATE `mytest`.`t2`</span></span><br><span class=\"line\"><span class=\"comment\">### WHERE</span></span><br><span class=\"line\"><span class=\"comment\">###   @1=1 /* INT meta=0 nullable=0 is_null=0 */</span></span><br><span class=\"line\"><span class=\"comment\">###   @2=1 /* INT meta=0 nullable=1 is_null=0 */</span></span><br><span class=\"line\"><span class=\"comment\">###   @3=1 /* INT meta=0 nullable=1 is_null=0 */</span></span><br><span class=\"line\"><span class=\"comment\">### SET</span></span><br><span class=\"line\"><span class=\"comment\">###   @1=1 /* INT meta=0 nullable=0 is_null=0 */</span></span><br><span class=\"line\"><span class=\"comment\">###   @2=1 /* INT meta=0 nullable=1 is_null=0 */</span></span><br><span class=\"line\"><span class=\"comment\">###   @3=10 /* INT meta=0 nullable=1 is_null=0 */</span></span><br><span class=\"line\"><span class=\"comment\"># at 472</span></span><br><span class=\"line\"><span class=\"comment\">#201116  9:49:07 server id 2762931378  end_log_pos 503 CRC32 0x027351e3     Xid = 14</span></span><br><span class=\"line\">COMMIT/*!*/;</span><br><span class=\"line\">SET @@SESSION.GTID_NEXT= <span class=\"string\">'AUTOMATIC'</span> /* added by mysqlbinlog */ /*!*/;</span><br><span class=\"line\">DELIMITER ;</span><br><span class=\"line\"><span class=\"comment\"># End of log file</span></span><br><span class=\"line\">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;</span><br><span class=\"line\">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"主备间如何进行同步\"><a href=\"#主备间如何进行同步\" class=\"headerlink\" title=\"主备间如何进行同步\"></a>主备间如何进行同步</h2><p>MySQL 通过 binlog 实现主备之间的同步，基本流程如下图：</p>\n<img src=\"/images/server-trx-4.png\"  width=\"520px\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>简单来说，MySQL 内部通过三个独立的线程来保证主备之间的 binlog 同步：</p>\n<ol>\n<li>dump 线程（主）：在事务提交过程中，写完 binlog 后会去更新当前 binlog 的位置，dump 线程根据该位置，向备节点发送新的 binlog；</li>\n<li>io 线程（备）：备节点上的 io 线程接收到主节点发来的 binlog，保存到本地的 relaylog，并向主节点进行回复；</li>\n<li>ack 线程（主）：接收备节点返回的确认消息，确定事务是否可以提交（WAIT_AFTER_SYNC 模式下）；</li>\n</ol>\n<p>在实际的同步过程中，主要通过以下的参数控制主备间的同步效率：</p>\n<ul>\n<li>rpl_semi_sync_master_wait_point ：[WAIT_AFTER_COMMIT | WAIT_AFTER_SYNC] 同步等待的位点</li>\n<li>rpl_semi_sync_master_timeout ：同步等待超时时间</li>\n<li>sync_binlog ：binlog 刷盘策略</li>\n<li>sync_relay_log ：relay log 刷盘策略</li>\n</ul>\n<h2 id=\"GTID-的作用\"><a href=\"#GTID-的作用\" class=\"headerlink\" title=\"GTID 的作用\"></a>GTID 的作用</h2><p>前面已经提到了，MySQL 通过 binlog 来实现主备节点间的同步。在早期的版本中，进行同步前，需要在备节点上指定主节点的 binlog 位点信息，基本的语法如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CHANGE</span> <span class=\"keyword\">MASTER</span> <span class=\"keyword\">TO</span> master_host=<span class=\"string\">'127.0.0.1'</span>,</span><br><span class=\"line\">master_port=<span class=\"number\">3932</span>,</span><br><span class=\"line\">master_user=<span class=\"string\">'replicator'</span>,</span><br><span class=\"line\">master_password=<span class=\"string\">'123456'</span>,</span><br><span class=\"line\">master_log_file=<span class=\"string\">'mysql-binlog.000001'</span>,</span><br><span class=\"line\">master_log_pos=<span class=\"number\">155</span>;</span><br></pre></td></tr></table></figure>\n\n<p>备节点根据指定的位点信息从主节点进行同步。这种方式的主要问题是：当主备节点发生切换时，需要手动的修改 binlog 位点，运维比较麻烦，GTID 应运而生。关于 GTID 的入门，可以参考<a href=\"https://dbaplus.cn/news-11-857-1.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，本文尝试用比较简单的方式进行归纳。首先，GTID 作为全局事务 ID，有 source_id:transaction_id 组成，可以简单的理解为某个 MySQL 节点上的某个事务。在前面的例子中也可以看到，在每个事务（读写事务）执行时，binlog 都会记录一个类型为 gtid 的 event 用于指定接下来要执行的事务的 GTID。与此同时，MySQL 内部有一个专门的线程 clone_gtid_thread 负责将已经执行的 GTID 进行持久化，保存到 mysql 库下的 gtid_executed 表中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; srv_start_threads_after_ddl_recovery</span><br><span class=\"line\">|    |--&gt; gtid_persistor.start()</span><br><span class=\"line\">|    |    |--&gt; os_thread_create(clone_gtid_thread)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; clone_gtid_thread</span><br><span class=\"line\">|    |--&gt; persist_gtid-&gt;periodic_write</span><br><span class=\"line\">|    |    |--&gt; flush_gtids  <span class=\"comment\">// loop</span></span><br><span class=\"line\">|    |    |    |--&gt; gtid_table_persistor-&gt;fetch_gtids</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; write_to_table  <span class=\"comment\">// 持久化到 gtid_executed 表</span></span><br><span class=\"line\">|    |    |    |    |--&gt; gtid_table_persistor-&gt;save</span><br><span class=\"line\">|    |    |    |    |    |--&gt; write_row</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; trx_sys_oldest_trx_no</span><br><span class=\"line\">|    |    |    |--&gt; update_gtid_trx_no</span><br><span class=\"line\">|    |    |    |    |--&gt; trx_sys_persist_gtid_num  <span class=\"comment\">// 持久化到 trx_sys page</span></span><br><span class=\"line\">|    |    |    |    |--&gt; srv_purge_wakeup</span><br></pre></td></tr></table></figure>\n\n<p>接下来，备节点在收到对应的 binlog 后，会分别统计已接收到的 gtid 集合和已执行的 gtid 集合。备节点与主节点进行同步时，也会将上述 gtid 的集合发送到主节点，主节点根据备节点上已有的 gtid 信息，确定还需要发送哪些 binlog 给备节点，不再需要手动的修改同步位点。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CHANGE</span> <span class=\"keyword\">MASTER</span> <span class=\"keyword\">TO</span> master_host=<span class=\"string\">'127.0.0.1'</span>,</span><br><span class=\"line\">master_port=<span class=\"number\">5932</span>,</span><br><span class=\"line\">master_user=<span class=\"string\">'replicator'</span>,</span><br><span class=\"line\">master_password=<span class=\"string\">'123456'</span>,</span><br><span class=\"line\">master_auto_position=<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>XA 与两阶段提交</p>\n<blockquote>\n<p><a href=\"http://mysql.taobao.org/monthly/2020/05/07/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2020/05/07/</a></p>\n</blockquote>\n<p>Binlog</p>\n<blockquote>\n<p><a href=\"http://mysql.taobao.org/monthly/2020/02/06/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2020/02/06/</a></p>\n</blockquote>\n<p>半同步复制</p>\n<blockquote>\n<p><a href=\"http://mysql.taobao.org/monthly/2017/04/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2017/04/01/</a></p>\n<p><a href=\"http://mysql.taobao.org/monthly/2016/08/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2016/08/01/</a></p>\n</blockquote>\n<p>GTID</p>\n<blockquote>\n<p><a href=\"https://dbaplus.cn/news-11-857-1.html\" target=\"_blank\" rel=\"noopener\">https://dbaplus.cn/news-11-857-1.html</a></p>\n<p><a href=\"https://keithlan.github.io/2016/06/23/gtid/\" target=\"_blank\" rel=\"noopener\">https://keithlan.github.io/2016/06/23/gtid/</a></p>\n<p><a href=\"http://mysql.taobao.org/monthly/2020/05/09/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2020/05/09/</a></p>\n<p><a href=\"https://www.cnblogs.com/MYSQLZOUQI/p/3850578.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/MYSQLZOUQI/p/3850578.html</a></p>\n</blockquote>\n<p>InnoDB 事务子系统</p>\n<blockquote>\n<p><a href=\"http://mysql.taobao.org/monthly/2015/12/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2015/12/01/</a></p>\n<p><a href=\"http://mysql.taobao.org/monthly/2017/12/01/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2017/12/01/</a></p>\n</blockquote>"},{"title":"MySQL 中的 TABLE 对象","date":"2020-12-05T12:07:49.000Z","_content":"\nMySQL 中的 TABLE 是最核心的数据结构之一，包含的类包括：TABLE、TABLE_LIST、TABLE_SHARE 等，下面结合 MySQL 的代码进行分析说明。\n\n<!-- more -->\n\n## 基本说明\n\n- TABLE_LIST：词法&语法分析后生成的对象，常见的生成方式为 add_table_to_list\n- TABLE_SHARE：server 层表定义缓存，一个 table 实例对应一个 TABLES_SHARE 对象，可以将TABLE_SHRAE 对象看成是表的物理文件（frm）在内存中的映射\n- TABLE：每一个查询 sql 中的表建一个 TABLE 对象\n\n<img src=\"/images/table-object-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\nTABLE_LIST 只是一个表的描述信息，包括各种名称、锁类型等；\n\nTABLE_SHARE 可以看作是完整的表定义信息，在 8.0 以前的版本中需要通过读取 frm 文件获取，8.0 版本中引入了 DD，可以直接通过 DD 获取到表定义信息。Server 层有一个全局的 Table_definition_cache 缓存对象，保存已经打开的 TABLE_SHARE 对象；\n\nTABLE 对象为查询最后使用的 TABLE 信息，该对象上关联了引擎层的 hander，所有的引擎层的操作都需要通过此 hander 进行。Server 层同样有一个全局的 Table_cache_manager，然而 TABLE 的缓存和 TABLE_SHARE 的缓存不同，由于每个 THD 上的 TABLE 对象都不相同，所有同一个表会在 Table_cache_manager 保存多份。\n\n关于 Table_cache_manager，有两个参数进行控制：\n\n```sql\nMySQL [none]> show variables like \"%table_open%\";\n+----------------------------+-------+\n| Variable_name              | Value |\n+----------------------------+-------+\n| table_open_cache           | 500   |\n| table_open_cache_instances | 16    |\n+----------------------------+-------+\n2 rows in set (0.01 sec)\n```\n\n其中：\n\n- table_open_cache_instances 表示将 Table_cache_manager 分为多少个部分；\n- table_open_cache 表示 TABLE 对象的阈值，超过此值后会开始进行无用对象的回收；\n\n## MySQL 8.0\n\n```c++\n|--> open_tables\n|    |--> open_and_process_table\n|    |    |--> open_table  // 打开表\n|    |    |    |--> thd->mdl_context.acquire_lock  // 获取 MDL 锁\n|    |    |    |--> open_table_get_mdl_lock\n|    |    |    |    |--> thd->mdl_context.acquire_lock\n|    |    |    |\n|    |    |    |--> check_if_table_exists\n|    |    |    |    |--> dd::table_exists\n|    |    |    |    |    |--> client->acquire // dd::Abstract_table\n|    |    |    |\n|    |    |    |--> tc->get_table  //  从 Table_cache_manager 查找\n|    |    |    |\n|    |    |    |--> get_table_share_with_discover  // 构建 TABLE_SHARE\n|    |    |    |    |--> get_table_share\n|    |    |    |    |    |--> table_def_cache->find  // 从 Table_definition_cache 查找\n|    |    |    |    |    |--> process_found_table_share\n|    |    |    |    |    |\n|    |    |    |    |    |--> alloc_table_share\n|    |    |    |    |    |--> table_def_cache->emplace  // 维护 Table_definition_cache\n|    |    |    |    |    |\n|    |    |    |    |    |--> thd->dd_client()->acquire\n|    |    |    |    |    |--> open_table_def\n|    |    |    |\n|    |    |    |--> open_table_from_share  // 通过 TABLE_SHARE 打开 TABLE\n|    |    |    |    |--> ha_open\n|    |    |    |    |    |--> ha_innobase::open // 打开一个 innodb 表\n|    |    |    |    |    |    |--> lookup_table_handler\n|    |    |    |    |    |    |--> dict_table_check_if_in_cache_low\n|    |    |    |    |    |    |--> dd_open_table\n|    |    |    |    |    |    |    |--> dd_open_table_one\n|    |    |    |    |    |    |\n|    |    |    |    |    |    |--> row_create_prebuilt\n|    |    |    |    |    |    |--> info(...)\n|    |    |    |    |    |    |    |--> info_low\n|    |    |    |    |    |    |    |    |--> update_thd\n|    |    |    |    |    |    |    |    |    |--> row_update_prebuilt_trx\n|    |    |    |\n|    |    |    |--> tc->add_used_table  // 添加到 Table_cache_manager\n|    |    |    |\n|    |    |    |--> thd->set_open_tables\n|    |    |    |--> table->init\n\n\n\n|--> close_thread_tables\n|    |--> mysql_unlock_tables\n|    |    |--> unlock_external\n|    |    |    |--> ha_external_lock\n|    |    |    |    |--> ha_innobase::external_lock\n|    |\n|    |--> close_open_tables\n|    |    |--> close_thread_table\n|    |    |    |--> release_or_close_table\n|    |    |    |    |--> intern_close_table\n|    |    |    |    |--> tc->remove_table\n|    |    |    |    |\n|    |    |    |    |--> tc->release_table\n```\n\n## MySQL 5.7\n\n### 表打开过程\n\n```c++\nbool open_table(THD *thd, TABLE_LIST *table_list, Open_table_context *ot_ctx)\n    |\n    |\n    |--> TABLE* Table_cache::get_table(THD *thd, my_hash_value_type hash_value,\n    |                                  const char *key, size_t key_length,\n    |                                  TABLE_SHARE **share)\n    |\n    |\n    |--> TABLE_SHARE *\n    |    get_table_share_with_discover(THD *thd, TABLE_LIST *table_list,\n    |                                  const char *key, size_t key_length,\n    |                                  uint db_flags, int *error,\n    |                                  my_hash_value_type hash_value)\n    |        |\n    |        |\n    |        |--> TABLE_SHARE *get_table_share(THD *thd, TABLE_LIST *table_list,\n    |        |                                 const char *key, size_t key_length,\n    |        |                                 uint db_flags, int *error,\n    |        |                                 my_hash_value_type hash_value)\n    |        |        |\n    |        |        |\n    |        |        |--> uchar* my_hash_search_using_hash_value(const HASH *hash, \n    |        |        |                                            my_hash_value_type hash_value,\n    |        |        |                                            const uchar *key,\n    |        |        |                                            size_t length)\n    |        |        |\n    |        |        |\n    |        |        |--> int open_table_def(THD *thd, TABLE_SHARE *share, uint db_flags)\n    |        |        |        |\n    |        |        |        |\n    |        |        |        |--> static int open_binary_frm(THD *thd, TABLE_SHARE *share, uchar *head,\n    |        |        |        |                               File file)\n    |        |        |        |        |\n    |        |        |        |        |\n    |        |        |        |        |--> handler *get_new_handler(TABLE_SHARE *share, MEM_ROOT *alloc,\n    |        |        |        |        |                             handlerton *db_type)\n    |\n    |\n    |--> int open_table_from_share(THD *thd, TABLE_SHARE *share, const char *alias,\n    |                              uint db_stat, uint prgflag, uint ha_open_flags,\n    |                              TABLE *outparam, bool is_create_table)\n    |        |\n    |        |\n    |        |--> handler *get_new_handler(TABLE_SHARE *share, MEM_ROOT *alloc,\n    |        |                             handlerton *db_type)\n    |        |\n    |        |\n    |        |--> int handler::ha_open(TABLE *table_arg, const char *name, int mode,\n                                       int test_if_locked)\n    \n```\n\n### 表创建过程\n\n```c++\nTABLE_LIST *\nst_select_lex::add_table_to_list(THD *thd,\n                                 Table_ident *table,\n                                 LEX_STRING *alias,\n                                 ulong table_options,\n                                 thr_lock_type lock_type,\n                                 enum_mdl_type mdl_type,\n                                 List<Index_hint> *index_hints_arg,\n                                 List<String> *partition_names,\n                                 LEX_STRING *option,\n                                 Sequence_scan_mode seq_scan_mode)\n\n\nbool mysql_create_table(THD *thd, TABLE_LIST *create_table,\n                        HA_CREATE_INFO *create_info,\n                        Alter_info *alter_info)\n    |\n    |\n    |--> bool mysql_create_table_no_lock(THD *thd,\n    |                                   const char *db, const char *table_name,\n    |                                   HA_CREATE_INFO *create_info,\n    |                                   Alter_info *alter_info,\n    |                                   uint select_field_count,\n    |                                   bool *is_trans)\n    |        |\n    |        |\n    |        |--> static\n    |        |    bool create_table_impl(THD *thd,\n    |        |                           const char *db, const char *table_name,\n    |        |                           const char *error_table_name,\n    |        |                           const char *path,\n    |        |                           HA_CREATE_INFO *create_info,\n    |        |                           Alter_info *alter_info,\n    |        |                           bool internal_tmp_table,\n    |        |                           uint select_field_count,\n    |        |                           bool no_ha_table,\n    |        |                           bool *is_trans,\n    |        |                           KEY **key_info,\n    |        |                           uint *key_count)\n    |        |        |\n    |        |        |\n    |        |        |--> int rea_create_table(THD *thd, const char *path,\n    |        |        |                         const char *db, const char *table_name,\n    |        |        |                         HA_CREATE_INFO *create_info,\n    |        |        |                         List<Create_field> &create_fields,\n    |        |        |                         uint keys, KEY *key_info, handler *file,\n    |        |        |                         bool no_ha_table)\n    \n```\n\n\n\n```c++\n/* create table 过程 */\n\n|--> mysql_create_table\n|    |--> open_tables\n|    |    |--> open_and_process_table\n|    |    |    |--> open_table\n|    |    |    |    |--> check_if_table_exists\n|    |\n|    |--> mysql_create_table_no_lock\n|    |    |--> create_table_impl\n|    |    |    |--> mysql_prepare_create_table\n|    |    |    |\n|    |    |    |--> rea_create_table\n|    |    |    |    |--> mysql_create_frm // 创建 frm 文件\n|    |    |    |    |\n|    |    |    |    |--> ha_create_table\n|    |    |    |    |    |--> open_table_def\n|    |    |    |    |    |    |--> mysql_file_open\n|    |    |    |    |    |    |--> open_binary_frm\n|    |    |    |    |    |    |--> mysql_file_close\n|    |    |    |    |    |\n|    |    |    |    |    |--> open_table_from_share\n|    |    |    |    |    |\n|    |    |    |    |    |--> table.file->ha_create\n\n\n\n|--> ha_innobase::create\n|    |--> info.prepare_create_table\n|    |--> row_mysql_lock_data_dictionary\n|    |\n|    |--> info.create_table\n|    |    |--> create_table_def\n|    |    |    |--> dict_mem_table_create\n|    |    |    |--> row_create_table_for_mysql\n|    |    |    |    |--> dict_build_table_def_step\n|    |    |    |    |    |--> dict_build_tablespace_for_table\n|    |    |    |    |    |    |--> fil_ibd_create // 创建 ibd 文件\n|    |    |    |    |    |--> dict_create_sys_tables_tuple\n|    |    |    |    |    |--> ins_node_set_new_row // 插入系统表\n|    |    |\n|    |    |--> create_index\n|    |\n|    |--> row_mysql_unlock_data_dictionary\n```\n\n## 参考文献\n\n> http://mysql.taobao.org/monthly/2015/08/10/\n>\n> http://liuyangming.tech/10-2019/information_schema-exploration.html\n>\n> https://www.cnblogs.com/xpchild/p/3780625.html","source":"_posts/mysql/table-object.md","raw":"---\ntitle: MySQL 中的 TABLE 对象\ndate: 2020-12-05 20:07:49\ncategories: \n- MySQL\n\n---\n\nMySQL 中的 TABLE 是最核心的数据结构之一，包含的类包括：TABLE、TABLE_LIST、TABLE_SHARE 等，下面结合 MySQL 的代码进行分析说明。\n\n<!-- more -->\n\n## 基本说明\n\n- TABLE_LIST：词法&语法分析后生成的对象，常见的生成方式为 add_table_to_list\n- TABLE_SHARE：server 层表定义缓存，一个 table 实例对应一个 TABLES_SHARE 对象，可以将TABLE_SHRAE 对象看成是表的物理文件（frm）在内存中的映射\n- TABLE：每一个查询 sql 中的表建一个 TABLE 对象\n\n<img src=\"/images/table-object-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\nTABLE_LIST 只是一个表的描述信息，包括各种名称、锁类型等；\n\nTABLE_SHARE 可以看作是完整的表定义信息，在 8.0 以前的版本中需要通过读取 frm 文件获取，8.0 版本中引入了 DD，可以直接通过 DD 获取到表定义信息。Server 层有一个全局的 Table_definition_cache 缓存对象，保存已经打开的 TABLE_SHARE 对象；\n\nTABLE 对象为查询最后使用的 TABLE 信息，该对象上关联了引擎层的 hander，所有的引擎层的操作都需要通过此 hander 进行。Server 层同样有一个全局的 Table_cache_manager，然而 TABLE 的缓存和 TABLE_SHARE 的缓存不同，由于每个 THD 上的 TABLE 对象都不相同，所有同一个表会在 Table_cache_manager 保存多份。\n\n关于 Table_cache_manager，有两个参数进行控制：\n\n```sql\nMySQL [none]> show variables like \"%table_open%\";\n+----------------------------+-------+\n| Variable_name              | Value |\n+----------------------------+-------+\n| table_open_cache           | 500   |\n| table_open_cache_instances | 16    |\n+----------------------------+-------+\n2 rows in set (0.01 sec)\n```\n\n其中：\n\n- table_open_cache_instances 表示将 Table_cache_manager 分为多少个部分；\n- table_open_cache 表示 TABLE 对象的阈值，超过此值后会开始进行无用对象的回收；\n\n## MySQL 8.0\n\n```c++\n|--> open_tables\n|    |--> open_and_process_table\n|    |    |--> open_table  // 打开表\n|    |    |    |--> thd->mdl_context.acquire_lock  // 获取 MDL 锁\n|    |    |    |--> open_table_get_mdl_lock\n|    |    |    |    |--> thd->mdl_context.acquire_lock\n|    |    |    |\n|    |    |    |--> check_if_table_exists\n|    |    |    |    |--> dd::table_exists\n|    |    |    |    |    |--> client->acquire // dd::Abstract_table\n|    |    |    |\n|    |    |    |--> tc->get_table  //  从 Table_cache_manager 查找\n|    |    |    |\n|    |    |    |--> get_table_share_with_discover  // 构建 TABLE_SHARE\n|    |    |    |    |--> get_table_share\n|    |    |    |    |    |--> table_def_cache->find  // 从 Table_definition_cache 查找\n|    |    |    |    |    |--> process_found_table_share\n|    |    |    |    |    |\n|    |    |    |    |    |--> alloc_table_share\n|    |    |    |    |    |--> table_def_cache->emplace  // 维护 Table_definition_cache\n|    |    |    |    |    |\n|    |    |    |    |    |--> thd->dd_client()->acquire\n|    |    |    |    |    |--> open_table_def\n|    |    |    |\n|    |    |    |--> open_table_from_share  // 通过 TABLE_SHARE 打开 TABLE\n|    |    |    |    |--> ha_open\n|    |    |    |    |    |--> ha_innobase::open // 打开一个 innodb 表\n|    |    |    |    |    |    |--> lookup_table_handler\n|    |    |    |    |    |    |--> dict_table_check_if_in_cache_low\n|    |    |    |    |    |    |--> dd_open_table\n|    |    |    |    |    |    |    |--> dd_open_table_one\n|    |    |    |    |    |    |\n|    |    |    |    |    |    |--> row_create_prebuilt\n|    |    |    |    |    |    |--> info(...)\n|    |    |    |    |    |    |    |--> info_low\n|    |    |    |    |    |    |    |    |--> update_thd\n|    |    |    |    |    |    |    |    |    |--> row_update_prebuilt_trx\n|    |    |    |\n|    |    |    |--> tc->add_used_table  // 添加到 Table_cache_manager\n|    |    |    |\n|    |    |    |--> thd->set_open_tables\n|    |    |    |--> table->init\n\n\n\n|--> close_thread_tables\n|    |--> mysql_unlock_tables\n|    |    |--> unlock_external\n|    |    |    |--> ha_external_lock\n|    |    |    |    |--> ha_innobase::external_lock\n|    |\n|    |--> close_open_tables\n|    |    |--> close_thread_table\n|    |    |    |--> release_or_close_table\n|    |    |    |    |--> intern_close_table\n|    |    |    |    |--> tc->remove_table\n|    |    |    |    |\n|    |    |    |    |--> tc->release_table\n```\n\n## MySQL 5.7\n\n### 表打开过程\n\n```c++\nbool open_table(THD *thd, TABLE_LIST *table_list, Open_table_context *ot_ctx)\n    |\n    |\n    |--> TABLE* Table_cache::get_table(THD *thd, my_hash_value_type hash_value,\n    |                                  const char *key, size_t key_length,\n    |                                  TABLE_SHARE **share)\n    |\n    |\n    |--> TABLE_SHARE *\n    |    get_table_share_with_discover(THD *thd, TABLE_LIST *table_list,\n    |                                  const char *key, size_t key_length,\n    |                                  uint db_flags, int *error,\n    |                                  my_hash_value_type hash_value)\n    |        |\n    |        |\n    |        |--> TABLE_SHARE *get_table_share(THD *thd, TABLE_LIST *table_list,\n    |        |                                 const char *key, size_t key_length,\n    |        |                                 uint db_flags, int *error,\n    |        |                                 my_hash_value_type hash_value)\n    |        |        |\n    |        |        |\n    |        |        |--> uchar* my_hash_search_using_hash_value(const HASH *hash, \n    |        |        |                                            my_hash_value_type hash_value,\n    |        |        |                                            const uchar *key,\n    |        |        |                                            size_t length)\n    |        |        |\n    |        |        |\n    |        |        |--> int open_table_def(THD *thd, TABLE_SHARE *share, uint db_flags)\n    |        |        |        |\n    |        |        |        |\n    |        |        |        |--> static int open_binary_frm(THD *thd, TABLE_SHARE *share, uchar *head,\n    |        |        |        |                               File file)\n    |        |        |        |        |\n    |        |        |        |        |\n    |        |        |        |        |--> handler *get_new_handler(TABLE_SHARE *share, MEM_ROOT *alloc,\n    |        |        |        |        |                             handlerton *db_type)\n    |\n    |\n    |--> int open_table_from_share(THD *thd, TABLE_SHARE *share, const char *alias,\n    |                              uint db_stat, uint prgflag, uint ha_open_flags,\n    |                              TABLE *outparam, bool is_create_table)\n    |        |\n    |        |\n    |        |--> handler *get_new_handler(TABLE_SHARE *share, MEM_ROOT *alloc,\n    |        |                             handlerton *db_type)\n    |        |\n    |        |\n    |        |--> int handler::ha_open(TABLE *table_arg, const char *name, int mode,\n                                       int test_if_locked)\n    \n```\n\n### 表创建过程\n\n```c++\nTABLE_LIST *\nst_select_lex::add_table_to_list(THD *thd,\n                                 Table_ident *table,\n                                 LEX_STRING *alias,\n                                 ulong table_options,\n                                 thr_lock_type lock_type,\n                                 enum_mdl_type mdl_type,\n                                 List<Index_hint> *index_hints_arg,\n                                 List<String> *partition_names,\n                                 LEX_STRING *option,\n                                 Sequence_scan_mode seq_scan_mode)\n\n\nbool mysql_create_table(THD *thd, TABLE_LIST *create_table,\n                        HA_CREATE_INFO *create_info,\n                        Alter_info *alter_info)\n    |\n    |\n    |--> bool mysql_create_table_no_lock(THD *thd,\n    |                                   const char *db, const char *table_name,\n    |                                   HA_CREATE_INFO *create_info,\n    |                                   Alter_info *alter_info,\n    |                                   uint select_field_count,\n    |                                   bool *is_trans)\n    |        |\n    |        |\n    |        |--> static\n    |        |    bool create_table_impl(THD *thd,\n    |        |                           const char *db, const char *table_name,\n    |        |                           const char *error_table_name,\n    |        |                           const char *path,\n    |        |                           HA_CREATE_INFO *create_info,\n    |        |                           Alter_info *alter_info,\n    |        |                           bool internal_tmp_table,\n    |        |                           uint select_field_count,\n    |        |                           bool no_ha_table,\n    |        |                           bool *is_trans,\n    |        |                           KEY **key_info,\n    |        |                           uint *key_count)\n    |        |        |\n    |        |        |\n    |        |        |--> int rea_create_table(THD *thd, const char *path,\n    |        |        |                         const char *db, const char *table_name,\n    |        |        |                         HA_CREATE_INFO *create_info,\n    |        |        |                         List<Create_field> &create_fields,\n    |        |        |                         uint keys, KEY *key_info, handler *file,\n    |        |        |                         bool no_ha_table)\n    \n```\n\n\n\n```c++\n/* create table 过程 */\n\n|--> mysql_create_table\n|    |--> open_tables\n|    |    |--> open_and_process_table\n|    |    |    |--> open_table\n|    |    |    |    |--> check_if_table_exists\n|    |\n|    |--> mysql_create_table_no_lock\n|    |    |--> create_table_impl\n|    |    |    |--> mysql_prepare_create_table\n|    |    |    |\n|    |    |    |--> rea_create_table\n|    |    |    |    |--> mysql_create_frm // 创建 frm 文件\n|    |    |    |    |\n|    |    |    |    |--> ha_create_table\n|    |    |    |    |    |--> open_table_def\n|    |    |    |    |    |    |--> mysql_file_open\n|    |    |    |    |    |    |--> open_binary_frm\n|    |    |    |    |    |    |--> mysql_file_close\n|    |    |    |    |    |\n|    |    |    |    |    |--> open_table_from_share\n|    |    |    |    |    |\n|    |    |    |    |    |--> table.file->ha_create\n\n\n\n|--> ha_innobase::create\n|    |--> info.prepare_create_table\n|    |--> row_mysql_lock_data_dictionary\n|    |\n|    |--> info.create_table\n|    |    |--> create_table_def\n|    |    |    |--> dict_mem_table_create\n|    |    |    |--> row_create_table_for_mysql\n|    |    |    |    |--> dict_build_table_def_step\n|    |    |    |    |    |--> dict_build_tablespace_for_table\n|    |    |    |    |    |    |--> fil_ibd_create // 创建 ibd 文件\n|    |    |    |    |    |--> dict_create_sys_tables_tuple\n|    |    |    |    |    |--> ins_node_set_new_row // 插入系统表\n|    |    |\n|    |    |--> create_index\n|    |\n|    |--> row_mysql_unlock_data_dictionary\n```\n\n## 参考文献\n\n> http://mysql.taobao.org/monthly/2015/08/10/\n>\n> http://liuyangming.tech/10-2019/information_schema-exploration.html\n>\n> https://www.cnblogs.com/xpchild/p/3780625.html","slug":"mysql/table-object","published":1,"updated":"2020-12-05T12:45:02.274Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojpj4yg002kgugmd3hc2dlw","content":"<p>MySQL 中的 TABLE 是最核心的数据结构之一，包含的类包括：TABLE、TABLE_LIST、TABLE_SHARE 等，下面结合 MySQL 的代码进行分析说明。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"基本说明\"><a href=\"#基本说明\" class=\"headerlink\" title=\"基本说明\"></a>基本说明</h2><ul>\n<li>TABLE_LIST：词法&amp;语法分析后生成的对象，常见的生成方式为 add_table_to_list</li>\n<li>TABLE_SHARE：server 层表定义缓存，一个 table 实例对应一个 TABLES_SHARE 对象，可以将TABLE_SHRAE 对象看成是表的物理文件（frm）在内存中的映射</li>\n<li>TABLE：每一个查询 sql 中的表建一个 TABLE 对象</li>\n</ul>\n<img src=\"/images/table-object-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>TABLE_LIST 只是一个表的描述信息，包括各种名称、锁类型等；</p>\n<p>TABLE_SHARE 可以看作是完整的表定义信息，在 8.0 以前的版本中需要通过读取 frm 文件获取，8.0 版本中引入了 DD，可以直接通过 DD 获取到表定义信息。Server 层有一个全局的 Table_definition_cache 缓存对象，保存已经打开的 TABLE_SHARE 对象；</p>\n<p>TABLE 对象为查询最后使用的 TABLE 信息，该对象上关联了引擎层的 hander，所有的引擎层的操作都需要通过此 hander 进行。Server 层同样有一个全局的 Table_cache_manager，然而 TABLE 的缓存和 TABLE_SHARE 的缓存不同，由于每个 THD 上的 TABLE 对象都不相同，所有同一个表会在 Table_cache_manager 保存多份。</p>\n<p>关于 Table_cache_manager，有两个参数进行控制：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MySQL [none]&gt; show variables like \"%table_open%\";</span><br><span class=\"line\">+<span class=\"comment\">----------------------------+-------+</span></span><br><span class=\"line\">| Variable_name              | Value |</span><br><span class=\"line\">+<span class=\"comment\">----------------------------+-------+</span></span><br><span class=\"line\">| table_open_cache           | 500   |</span><br><span class=\"line\">| table_open_cache_instances | 16    |</span><br><span class=\"line\">+<span class=\"comment\">----------------------------+-------+</span></span><br><span class=\"line\">2 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<ul>\n<li>table_open_cache_instances 表示将 Table_cache_manager 分为多少个部分；</li>\n<li>table_open_cache 表示 TABLE 对象的阈值，超过此值后会开始进行无用对象的回收；</li>\n</ul>\n<h2 id=\"MySQL-8-0\"><a href=\"#MySQL-8-0\" class=\"headerlink\" title=\"MySQL 8.0\"></a>MySQL 8.0</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; open_tables</span><br><span class=\"line\">|    |--&gt; open_and_process_table</span><br><span class=\"line\">|    |    |--&gt; open_table  <span class=\"comment\">// 打开表</span></span><br><span class=\"line\">|    |    |    |--&gt; thd-&gt;mdl_context.acquire_lock  <span class=\"comment\">// 获取 MDL 锁</span></span><br><span class=\"line\">|    |    |    |--&gt; open_table_get_mdl_lock</span><br><span class=\"line\">|    |    |    |    |--&gt; thd-&gt;mdl_context.acquire_lock</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; check_if_table_exists</span><br><span class=\"line\">|    |    |    |    |--&gt; dd::table_exists</span><br><span class=\"line\">|    |    |    |    |    |--&gt; client-&gt;acquire <span class=\"comment\">// dd::Abstract_table</span></span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; tc-&gt;get_table  <span class=\"comment\">//  从 Table_cache_manager 查找</span></span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; get_table_share_with_discover  <span class=\"comment\">// 构建 TABLE_SHARE</span></span><br><span class=\"line\">|    |    |    |    |--&gt; get_table_share</span><br><span class=\"line\">|    |    |    |    |    |--&gt; table_def_cache-&gt;<span class=\"built_in\">find</span>  <span class=\"comment\">// 从 Table_definition_cache 查找</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; process_found_table_share</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; alloc_table_share</span><br><span class=\"line\">|    |    |    |    |    |--&gt; table_def_cache-&gt;emplace  <span class=\"comment\">// 维护 Table_definition_cache</span></span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; thd-&gt;dd_client()-&gt;acquire</span><br><span class=\"line\">|    |    |    |    |    |--&gt; open_table_def</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; open_table_from_share  <span class=\"comment\">// 通过 TABLE_SHARE 打开 TABLE</span></span><br><span class=\"line\">|    |    |    |    |--&gt; ha_open</span><br><span class=\"line\">|    |    |    |    |    |--&gt; ha_innobase::<span class=\"built_in\">open</span> <span class=\"comment\">// 打开一个 innodb 表</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; lookup_table_handler</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; dict_table_check_if_in_cache_low</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; dd_open_table</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; dd_open_table_one</span><br><span class=\"line\">|    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; row_create_prebuilt</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; info(...)</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; info_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; update_thd</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; row_update_prebuilt_trx</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; tc-&gt;add_used_table  <span class=\"comment\">// 添加到 Table_cache_manager</span></span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; thd-&gt;set_open_tables</span><br><span class=\"line\">|    |    |    |--&gt; table-&gt;init</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; close_thread_tables</span><br><span class=\"line\">|    |--&gt; mysql_unlock_tables</span><br><span class=\"line\">|    |    |--&gt; unlock_external</span><br><span class=\"line\">|    |    |    |--&gt; ha_external_lock</span><br><span class=\"line\">|    |    |    |    |--&gt; ha_innobase::external_lock</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; close_open_tables</span><br><span class=\"line\">|    |    |--&gt; close_thread_table</span><br><span class=\"line\">|    |    |    |--&gt; release_or_close_table</span><br><span class=\"line\">|    |    |    |    |--&gt; intern_close_table</span><br><span class=\"line\">|    |    |    |    |--&gt; tc-&gt;remove_table</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; tc-&gt;release_table</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"MySQL-5-7\"><a href=\"#MySQL-5-7\" class=\"headerlink\" title=\"MySQL 5.7\"></a>MySQL 5.7</h2><h3 id=\"表打开过程\"><a href=\"#表打开过程\" class=\"headerlink\" title=\"表打开过程\"></a>表打开过程</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">open_table</span><span class=\"params\">(THD *thd, TABLE_LIST *table_list, Open_table_context *ot_ctx)</span></span></span><br><span class=\"line\">    |</span><br><span class=\"line\">    |</span><br><span class=\"line\">    |--&gt; <span class=\"function\">TABLE* <span class=\"title\">Table_cache::get_table</span><span class=\"params\">(THD *thd, my_hash_value_type hash_value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |                                  <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *key, <span class=\"keyword\">size_t</span> key_length,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |                                  TABLE_SHARE **share)</span></span></span><br><span class=\"line\">    |</span><br><span class=\"line\">    |</span><br><span class=\"line\">    |--&gt; TABLE_SHARE *</span><br><span class=\"line\">    |    get_table_share_with_discover(THD *thd, TABLE_LIST *table_list,</span><br><span class=\"line\">    |                                  <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *key, <span class=\"keyword\">size_t</span> key_length,</span><br><span class=\"line\">    |                                  uint db_flags, <span class=\"keyword\">int</span> *error,</span><br><span class=\"line\">    |                                  my_hash_value_type hash_value)</span><br><span class=\"line\">    |        |</span><br><span class=\"line\">    |        |</span><br><span class=\"line\">    |        |--&gt; <span class=\"function\">TABLE_SHARE *<span class=\"title\">get_table_share</span><span class=\"params\">(THD *thd, TABLE_LIST *table_list,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                                 <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *key, <span class=\"keyword\">size_t</span> key_length,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                                 uint db_flags, <span class=\"keyword\">int</span> *error,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                                 my_hash_value_type hash_value)</span></span></span><br><span class=\"line\">    |        |        |</span><br><span class=\"line\">    |        |        |</span><br><span class=\"line\">    |        |        |--&gt; <span class=\"function\">uchar* <span class=\"title\">my_hash_search_using_hash_value</span><span class=\"params\">(<span class=\"keyword\">const</span> HASH *hash, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |                                            my_hash_value_type hash_value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |                                            <span class=\"keyword\">const</span> uchar *key,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |                                            <span class=\"keyword\">size_t</span> length)</span></span></span><br><span class=\"line\">    |        |        |</span><br><span class=\"line\">    |        |        |</span><br><span class=\"line\">    |        |        |--&gt; <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">open_table_def</span><span class=\"params\">(THD *thd, TABLE_SHARE *share, uint db_flags)</span></span></span><br><span class=\"line\">    |        |        |        |</span><br><span class=\"line\">    |        |        |        |</span><br><span class=\"line\">    |        |        |        |--&gt; <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">open_binary_frm</span><span class=\"params\">(THD *thd, TABLE_SHARE *share, uchar *head,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |        |                               <span class=\"built_in\">File</span> file)</span></span></span><br><span class=\"line\">    |        |        |        |        |</span><br><span class=\"line\">    |        |        |        |        |</span><br><span class=\"line\">    |        |        |        |        |--&gt; <span class=\"function\">handler *<span class=\"title\">get_new_handler</span><span class=\"params\">(TABLE_SHARE *share, MEM_ROOT *alloc,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |        |        |                             handlerton *db_type)</span></span></span><br><span class=\"line\">    |</span><br><span class=\"line\">    |</span><br><span class=\"line\">    |--&gt; <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">open_table_from_share</span><span class=\"params\">(THD *thd, TABLE_SHARE *share, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *alias,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |                              uint db_stat, uint prgflag, uint ha_open_flags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |                              TABLE *outparam, <span class=\"keyword\">bool</span> is_create_table)</span></span></span><br><span class=\"line\">    |        |</span><br><span class=\"line\">    |        |</span><br><span class=\"line\">    |        |--&gt; <span class=\"function\">handler *<span class=\"title\">get_new_handler</span><span class=\"params\">(TABLE_SHARE *share, MEM_ROOT *alloc,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                             handlerton *db_type)</span></span></span><br><span class=\"line\">    |        |</span><br><span class=\"line\">    |        |</span><br><span class=\"line\">    |        |--&gt; <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">handler::ha_open</span><span class=\"params\">(TABLE *table_arg, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, <span class=\"keyword\">int</span> mode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"keyword\">int</span> test_if_locked)</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"表创建过程\"><a href=\"#表创建过程\" class=\"headerlink\" title=\"表创建过程\"></a>表创建过程</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TABLE_LIST *</span><br><span class=\"line\">st_select_lex::add_table_to_list(THD *thd,</span><br><span class=\"line\">                                 Table_ident *table,</span><br><span class=\"line\">                                 LEX_STRING *alias,</span><br><span class=\"line\">                                 ulong table_options,</span><br><span class=\"line\">                                 thr_lock_type lock_type,</span><br><span class=\"line\">                                 enum_mdl_type mdl_type,</span><br><span class=\"line\">                                 List&lt;Index_hint&gt; *index_hints_arg,</span><br><span class=\"line\">                                 List&lt;<span class=\"keyword\">String</span>&gt; *partition_names,</span><br><span class=\"line\">                                 LEX_STRING *option,</span><br><span class=\"line\">                                 Sequence_scan_mode seq_scan_mode)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">mysql_create_table</span><span class=\"params\">(THD *thd, TABLE_LIST *create_table,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        HA_CREATE_INFO *create_info,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        Alter_info *alter_info)</span></span></span><br><span class=\"line\">    |</span><br><span class=\"line\">    |</span><br><span class=\"line\">    |--&gt; <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">mysql_create_table_no_lock</span><span class=\"params\">(THD *thd,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |                                   <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *db, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *table_name,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |                                   HA_CREATE_INFO *create_info,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |                                   Alter_info *alter_info,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |                                   uint select_field_count,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |                                   <span class=\"keyword\">bool</span> *is_trans)</span></span></span><br><span class=\"line\">    |        |</span><br><span class=\"line\">    |        |</span><br><span class=\"line\">    |        |--&gt; <span class=\"keyword\">static</span></span><br><span class=\"line\">    |        |    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">create_table_impl</span><span class=\"params\">(THD *thd,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *db, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *table_name,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *error_table_name,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           HA_CREATE_INFO *create_info,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           Alter_info *alter_info,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           <span class=\"keyword\">bool</span> internal_tmp_table,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           uint select_field_count,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           <span class=\"keyword\">bool</span> no_ha_table,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           <span class=\"keyword\">bool</span> *is_trans,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           KEY **key_info,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           uint *key_count)</span></span></span><br><span class=\"line\">    |        |        |</span><br><span class=\"line\">    |        |        |</span><br><span class=\"line\">    |        |        |--&gt; <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rea_create_table</span><span class=\"params\">(THD *thd, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |                         <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *db, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *table_name,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |                         HA_CREATE_INFO *create_info,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |                         List&lt;Create_field&gt; &amp;create_fields,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |                         uint keys, KEY *key_info, handler *file,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |                         <span class=\"keyword\">bool</span> no_ha_table)</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* create table 过程 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; mysql_create_table</span><br><span class=\"line\">|    |--&gt; open_tables</span><br><span class=\"line\">|    |    |--&gt; open_and_process_table</span><br><span class=\"line\">|    |    |    |--&gt; open_table</span><br><span class=\"line\">|    |    |    |    |--&gt; check_if_table_exists</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; mysql_create_table_no_lock</span><br><span class=\"line\">|    |    |--&gt; create_table_impl</span><br><span class=\"line\">|    |    |    |--&gt; mysql_prepare_create_table</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; rea_create_table</span><br><span class=\"line\">|    |    |    |    |--&gt; mysql_create_frm <span class=\"comment\">// 创建 frm 文件</span></span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; ha_create_table</span><br><span class=\"line\">|    |    |    |    |    |--&gt; open_table_def</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; mysql_file_open</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; open_binary_frm</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; mysql_file_close</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; open_table_from_share</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; table.file-&gt;ha_create</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; ha_innobase::create</span><br><span class=\"line\">|    |--&gt; info.prepare_create_table</span><br><span class=\"line\">|    |--&gt; row_mysql_lock_data_dictionary</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; info.create_table</span><br><span class=\"line\">|    |    |--&gt; create_table_def</span><br><span class=\"line\">|    |    |    |--&gt; dict_mem_table_create</span><br><span class=\"line\">|    |    |    |--&gt; row_create_table_for_mysql</span><br><span class=\"line\">|    |    |    |    |--&gt; dict_build_table_def_step</span><br><span class=\"line\">|    |    |    |    |    |--&gt; dict_build_tablespace_for_table</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; fil_ibd_create <span class=\"comment\">// 创建 ibd 文件</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; dict_create_sys_tables_tuple</span><br><span class=\"line\">|    |    |    |    |    |--&gt; ins_node_set_new_row <span class=\"comment\">// 插入系统表</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; create_index</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; row_mysql_unlock_data_dictionary</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p><a href=\"http://mysql.taobao.org/monthly/2015/08/10/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2015/08/10/</a></p>\n<p><a href=\"http://liuyangming.tech/10-2019/information_schema-exploration.html\" target=\"_blank\" rel=\"noopener\">http://liuyangming.tech/10-2019/information_schema-exploration.html</a></p>\n<p><a href=\"https://www.cnblogs.com/xpchild/p/3780625.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xpchild/p/3780625.html</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>MySQL 中的 TABLE 是最核心的数据结构之一，包含的类包括：TABLE、TABLE_LIST、TABLE_SHARE 等，下面结合 MySQL 的代码进行分析说明。</p>","more":"<h2 id=\"基本说明\"><a href=\"#基本说明\" class=\"headerlink\" title=\"基本说明\"></a>基本说明</h2><ul>\n<li>TABLE_LIST：词法&amp;语法分析后生成的对象，常见的生成方式为 add_table_to_list</li>\n<li>TABLE_SHARE：server 层表定义缓存，一个 table 实例对应一个 TABLES_SHARE 对象，可以将TABLE_SHRAE 对象看成是表的物理文件（frm）在内存中的映射</li>\n<li>TABLE：每一个查询 sql 中的表建一个 TABLE 对象</li>\n</ul>\n<img src=\"/images/table-object-1.png\" align=\"left\"/>\n<img class=\"nofancybox\" src=\"/images/div.jpg\" width=\"100%\" height=\"0.1px\"/>\n\n<p>TABLE_LIST 只是一个表的描述信息，包括各种名称、锁类型等；</p>\n<p>TABLE_SHARE 可以看作是完整的表定义信息，在 8.0 以前的版本中需要通过读取 frm 文件获取，8.0 版本中引入了 DD，可以直接通过 DD 获取到表定义信息。Server 层有一个全局的 Table_definition_cache 缓存对象，保存已经打开的 TABLE_SHARE 对象；</p>\n<p>TABLE 对象为查询最后使用的 TABLE 信息，该对象上关联了引擎层的 hander，所有的引擎层的操作都需要通过此 hander 进行。Server 层同样有一个全局的 Table_cache_manager，然而 TABLE 的缓存和 TABLE_SHARE 的缓存不同，由于每个 THD 上的 TABLE 对象都不相同，所有同一个表会在 Table_cache_manager 保存多份。</p>\n<p>关于 Table_cache_manager，有两个参数进行控制：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MySQL [none]&gt; show variables like \"%table_open%\";</span><br><span class=\"line\">+<span class=\"comment\">----------------------------+-------+</span></span><br><span class=\"line\">| Variable_name              | Value |</span><br><span class=\"line\">+<span class=\"comment\">----------------------------+-------+</span></span><br><span class=\"line\">| table_open_cache           | 500   |</span><br><span class=\"line\">| table_open_cache_instances | 16    |</span><br><span class=\"line\">+<span class=\"comment\">----------------------------+-------+</span></span><br><span class=\"line\">2 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<ul>\n<li>table_open_cache_instances 表示将 Table_cache_manager 分为多少个部分；</li>\n<li>table_open_cache 表示 TABLE 对象的阈值，超过此值后会开始进行无用对象的回收；</li>\n</ul>\n<h2 id=\"MySQL-8-0\"><a href=\"#MySQL-8-0\" class=\"headerlink\" title=\"MySQL 8.0\"></a>MySQL 8.0</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; open_tables</span><br><span class=\"line\">|    |--&gt; open_and_process_table</span><br><span class=\"line\">|    |    |--&gt; open_table  <span class=\"comment\">// 打开表</span></span><br><span class=\"line\">|    |    |    |--&gt; thd-&gt;mdl_context.acquire_lock  <span class=\"comment\">// 获取 MDL 锁</span></span><br><span class=\"line\">|    |    |    |--&gt; open_table_get_mdl_lock</span><br><span class=\"line\">|    |    |    |    |--&gt; thd-&gt;mdl_context.acquire_lock</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; check_if_table_exists</span><br><span class=\"line\">|    |    |    |    |--&gt; dd::table_exists</span><br><span class=\"line\">|    |    |    |    |    |--&gt; client-&gt;acquire <span class=\"comment\">// dd::Abstract_table</span></span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; tc-&gt;get_table  <span class=\"comment\">//  从 Table_cache_manager 查找</span></span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; get_table_share_with_discover  <span class=\"comment\">// 构建 TABLE_SHARE</span></span><br><span class=\"line\">|    |    |    |    |--&gt; get_table_share</span><br><span class=\"line\">|    |    |    |    |    |--&gt; table_def_cache-&gt;<span class=\"built_in\">find</span>  <span class=\"comment\">// 从 Table_definition_cache 查找</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; process_found_table_share</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; alloc_table_share</span><br><span class=\"line\">|    |    |    |    |    |--&gt; table_def_cache-&gt;emplace  <span class=\"comment\">// 维护 Table_definition_cache</span></span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; thd-&gt;dd_client()-&gt;acquire</span><br><span class=\"line\">|    |    |    |    |    |--&gt; open_table_def</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; open_table_from_share  <span class=\"comment\">// 通过 TABLE_SHARE 打开 TABLE</span></span><br><span class=\"line\">|    |    |    |    |--&gt; ha_open</span><br><span class=\"line\">|    |    |    |    |    |--&gt; ha_innobase::<span class=\"built_in\">open</span> <span class=\"comment\">// 打开一个 innodb 表</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; lookup_table_handler</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; dict_table_check_if_in_cache_low</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; dd_open_table</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; dd_open_table_one</span><br><span class=\"line\">|    |    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; row_create_prebuilt</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; info(...)</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; info_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; update_thd</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |    |--&gt; row_update_prebuilt_trx</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; tc-&gt;add_used_table  <span class=\"comment\">// 添加到 Table_cache_manager</span></span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; thd-&gt;set_open_tables</span><br><span class=\"line\">|    |    |    |--&gt; table-&gt;init</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; close_thread_tables</span><br><span class=\"line\">|    |--&gt; mysql_unlock_tables</span><br><span class=\"line\">|    |    |--&gt; unlock_external</span><br><span class=\"line\">|    |    |    |--&gt; ha_external_lock</span><br><span class=\"line\">|    |    |    |    |--&gt; ha_innobase::external_lock</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; close_open_tables</span><br><span class=\"line\">|    |    |--&gt; close_thread_table</span><br><span class=\"line\">|    |    |    |--&gt; release_or_close_table</span><br><span class=\"line\">|    |    |    |    |--&gt; intern_close_table</span><br><span class=\"line\">|    |    |    |    |--&gt; tc-&gt;remove_table</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; tc-&gt;release_table</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"MySQL-5-7\"><a href=\"#MySQL-5-7\" class=\"headerlink\" title=\"MySQL 5.7\"></a>MySQL 5.7</h2><h3 id=\"表打开过程\"><a href=\"#表打开过程\" class=\"headerlink\" title=\"表打开过程\"></a>表打开过程</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">open_table</span><span class=\"params\">(THD *thd, TABLE_LIST *table_list, Open_table_context *ot_ctx)</span></span></span><br><span class=\"line\">    |</span><br><span class=\"line\">    |</span><br><span class=\"line\">    |--&gt; <span class=\"function\">TABLE* <span class=\"title\">Table_cache::get_table</span><span class=\"params\">(THD *thd, my_hash_value_type hash_value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |                                  <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *key, <span class=\"keyword\">size_t</span> key_length,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |                                  TABLE_SHARE **share)</span></span></span><br><span class=\"line\">    |</span><br><span class=\"line\">    |</span><br><span class=\"line\">    |--&gt; TABLE_SHARE *</span><br><span class=\"line\">    |    get_table_share_with_discover(THD *thd, TABLE_LIST *table_list,</span><br><span class=\"line\">    |                                  <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *key, <span class=\"keyword\">size_t</span> key_length,</span><br><span class=\"line\">    |                                  uint db_flags, <span class=\"keyword\">int</span> *error,</span><br><span class=\"line\">    |                                  my_hash_value_type hash_value)</span><br><span class=\"line\">    |        |</span><br><span class=\"line\">    |        |</span><br><span class=\"line\">    |        |--&gt; <span class=\"function\">TABLE_SHARE *<span class=\"title\">get_table_share</span><span class=\"params\">(THD *thd, TABLE_LIST *table_list,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                                 <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *key, <span class=\"keyword\">size_t</span> key_length,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                                 uint db_flags, <span class=\"keyword\">int</span> *error,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                                 my_hash_value_type hash_value)</span></span></span><br><span class=\"line\">    |        |        |</span><br><span class=\"line\">    |        |        |</span><br><span class=\"line\">    |        |        |--&gt; <span class=\"function\">uchar* <span class=\"title\">my_hash_search_using_hash_value</span><span class=\"params\">(<span class=\"keyword\">const</span> HASH *hash, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |                                            my_hash_value_type hash_value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |                                            <span class=\"keyword\">const</span> uchar *key,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |                                            <span class=\"keyword\">size_t</span> length)</span></span></span><br><span class=\"line\">    |        |        |</span><br><span class=\"line\">    |        |        |</span><br><span class=\"line\">    |        |        |--&gt; <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">open_table_def</span><span class=\"params\">(THD *thd, TABLE_SHARE *share, uint db_flags)</span></span></span><br><span class=\"line\">    |        |        |        |</span><br><span class=\"line\">    |        |        |        |</span><br><span class=\"line\">    |        |        |        |--&gt; <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">open_binary_frm</span><span class=\"params\">(THD *thd, TABLE_SHARE *share, uchar *head,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |        |                               <span class=\"built_in\">File</span> file)</span></span></span><br><span class=\"line\">    |        |        |        |        |</span><br><span class=\"line\">    |        |        |        |        |</span><br><span class=\"line\">    |        |        |        |        |--&gt; <span class=\"function\">handler *<span class=\"title\">get_new_handler</span><span class=\"params\">(TABLE_SHARE *share, MEM_ROOT *alloc,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |        |        |                             handlerton *db_type)</span></span></span><br><span class=\"line\">    |</span><br><span class=\"line\">    |</span><br><span class=\"line\">    |--&gt; <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">open_table_from_share</span><span class=\"params\">(THD *thd, TABLE_SHARE *share, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *alias,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |                              uint db_stat, uint prgflag, uint ha_open_flags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |                              TABLE *outparam, <span class=\"keyword\">bool</span> is_create_table)</span></span></span><br><span class=\"line\">    |        |</span><br><span class=\"line\">    |        |</span><br><span class=\"line\">    |        |--&gt; <span class=\"function\">handler *<span class=\"title\">get_new_handler</span><span class=\"params\">(TABLE_SHARE *share, MEM_ROOT *alloc,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                             handlerton *db_type)</span></span></span><br><span class=\"line\">    |        |</span><br><span class=\"line\">    |        |</span><br><span class=\"line\">    |        |--&gt; <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">handler::ha_open</span><span class=\"params\">(TABLE *table_arg, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, <span class=\"keyword\">int</span> mode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"keyword\">int</span> test_if_locked)</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"表创建过程\"><a href=\"#表创建过程\" class=\"headerlink\" title=\"表创建过程\"></a>表创建过程</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TABLE_LIST *</span><br><span class=\"line\">st_select_lex::add_table_to_list(THD *thd,</span><br><span class=\"line\">                                 Table_ident *table,</span><br><span class=\"line\">                                 LEX_STRING *alias,</span><br><span class=\"line\">                                 ulong table_options,</span><br><span class=\"line\">                                 thr_lock_type lock_type,</span><br><span class=\"line\">                                 enum_mdl_type mdl_type,</span><br><span class=\"line\">                                 List&lt;Index_hint&gt; *index_hints_arg,</span><br><span class=\"line\">                                 List&lt;<span class=\"keyword\">String</span>&gt; *partition_names,</span><br><span class=\"line\">                                 LEX_STRING *option,</span><br><span class=\"line\">                                 Sequence_scan_mode seq_scan_mode)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">mysql_create_table</span><span class=\"params\">(THD *thd, TABLE_LIST *create_table,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        HA_CREATE_INFO *create_info,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        Alter_info *alter_info)</span></span></span><br><span class=\"line\">    |</span><br><span class=\"line\">    |</span><br><span class=\"line\">    |--&gt; <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">mysql_create_table_no_lock</span><span class=\"params\">(THD *thd,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |                                   <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *db, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *table_name,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |                                   HA_CREATE_INFO *create_info,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |                                   Alter_info *alter_info,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |                                   uint select_field_count,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |                                   <span class=\"keyword\">bool</span> *is_trans)</span></span></span><br><span class=\"line\">    |        |</span><br><span class=\"line\">    |        |</span><br><span class=\"line\">    |        |--&gt; <span class=\"keyword\">static</span></span><br><span class=\"line\">    |        |    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">create_table_impl</span><span class=\"params\">(THD *thd,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *db, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *table_name,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *error_table_name,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           HA_CREATE_INFO *create_info,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           Alter_info *alter_info,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           <span class=\"keyword\">bool</span> internal_tmp_table,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           uint select_field_count,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           <span class=\"keyword\">bool</span> no_ha_table,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           <span class=\"keyword\">bool</span> *is_trans,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           KEY **key_info,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |                           uint *key_count)</span></span></span><br><span class=\"line\">    |        |        |</span><br><span class=\"line\">    |        |        |</span><br><span class=\"line\">    |        |        |--&gt; <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rea_create_table</span><span class=\"params\">(THD *thd, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |                         <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *db, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *table_name,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |                         HA_CREATE_INFO *create_info,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |                         List&lt;Create_field&gt; &amp;create_fields,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |                         uint keys, KEY *key_info, handler *file,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    |        |        |                         <span class=\"keyword\">bool</span> no_ha_table)</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* create table 过程 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; mysql_create_table</span><br><span class=\"line\">|    |--&gt; open_tables</span><br><span class=\"line\">|    |    |--&gt; open_and_process_table</span><br><span class=\"line\">|    |    |    |--&gt; open_table</span><br><span class=\"line\">|    |    |    |    |--&gt; check_if_table_exists</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; mysql_create_table_no_lock</span><br><span class=\"line\">|    |    |--&gt; create_table_impl</span><br><span class=\"line\">|    |    |    |--&gt; mysql_prepare_create_table</span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; rea_create_table</span><br><span class=\"line\">|    |    |    |    |--&gt; mysql_create_frm <span class=\"comment\">// 创建 frm 文件</span></span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; ha_create_table</span><br><span class=\"line\">|    |    |    |    |    |--&gt; open_table_def</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; mysql_file_open</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; open_binary_frm</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; mysql_file_close</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; open_table_from_share</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; table.file-&gt;ha_create</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; ha_innobase::create</span><br><span class=\"line\">|    |--&gt; info.prepare_create_table</span><br><span class=\"line\">|    |--&gt; row_mysql_lock_data_dictionary</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; info.create_table</span><br><span class=\"line\">|    |    |--&gt; create_table_def</span><br><span class=\"line\">|    |    |    |--&gt; dict_mem_table_create</span><br><span class=\"line\">|    |    |    |--&gt; row_create_table_for_mysql</span><br><span class=\"line\">|    |    |    |    |--&gt; dict_build_table_def_step</span><br><span class=\"line\">|    |    |    |    |    |--&gt; dict_build_tablespace_for_table</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; fil_ibd_create <span class=\"comment\">// 创建 ibd 文件</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; dict_create_sys_tables_tuple</span><br><span class=\"line\">|    |    |    |    |    |--&gt; ins_node_set_new_row <span class=\"comment\">// 插入系统表</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; create_index</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; row_mysql_unlock_data_dictionary</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><blockquote>\n<p><a href=\"http://mysql.taobao.org/monthly/2015/08/10/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2015/08/10/</a></p>\n<p><a href=\"http://liuyangming.tech/10-2019/information_schema-exploration.html\" target=\"_blank\" rel=\"noopener\">http://liuyangming.tech/10-2019/information_schema-exploration.html</a></p>\n<p><a href=\"https://www.cnblogs.com/xpchild/p/3780625.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xpchild/p/3780625.html</a></p>\n</blockquote>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckojpj4x50009gugm1v0g49r1","category_id":"ckojpj4x10006gugm41op9821","_id":"ckojpj4xa000ggugm5a7icubp"},{"post_id":"ckojpj4wz0004gugmfzq770ef","category_id":"ckojpj4x10006gugm41op9821","_id":"ckojpj4xd000jgugmdsdahgmx"},{"post_id":"ckojpj4x00005gugmbewn2i5i","category_id":"ckojpj4x7000bgugm0bsh0cjo","_id":"ckojpj4xf000ogugmel6t7bmq"},{"post_id":"ckojpj4x30007gugmhdls02hz","category_id":"ckojpj4x10006gugm41op9821","_id":"ckojpj4xi000tgugm5766evny"},{"post_id":"ckojpj4xg000pgugmh2032qdy","category_id":"ckojpj4xf000ngugmhvb66sv4","_id":"ckojpj4xk000ygugm5blj524v"},{"post_id":"ckojpj4x6000agugmfa9z3gns","category_id":"ckojpj4xf000ngugmhvb66sv4","_id":"ckojpj4xm0012gugmevwzcq8z"},{"post_id":"ckojpj4x8000cgugm3znafcla","category_id":"ckojpj4xf000ngugmhvb66sv4","_id":"ckojpj4xn0017gugmb0btfrxh"},{"post_id":"ckojpj4xk000xgugm03mw3lf0","category_id":"ckojpj4xf000ngugmhvb66sv4","_id":"ckojpj4xo001agugm20cjh02s"},{"post_id":"ckojpj4xa000fgugmgztv87j5","category_id":"ckojpj4xf000ngugmhvb66sv4","_id":"ckojpj4xp001egugm54yba3qr"},{"post_id":"ckojpj4xc000igugma0j72lke","category_id":"ckojpj4xf000ngugmhvb66sv4","_id":"ckojpj4xr001jgugmdiz9ej3f"},{"post_id":"ckojpj4xe000lgugm2uxy2d1c","category_id":"ckojpj4xf000ngugmhvb66sv4","_id":"ckojpj4xu001pgugm5tacgqws"},{"post_id":"ckojpj4xh000rgugm0fn93b1e","category_id":"ckojpj4xr001igugm4u5te2wm","_id":"ckojpj4xv001xgugm4i2lhp91"},{"post_id":"ckojpj4xi000vgugm91qr26xv","category_id":"ckojpj4xr001igugm4u5te2wm","_id":"ckojpj4xx0021gugme8vedkqd"},{"post_id":"ckojpj4xl0011gugmgy465uil","category_id":"ckojpj4xr001igugm4u5te2wm","_id":"ckojpj4xx0023gugm9d1feplo"},{"post_id":"ckojpj4xm0014gugm4gdlgo4v","category_id":"ckojpj4xw0020gugm2dcaf8e4","_id":"ckojpj4xy0027gugm54fh1g01"},{"post_id":"ckojpj4xn0019gugm0c0d0ecu","category_id":"ckojpj4xw0020gugm2dcaf8e4","_id":"ckojpj4xz0029gugm9s5q2ar3"},{"post_id":"ckojpj4xo001bgugm6uha3wln","category_id":"ckojpj4xw0020gugm2dcaf8e4","_id":"ckojpj4xz002bgugmf0sb6e48"},{"post_id":"ckojpj4xq001fgugmaf8g6e0c","category_id":"ckojpj4xw0020gugm2dcaf8e4","_id":"ckojpj4xz002dgugmd8yi5ert"},{"post_id":"ckojpj4xq001ggugm30n7gch9","category_id":"ckojpj4xw0020gugm2dcaf8e4","_id":"ckojpj4y0002fgugmhifk1z7m"},{"post_id":"ckojpj4xs001lgugm8okeefsp","category_id":"ckojpj4xw0020gugm2dcaf8e4","_id":"ckojpj4y0002ggugm7ytg1lhj"},{"post_id":"ckojpj4xs001ngugm6hoohs61","category_id":"ckojpj4y0002egugm5juhfllp","_id":"ckojpj4y1002igugm3jqgbyfo"},{"post_id":"ckojpj4xu001sgugmdccyeddd","category_id":"ckojpj4xw0020gugm2dcaf8e4","_id":"ckojpj4y1002jgugmd3tx0yxu"},{"post_id":"ckojpj4yg002kgugmd3hc2dlw","category_id":"ckojpj4xw0020gugm2dcaf8e4","_id":"ckojpj4yi002lgugm8a189yyt"}],"PostTag":[{"post_id":"ckojpj4x00005gugmbewn2i5i","tag_id":"ckojpj4x40008gugm10fz2g4k","_id":"ckojpj4xa000egugmaary1bp9"},{"post_id":"ckojpj4x30007gugmhdls02hz","tag_id":"ckojpj4x9000dgugmd0k85z5u","_id":"ckojpj4xf000mgugmd8txaxq5"},{"post_id":"ckojpj4x50009gugm1v0g49r1","tag_id":"ckojpj4xe000kgugmd05c11ri","_id":"ckojpj4xh000sgugmh3g2a0y5"},{"post_id":"ckojpj4x6000agugmfa9z3gns","tag_id":"ckojpj4xg000qgugm2av006bg","_id":"ckojpj4xl000zgugm0ft3cp7w"},{"post_id":"ckojpj4xk000xgugm03mw3lf0","tag_id":"ckojpj4x40008gugm10fz2g4k","_id":"ckojpj4xm0013gugmcy2j0nez"},{"post_id":"ckojpj4xc000igugma0j72lke","tag_id":"ckojpj4xj000wgugmdhuxbfz4","_id":"ckojpj4xn0018gugmgesu999k"},{"post_id":"ckojpj4xq001fgugmaf8g6e0c","tag_id":"ckojpj4xj000wgugmdhuxbfz4","_id":"ckojpj4xr001kgugm7dnwekjr"},{"post_id":"ckojpj4xi000vgugm91qr26xv","tag_id":"ckojpj4xm0015gugmf8fk8ork","_id":"ckojpj4xs001mgugmd5aoeq09"},{"post_id":"ckojpj4xi000vgugm91qr26xv","tag_id":"ckojpj4xp001cgugm007i4gy2","_id":"ckojpj4xu001qgugm6c6lgwg1"},{"post_id":"ckojpj4xl0011gugmgy465uil","tag_id":"ckojpj4xp001cgugm007i4gy2","_id":"ckojpj4xv001tgugm61wbeklu"},{"post_id":"ckojpj4xu001sgugmdccyeddd","tag_id":"ckojpj4x40008gugm10fz2g4k","_id":"ckojpj4xv001ugugm7214ati1"},{"post_id":"ckojpj4xo001bgugm6uha3wln","tag_id":"ckojpj4xt001ogugmbs6k0nfa","_id":"ckojpj4xw001ygugmdaoza7tz"},{"post_id":"ckojpj4xq001ggugm30n7gch9","tag_id":"ckojpj4xt001ogugmbs6k0nfa","_id":"ckojpj4xx0022gugmdcxk64nj"},{"post_id":"ckojpj4xs001lgugm8okeefsp","tag_id":"ckojpj4xt001ogugmbs6k0nfa","_id":"ckojpj4xy0025gugmhc8l4opz"}],"Tag":[{"name":"事务","_id":"ckojpj4x40008gugm10fz2g4k"},{"name":"锁","_id":"ckojpj4x9000dgugmd0k85z5u"},{"name":"LF_HASH","_id":"ckojpj4xe000kgugmd05c11ri"},{"name":"Buffer Pool","_id":"ckojpj4xg000qgugm2av006bg"},{"name":"架构","_id":"ckojpj4xj000wgugmdhuxbfz4"},{"name":"网络","_id":"ckojpj4xm0015gugmf8fk8ork"},{"name":"工具","_id":"ckojpj4xp001cgugm007i4gy2"},{"name":"Feature","_id":"ckojpj4xt001ogugmbs6k0nfa"}]}}