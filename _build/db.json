{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/images/innodb-intro.png","path":"images/innodb-intro.png","modified":0,"renderable":0},{"_id":"source/images/sql-execute-1.jpg","path":"images/sql-execute-1.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/LICENSE","path":"lib/fancybox/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/README.md","path":"lib/fancybox/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.css","path":"lib/fancybox/source/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.js","path":"lib/fancybox/source/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"source/images/connection-handler-1.jpg","path":"images/connection-handler-1.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"c9a96fa1e3a3a6a958fd387b271dff8f454fd918","modified":1598170414560},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1593857338947},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1593857338946},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1593857338947},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1593857338952},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1593857338952},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1593857338952},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1593857338952},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1593857338952},{"_id":"themes/next/_config.yml","hash":"920398a2c3b44bb7266fdda769abdd057437362f","modified":1595148234815},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1593857338953},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1593857338960},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1593857338989},{"_id":"source/_posts/cgroup-linux.md","hash":"cd47b99ee502770964dda136c63fae70123e2a8d","modified":1595079459149},{"_id":"source/_posts/cplusplus-lock.md","hash":"027da7b378dd3d5bd60ee11da44fb74f85ee9a83","modified":1594998446364},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1594458078377},{"_id":"source/_posts/connection-handler.md","hash":"68bbe3999101706889d87450524e8421c89e6519","modified":1595247844907},{"_id":"source/_posts/innodb-intro.md","hash":"aad178f564c4946ac15efff7e2433aea5edaf4bb","modified":1595148402649},{"_id":"source/_posts/innodb-buffer-page.md","hash":"00580feb301c554c85ee35caddfbac36490f0f57","modified":1598517854922},{"_id":"source/_posts/lf_hash.md","hash":"658131e7f52dc1f2659d7a615b9d351e4c15cec9","modified":1595000102564},{"_id":"source/_posts/menu.md","hash":"24b49f6ec56bb5d385155835863ff4e03e18933b","modified":1594997322273},{"_id":"source/_posts/io-performance.md","hash":"71e7a267cfc8df906aa25e90b9b5515b5cd2c073","modified":1600047688205},{"_id":"source/_posts/perf-linux.md","hash":"23fd0032daf8f26d6669efd453db10ef41760c41","modified":1595079396261},{"_id":"source/_posts/sql-execute.md","hash":"ef03a5e1dcd90d551ad229508b27e5bfd6f8e7f3","modified":1595148431783},{"_id":"source/_posts/tcpdump-linux.md","hash":"82bdc16538b829934b97a8b51021fec8656aa4af","modified":1595077378707},{"_id":"source/_posts/x-plugin.md","hash":"db01c15aa5ee5d4bf95634ea4c9e850b8269ea1a","modified":1595079414647},{"_id":"source/_posts/transaction-intro.md","hash":"b66c7c05810ff68a825ecf670b078bae79e45884","modified":1594997210902},{"_id":"source/archives/index.md","hash":"f275280243804c848b2c8c79a72e35e486be36e8","modified":1593838240368},{"_id":"source/categories/index.md","hash":"4cd6c17983a961a9efde496b64ac548c6fffa17f","modified":1593861512927},{"_id":"source/tags/index.md","hash":"5fb0f145c4628f09f7c2406ac106794ec3e8e9f7","modified":1593861555878},{"_id":"themes/next/.git_bak/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1593857338933},{"_id":"themes/next/.git_bak/config","hash":"e78135eac1ede2f3ca79747839db482790e54b3c","modified":1593857338936},{"_id":"themes/next/.git_bak/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1593856664496},{"_id":"themes/next/.git_bak/index","hash":"67865cd6cf6a72bc10f46fa850cd4d45502859d5","modified":1593862256184},{"_id":"themes/next/.git_bak/packed-refs","hash":"106c07d5e79883e01ae524173c32e1ab7ee0d172","modified":1593857338930},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1593857338947},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1593857338948},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1593857338950},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1593857338949},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1593857338950},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1593857338950},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1593857338950},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1593857338951},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1593857338951},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1593857338951},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1593857338951},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1593857338954},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1593857338954},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1593857338953},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1593857338954},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1593857338954},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1593857338955},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1593857338955},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1593857338955},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1593857338955},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1593857338960},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1593857338960},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1593857338960},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1593857338960},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1593857338961},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1593857338961},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1593857338961},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1593857338961},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1593857338961},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1593857338962},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1593857338962},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1593857338962},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1593857338963},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1593857338963},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1593857338963},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1593857338963},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1593857338962},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1593857338964},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1593857338963},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1593857338964},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1593857338964},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1593857338965},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1593857338964},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1593857338987},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1593857338988},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1593857338987},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1593857338988},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1593857338988},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1593857338988},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1593857338994},{"_id":"source/images/innodb-intro.png","hash":"fdbf2c8bff19fdc7ab07f5abdb3b8aec0ca995b8","modified":1594985026506},{"_id":"source/images/sql-execute-1.jpg","hash":"de7bb4171af4fac85259ef6a229c6c8fd4cd245c","modified":1594560155351},{"_id":"themes/next/.git_bak/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1593856664497},{"_id":"themes/next/.git_bak/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1593856664499},{"_id":"themes/next/.git_bak/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1593856664501},{"_id":"themes/next/.git_bak/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1593856664502},{"_id":"themes/next/.git_bak/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1593856664498},{"_id":"themes/next/.git_bak/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1593856664503},{"_id":"themes/next/.git_bak/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1593856664500},{"_id":"themes/next/.git_bak/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1593856664500},{"_id":"themes/next/.git_bak/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1593856664498},{"_id":"themes/next/.git_bak/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1593856664503},{"_id":"themes/next/.git_bak/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1593856664496},{"_id":"themes/next/.git_bak/logs/HEAD","hash":"c6061cb06758c3c5ad7af34c0db7588ca51dcdf7","modified":1593857338935},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1593857338948},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1593857338948},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1593857338949},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1593857338949},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1593857338956},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1593857338956},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1593857338956},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1593857338957},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1593857338956},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1593857338957},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1593857338958},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1593857338958},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1593857338957},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1593857338958},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1593857338959},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1593857338959},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1593857338959},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1593857338965},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1593857338965},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1593857338965},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1593857338966},{"_id":"themes/next/layout/_partials/footer.swig","hash":"e5a2bdf45fde7cea9cb03993f5a0fd960326ed5d","modified":1593862255682},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1593857338968},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1593857338969},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1593857338976},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1593857338976},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1593857338977},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1593857338977},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1593857338979},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1593857338979},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1593857338981},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1593857338983},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1593857338984},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1593857338984},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1593857338989},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1593857338992},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1593857338992},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1593857338993},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1593857338993},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1593857338993},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1593857338993},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1593857338994},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1593857338994},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1593857338994},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1593857338994},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1593857338995},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1593857338995},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1593857338995},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1593857338995},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1593857338996},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1593857338996},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1593857338996},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1593857338996},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1593857338996},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1593857338997},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1593857339023},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1593857339029},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1593857339030},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1593857339030},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1593857339030},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1593857339031},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1593857339032},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1593857339031},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1593857339031},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1593857339032},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1593857339032},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1593857339033},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1593857339033},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1593857339033},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1593857339033},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1593857339033},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1593857339034},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1593857339034},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1593857339034},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1593857339034},{"_id":"themes/next/source/js/utils.js","hash":"2c6e6b4d9a592fbb4bf04689524db2cdfcd94ca7","modified":1593857339035},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1593857339036},{"_id":"themes/next/.git_bak/refs/heads/master","hash":"7b5894d5fc28d7797285dac4f43134462f6c7c5d","modified":1593857338934},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1593857338966},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1593857338966},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1593857338967},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1593857338966},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1593857338967},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1593857338967},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1593857338968},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1593857338968},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1593857338969},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1593857338974},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1593857338974},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1593857338975},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1593857338974},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1593857338975},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1593857338975},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1593857338975},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1593857338976},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1593857338976},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1593857338977},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1593857338978},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1593857338978},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1593857338978},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1593857338979},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1593857338980},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1593857338980},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1593857338980},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1593857338980},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1593857338981},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1593857338981},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1593857338982},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1593857338982},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1593857338982},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1593857338982},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1593857338982},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1593857338983},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1593857338983},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1593857338984},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1593857338983},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1593857338984},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1593857338985},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1593857338985},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1593857338985},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1593857338986},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1593857338986},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1593857338986},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1593857338986},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1593857338987},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1593857338987},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1593857338989},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1593857338989},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1593857338990},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1593857338990},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1593857338990},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1593857338991},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1593857338991},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1593857338991},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1593857338991},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1593857338992},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1593857338992},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1593857339028},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1593857339028},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1593857339028},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1593857339029},{"_id":"themes/next/source/css/_variables/base.styl","hash":"3ff1998af930bbddb029ef288ecfb76466a01211","modified":1593859539203},{"_id":"themes/next/source/images/avatar.jpg","hash":"e7980d215c86bd4ac681991ae0d6ac2f526d3824","modified":1593859327541},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1593857339035},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1593857339035},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"d8bf9cb15d9d91c7ad022ba2954b5b4d326f17f7","modified":1595148214246},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1595148214246},{"_id":"themes/next/source/lib/fancybox/LICENSE","hash":"8624bcdae55baeef00cd11d5dfcfa60f68710a02","modified":1595148214247},{"_id":"themes/next/source/lib/fancybox/README.md","hash":"8286582ed7c338fce8bb03566b769fba378bce83","modified":1595148214247},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1593857339039},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1593857339039},{"_id":"themes/next/.git_bak/logs/refs/heads/master","hash":"c6061cb06758c3c5ad7af34c0db7588ca51dcdf7","modified":1593857338935},{"_id":"themes/next/.git_bak/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1593857338932},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1593857338998},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1593857338999},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1593857338998},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1593857339008},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1593857339014},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1593857339015},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1593857339018},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1593857339018},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1593857339018},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1593857339020},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1593857339020},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1593857339023},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1593857339024},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1593857339021},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1593857339021},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1593857339025},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1593857339024},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1593857339025},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1593857339024},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1593857339025},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1593857339025},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1593857339025},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1593857339026},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1593857339026},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1593857339027},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1593857339026},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1593857339026},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1593857339027},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1593857339027},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1593857339027},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1593857339028},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1593857339027},{"_id":"themes/next/source/lib/fancybox/.git/config","hash":"0bd9061daa1ae14bc8c15ccb2616123858620669","modified":1595148214239},{"_id":"themes/next/source/lib/fancybox/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1595148214235},{"_id":"themes/next/source/lib/fancybox/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1595148191607},{"_id":"themes/next/source/lib/fancybox/.git/index","hash":"3d8a64930957b173af9d9655a3219b5b70e32ee1","modified":1595148214251},{"_id":"themes/next/source/lib/fancybox/.git/packed-refs","hash":"f0b53e687e79fcab7e1836dec921908302da45b9","modified":1595148214231},{"_id":"themes/next/source/lib/fancybox/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1595148214246},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"e43435fb9eaa918f5b8e35c9e110124b8bd13751","modified":1595148214248},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1595148214248},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1593857339038},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1595148214249},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1593857339036},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1593857339037},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1593857339038},{"_id":"themes/next/.git_bak/logs/refs/remotes/origin/HEAD","hash":"c6061cb06758c3c5ad7af34c0db7588ca51dcdf7","modified":1593857338932},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1593857339002},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1593857339003},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1593857339003},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1593857339004},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1593857339004},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1593857339005},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1593857339005},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1593857339005},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1593857339007},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1593857339007},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1593857339008},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1593857339006},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1593857338999},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1593857339000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1593857339007},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1593857339001},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1593857339000},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1593857339009},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1593857339001},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1593857339010},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1593857339009},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1593857339010},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1593857339011},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1593857339012},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1593857339013},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1593857339012},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1593857339013},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1593857339013},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1593857339014},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1593857339015},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1593857339015},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1593857339016},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1593857339014},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1593857339013},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1593857339016},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1593857339016},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1593857339016},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1593857339017},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1593857339019},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1593857339017},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1593857339018},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1593857339017},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1593857339019},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1593857339019},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1593857339020},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1593857339021},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1593857339022},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1593857339022},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1593857339022},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1593857339023},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1593857339023},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1593857339022},{"_id":"themes/next/source/lib/fancybox/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1595148191611},{"_id":"themes/next/source/lib/fancybox/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1595148191608},{"_id":"themes/next/source/lib/fancybox/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1595148191613},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1595148191614},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1595148191611},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1595148191615},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1595148191609},{"_id":"themes/next/source/lib/fancybox/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1595148191613},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1595148191612},{"_id":"themes/next/source/lib/fancybox/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1595148191616},{"_id":"themes/next/source/lib/fancybox/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1595148191606},{"_id":"themes/next/source/lib/fancybox/.git/logs/HEAD","hash":"a14eee48208ac3a9a5b2ae7f225966a916809aea","modified":1595148214237},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"27f034e5db8c32e268e2959b9a7c1258d36e4510","modified":1595148214250},{"_id":"themes/next/.git_bak/objects/pack/pack-86e2565862baf23d3242d9762d7e9890da3bd718.idx","hash":"c2f6240fb7b9c8e09988b3960493fdad157ad6e9","modified":1593857338911},{"_id":"themes/next/source/lib/fancybox/.git/objects/0c/dada082d621dbfdd00f7020c33dc751129167f","hash":"b490c11cdefde6b331a7d4ddb055e34ad08459d8","modified":1595148197084},{"_id":"themes/next/source/lib/fancybox/.git/objects/00/c03f6be011e8878608eec12f68caf42b73f38e","hash":"8516bd35bc8f9223e13de5877778c8d14d49d6db","modified":1595148214217},{"_id":"themes/next/source/lib/fancybox/.git/objects/19/3567a3107003507fafacd255c349857e417926","hash":"ef5eab75e8c6998cb223edb4eb8a26c4cfc9415c","modified":1595148212932},{"_id":"themes/next/source/lib/fancybox/.git/objects/16/b01254a56610f4c6b7721c534ed4fc40ae51dd","hash":"88ca5fd99322d3a4067e0711af79f41c078f2ef5","modified":1595148198440},{"_id":"themes/next/source/lib/fancybox/.git/objects/2f/9eba51ec174b1e0c719d12cafa7c3c07140471","hash":"fc994d9d8b3b21ec7c941eea7e3862970e297e9b","modified":1595148197086},{"_id":"themes/next/source/lib/fancybox/.git/objects/1f/a2c5f332b7e304431213aec21012e53f8781d7","hash":"7632806182aa989d3b7029579d5c03c34b113ee3","modified":1595148197078},{"_id":"themes/next/source/lib/fancybox/.git/objects/3d/521bfc64755e348870094e85323dc1b9c96a6b","hash":"e9660fc4f89ecb176b0ab6e4860579c1bfe9f9cb","modified":1595148205957},{"_id":"themes/next/source/lib/fancybox/.git/objects/36/9bab09306448a2970d378b59bb21c059edad63","hash":"877e0c15623d0d6ff8f09bb627fc60a489f3c105","modified":1595148198023},{"_id":"themes/next/source/lib/fancybox/.git/objects/40/9607f1ba381a64c3ccb8d5440299e8ef868ef8","hash":"a462f7a9efebb70c4051f92c09ccbd9885132c77","modified":1595148197075},{"_id":"themes/next/source/lib/fancybox/.git/objects/47/d427b6c52396bbab53a05f57aaa82b52c805b1","hash":"c5626bbb62f4d1d1e39034e7f44baf4c509410d6","modified":1595148205959},{"_id":"themes/next/source/lib/fancybox/.git/objects/54/0a7b36ee26decfc3f0f34bf73bc85c48899128","hash":"2e5447a9dd879d71368e9dddd34d93849d00b934","modified":1595148214219},{"_id":"themes/next/source/lib/fancybox/.git/objects/53/ceaabe0f8677333c5be196778b3e40840a1869","hash":"7bc1c1c42059d5402335b5293bfb5e54bee22557","modified":1595148197081},{"_id":"themes/next/source/lib/fancybox/.git/objects/51/cf05811ed7d35e92551db1ba5a6e267ce781a5","hash":"99c009035ea86e3876b586577677d4d62ae12379","modified":1595148205957},{"_id":"themes/next/source/lib/fancybox/.git/objects/64/c47e893a0fef71c8c0930975ef114d9812da56","hash":"eaad75fab15724f9c2b069fc1ce9b8216be149d7","modified":1595148198025},{"_id":"themes/next/source/lib/fancybox/.git/objects/63/c555caede30ab06d6dba16644a827e9574c8cb","hash":"846603220288272ad5d35ebdc3c917cc4adce424","modified":1595148197076},{"_id":"themes/next/source/lib/fancybox/.git/objects/7b/15d3cb03fda86241f8b2b335f04e9b9de0e1c4","hash":"d1fe3bd82c90f7d93874798a8ee8ebf1391d7207","modified":1595148209637},{"_id":"themes/next/source/lib/fancybox/.git/objects/78/068b93f813cecbbd50c8247de547035009d512","hash":"4bc2bee779bd7e3cca13ee34801cf1e12585e5ae","modified":1595148205958},{"_id":"themes/next/source/lib/fancybox/.git/objects/7c/c60b295fa2dcb82537a63792c9b3b3c2e74c33","hash":"b2dc23c71b13726c391aaefaa5312227a9b6ab7e","modified":1595148198441},{"_id":"themes/next/source/lib/fancybox/.git/objects/80/6b27034bd69d563e4243c2f12b43c7064b32dd","hash":"b7d3e8020767ae60a2029da8eccb0068623dc618","modified":1595148205955},{"_id":"themes/next/source/lib/fancybox/.git/objects/92/4369c371444afb18fb86309229f5b4c24c6cf4","hash":"9eb6fa8ff9081e6650f6bee350d21567df105737","modified":1595148212930},{"_id":"themes/next/source/lib/fancybox/.git/objects/7c/00ef8195b73793d477d22e723ecdac9553ebf3","hash":"fd8c4fd143b32fb3e86367f123feb7c35b305262","modified":1595148205949},{"_id":"themes/next/source/lib/fancybox/.git/objects/89/9d7a75b543fbed2a785f67d995bc77e06eb2e9","hash":"5651e2b80703225f642625c0fb2646543096d2cf","modified":1595148197079},{"_id":"themes/next/source/lib/fancybox/.git/objects/94/a9ed024d3859793618152ea559a168bbcbb5e2","hash":"1c2d080a86f03eb960e112a94910a5115addf57a","modified":1595148198022},{"_id":"themes/next/source/lib/fancybox/.git/objects/9b/fe9361836240600c1bcc3cab9d42b35e731fad","hash":"3d38ffc7ac1ae85224691ef15d7f32e40c40b3a2","modified":1595148198438},{"_id":"themes/next/source/lib/fancybox/.git/objects/aa/654e17af8c354994f706c4e33bba6b5b70caeb","hash":"22b1bdf0b0974bf5e9022953ac26066056c235ff","modified":1595148214215},{"_id":"themes/next/source/lib/fancybox/.git/objects/ac/97c2cc9f61c52753abe4174a4a74b2064e5af0","hash":"272e74036b0612de83d9d0aa9604d3edf888b249","modified":1595148209636},{"_id":"themes/next/source/lib/fancybox/.git/objects/ad/569256343419017e8832a38faaa1c786716a1d","hash":"0538e4abd112b0a843035f28a511edabbe73f2ce","modified":1595148197077},{"_id":"themes/next/source/lib/fancybox/.git/objects/b6/c361c8dcf2f5a7572e81b956272e4cfe1198c1","hash":"3e160c605dbd94dcef2b9692a4a5a82bddb76264","modified":1595148198024},{"_id":"themes/next/source/lib/fancybox/.git/objects/bd/e1f741357b44b49290d43fdd193125202fef81","hash":"9beefc75cc0c37d04e98dd13b51ad85df40e77b9","modified":1595148197083},{"_id":"themes/next/source/lib/fancybox/.git/objects/c2/fc5def1b6c38369e5e8b849adb956bd79b549e","hash":"27f03b9616e615b2724bac0fa4507d152697f3f1","modified":1595148197080},{"_id":"themes/next/source/lib/fancybox/.git/objects/ce/c0e316bee5d497ee834dbd29e0c5aad8331052","hash":"3d769fa5f55014841d10bb3bdf1b9725c43e9043","modified":1595148197082},{"_id":"themes/next/source/lib/fancybox/.git/objects/b3/b3098638624b56be968573e2dab1684f8a7f06","hash":"6fa11a2d904dff2b8f4ae1bd88bdbb66736438a1","modified":1595148201346},{"_id":"themes/next/source/lib/fancybox/.git/objects/d5/d10f6be62acc10fec6e11e8dc4affe1184a17b","hash":"cec51b2539349d2aba1ec5d11eaded3815eccdc5","modified":1595148201348},{"_id":"themes/next/source/lib/fancybox/.git/objects/f6/bb280a0b2c68256a8e906b35c6976c80c1b3be","hash":"5daaee11fc384fbe0f02c7123036c954ee9a73fd","modified":1595148197084},{"_id":"themes/next/source/lib/fancybox/.git/refs/heads/master","hash":"0b56bdb897316a3b4ec6c120673249f65f4cb420","modified":1595148214237},{"_id":"themes/next/source/lib/fancybox/.git/logs/refs/heads/master","hash":"a14eee48208ac3a9a5b2ae7f225966a916809aea","modified":1595148214238},{"_id":"themes/next/source/lib/fancybox/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1595148214234},{"_id":"source/images/connection-handler-1.jpg","hash":"92bcdd71f0a568d4403763cd742094e0ef6736bf","modified":1595169913336},{"_id":"themes/next/source/lib/fancybox/.git/logs/refs/remotes/origin/HEAD","hash":"a14eee48208ac3a9a5b2ae7f225966a916809aea","modified":1595148214234},{"_id":"themes/next/.git_bak/objects/pack/pack-86e2565862baf23d3242d9762d7e9890da3bd718.pack","hash":"ce1356563957c2df9e5122a60ede12756fab94ce","modified":1593857338903},{"_id":"public/archives/index.html","hash":"76da0150296bbd89d49ce63457fbcf10104c8217","modified":1603432545953},{"_id":"public/tags/index.html","hash":"3cf469ff862478ad0fd284aabed5b009d741d9ca","modified":1603432545953},{"_id":"public/categories/index.html","hash":"227f7769d9bc77cdeff74c895658d750555f0bfb","modified":1603432545953},{"_id":"public/2020/09/13/io-performance/index.html","hash":"f504f1254269832cfdfdcb5e0283edf8749d69c1","modified":1603432545953},{"_id":"public/2020/07/18/innodb-intro/index.html","hash":"1671f6cf76a31bcf11a8e4ff76d05c39c2012ebd","modified":1603432545953},{"_id":"public/categories/其它/index.html","hash":"45037cbc25d51b64675ed6f4f185b98381630b34","modified":1603432545953},{"_id":"public/categories/C/index.html","hash":"783b8da0bd1eb2daa9f11ee285d72498dcf6f7d6","modified":1603432545953},{"_id":"public/categories/数据库/index.html","hash":"82ba8f21342841e3a37ad953c3694319498d4f3f","modified":1603432545953},{"_id":"public/archives/page/2/index.html","hash":"63352ca1386fa6dd322dc3778703f72c323fbd50","modified":1603432545953},{"_id":"public/archives/2020/index.html","hash":"e23519830a7e816df259de2f6cf7bcf533470394","modified":1603432545953},{"_id":"public/archives/2020/page/2/index.html","hash":"3837546a5fd1c6582a052a46381b51f6c059577d","modified":1603432545953},{"_id":"public/archives/2020/07/index.html","hash":"492c40a0cd0d1d80abd300a5c862069c0243f5cb","modified":1603432545953},{"_id":"public/archives/2020/07/page/2/index.html","hash":"3d67e3bf82be0c6e3ea1e230898c6150dd3ca263","modified":1603432545953},{"_id":"public/archives/2020/08/index.html","hash":"6ece018769e187caea749e598990feb7e4248b4d","modified":1603432545953},{"_id":"public/archives/2020/09/index.html","hash":"73d252d59ad4d1a865a1ac425a4f22156268a3e9","modified":1603432545953},{"_id":"public/tags/MySQL/index.html","hash":"1abe87861372e3cd39a7ab24262bb4e4a5823322","modified":1603432545953},{"_id":"public/tags/InnoDB/index.html","hash":"4e94d2a209c18f32acde1d335bfb1805bd674277","modified":1603432545953},{"_id":"public/tags/Linux/index.html","hash":"514ac3ca5e62b68de60f478e2c3ec3856f6758bd","modified":1603432545953},{"_id":"public/tags/事务/index.html","hash":"4daae746012ddfbea3ad70942bd0edf42f24f841","modified":1603432545953},{"_id":"public/2020/08/23/innodb-buffer-page/index.html","hash":"02fefa4864f5b0100b619c04686bbf17338ade7d","modified":1603432545953},{"_id":"public/2020/07/18/cgroup-linux/index.html","hash":"d4056f49848b179d63aa010fa276dfc026d8522b","modified":1603432545953},{"_id":"public/2020/07/18/tcpdump-linux/index.html","hash":"cc8fe63f50cfed4c0868aa0c288a691ef590ecfa","modified":1603432545953},{"_id":"public/2020/07/17/lf_hash/index.html","hash":"8be23b3c60f06d72262f4fe0d33965ff36beece2","modified":1603432545953},{"_id":"public/2020/07/18/perf-linux/index.html","hash":"7a3b27158cd209f03960a6ff650dbc77dc7f9e35","modified":1603432545953},{"_id":"public/2020/07/17/cplusplus-lock/index.html","hash":"0d12c7a9c73a6db2217fc192619a1995564b7f70","modified":1603432545953},{"_id":"public/2020/07/17/x-plugin/index.html","hash":"2aee84ded7711dae4d405ca7f5c9083927ecd8d7","modified":1603432545953},{"_id":"public/2020/07/13/transaction-intro/index.html","hash":"8842e4df271e11e21bd7e1710395769da0eea6ce","modified":1603432545953},{"_id":"public/2020/07/04/sql-execute/index.html","hash":"6b39f4cf830c9b51434c3c924e5c8a383fa12870","modified":1603432545953},{"_id":"public/2020/07/15/connection-handler/index.html","hash":"1c5427588b821bf21ef2faa6cf045671f93e0779","modified":1603432545953},{"_id":"public/2020/07/04/menu/index.html","hash":"d0fae0e3d87efd335f71eefff07a9cd80f9c67e7","modified":1603432545953},{"_id":"public/index.html","hash":"21bf7a0474889288996c50452267b71ef50b0f07","modified":1603432545953},{"_id":"public/page/2/index.html","hash":"b9d13d2a7b061ca5adb2589d118809289dce8734","modified":1603432545953},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1603432545953},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1603432545953},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1603432545953},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1603432545953},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1603432545953},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1603432545953},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1603432545953},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1603432545953},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1603432545953},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1603432545953},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1603432545953},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1603432545953},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1603432545953},{"_id":"public/lib/fancybox/LICENSE","hash":"8624bcdae55baeef00cd11d5dfcfa60f68710a02","modified":1603432545953},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1603432545953},{"_id":"public/images/sql-execute-1.jpg","hash":"de7bb4171af4fac85259ef6a229c6c8fd4cd245c","modified":1603432545953},{"_id":"public/images/avatar.jpg","hash":"e7980d215c86bd4ac681991ae0d6ac2f526d3824","modified":1603432545953},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1603432545953},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1603432545953},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1603432545953},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1603432545953},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1603432545953},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1603432545953},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1603432545953},{"_id":"public/js/utils.js","hash":"2c6e6b4d9a592fbb4bf04689524db2cdfcd94ca7","modified":1603432545953},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1603432545953},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1603432545953},{"_id":"public/lib/fancybox/source/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1603432545953},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1603432545953},{"_id":"public/lib/fancybox/README.html","hash":"ef332d1b78e923c8ba02c84f37e966c0fd8bb6c5","modified":1603432545953},{"_id":"public/css/main.css","hash":"5d270b5666c6d83030beef786bc9b71ed7bf113d","modified":1603432545953},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1603432545953},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"e43435fb9eaa918f5b8e35c9e110124b8bd13751","modified":1603432545953},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1603432545953},{"_id":"public/lib/fancybox/source/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1603432545953},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1603432545953},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"27f034e5db8c32e268e2959b9a7c1258d36e4510","modified":1603432545953},{"_id":"public/images/innodb-intro.png","hash":"fdbf2c8bff19fdc7ab07f5abdb3b8aec0ca995b8","modified":1603432545953},{"_id":"public/images/connection-handler-1.jpg","hash":"92bcdd71f0a568d4403763cd742094e0ef6736bf","modified":1603432545953}],"Category":[{"name":"其它","_id":"ckgluc7290004owgm10zbes9o"},{"name":"C++","_id":"ckgluc72e000aowgmb5y3bd68"},{"name":"数据库","_id":"ckgluc72m000lowgmbyuv7c0g"}],"Data":[],"Page":[{"title":"archives","date":"2020-07-04T03:27:53.000Z","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2020-07-04 11:27:53\n---\n","updated":"2020-07-04T04:50:40.368Z","path":"archives/index.html","comments":1,"layout":"page","_id":"ckgluc7270001owgm34z8daoj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","date":"2020-07-04T06:10:13.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2020-07-04 14:10:13\ntype: \"categories\"\n---\n","updated":"2020-07-04T11:18:32.927Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckgluc7280003owgm30oj837l","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2020-07-04T03:22:07.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2020-07-04 11:22:07\ntype: \"tags\"\n---\n","updated":"2020-07-04T11:19:15.878Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckgluc72c0007owgm0r5hanl7","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"cgroups 使用简介","date":"2020-07-18T13:03:55.000Z","_content":"\ncgroups 是 Linux 内核提供的一种可以限制、记录、隔离进程组所使用的物理资源的机制，本文简单介绍下 cgroups 的使用情况。\n\n<!-- more -->\n\n## cgroups 原理\n\ncgroups 的实现本质上是给系统进程挂上钩子（hooks），在 task 运行的过程中涉及到某个资源时就会触发钩子上所附带的 subsystem 进行检测，最终根据资源类别的不同使用对应的技术进行资源限制和优先级分配。cgroups 的目的是将任意进程进行分组化管理。\n\n> https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/index\n\n### 基本概念\n\ncgroups 主要由 task，cgroup，subsystem 以及 hierarchy 组成\n\n- task（任务）：在 cgroups 中，任务就是系统的一个进程；\n- cgroup （控制族群）：控制族群是一组按照某种标准划分的进程，cgroups 中的资源控制都是以控制族群为单位实现的。一个进程可以加入某个控制族群，也可以迁移至另一个控制族群；\n- hierarchy（层级）：控制族群可以组织成层级的形式，即一颗控制族群树,其上的子节点继承父节点的特定属性（cgroup 结构树）；\n- subsystem（子系统）：通常是一个资源控制器，例如 CPU 子系统可以控制 CPU 时间分配，一个子系统必须附加到控制族群树上才能起作用，该树上的所有控制族群都受到该子系统的控制；\n\n### 子系统\n\nsubsystem 实际上就是 cgroups 的资源控制系统，每种 subsystem 独立地控制一种资源，常见的子系统如下：\n\n- cpu：使用调度程序控制 task 对 CPU 的使用；\n- cpuset：可以为 cgroup 中的 task 分配独立的 CPU（此处针对多处理器系统）和内存；\n- memory：可以设定 cgroup 中 task 对内存使用量的限定；\n- blkio：可以为块设备设定输入/输出限制，比如物理驱动设备（包括磁盘、固态硬盘、USB等）；\n\n## cgroup 使用\n\n```shell\n# 关键信息\n1. cat /proc/cgroups 查看当前 cgroup 运行情况\n2. mount | grep cgroup 查看 cgroup 挂载情况\n3. cgroup 内的节点保持继承关系，子目录自动继承父目录的规则\n4. 删除 cgroup 下的目录时，不能直接 rm -rf ，需要使用 rmdir\n5. 通过规则目录下的 cgroup.procs 与进程进行绑定，限定进程的资源\n```\n\n### CPU 隔离\n\nCPU 隔离有两种模式：共享模式和独享模式，其中共享模式：\n\n1. 通过 cpu 子系统进行限制，/cgroup/cpu/xxx\n2. 主要由以下文件进行配置：\n\n```\n-rw-r--r-- 1 root root 0 Sep 23 14:54 cpu.cfs_period_us\n-rw-r--r-- 1 root root 0 Sep 23 14:54 cpu.cfs_quota_us\n```\n\n独享模式：\n\n1. 通过 cpuset 子系统进行限制，/cgroup/cpuset/xxx\n2. 主要由以下文件进行配置：\n\n```\n-rw-r--r-- 1 root root 0 Sep 23 14:45 cpuset.cpus\n```\n\n注：\n\n1. cfs_period_us 用来配置时间周期长度，cfs_quota_us 用来配置当前 cgroup 在设置的周期长度内所能使用的 CPU 时间数。cfs_quota_us/cfs_period_us 可以当做是对应的核数限制；\n2. cpuset.cpus 需要设置成全部核，cpuset.mems 需要设置为 0；\n3. 通过 cgroup.procs 与进程进行绑定；\n4. cpuset.cpus 里直接绑定 cpu 核，cpu 核的信息可以通过 /proc/cpuinfo 进行查看；\n\n### Memory 隔离\n\nMemory 的隔离：\n\n1. 通过 memory 子系统进行限制，/cgroup/memory/xxx\n2. 主要由以下文件进行配置：\n\n```\n-rw-r--r-- 1 root root 0 Sep 23 14:54 memory.limit_in_bytes\n```\n\n注：memory.oom_control文件用来配置当内存超出限制后的是否需要kill申请内存的进程。\n\n### IOPS 限制\n\nIOPS 的隔离：\n\n1. 通过 blkio 子系统进行限制，/cgroup/blkio/xxx\n2. 主要由以下文件进行配置：\n\n```\n-rw-r--r-- 1 root root 0 Nov 19 16:41 blkio.throttle.read_iops_device\n-rw-r--r-- 1 root root 0 Nov 19 16:41 blkio.throttle.write_iops_device\n```\n\n注：与内存限制不同的是，IOPS 的限制其实是对于块设备的 IO 限制，所以配置文件中会指明对应的设备 ID。\n\n### 参考文献\n\n> https://staight.github.io/2019/03/07/linux资源管理器-cgroups理解\n>\n> https://segmentfault.com/a/1190000006917884\n>\n> https://segmentfault.com/a/1190000007241437\n>\n> https://segmentfault.com/a/1190000008125359\n>\n> https://segmentfault.com/a/1190000008323952","source":"_posts/cgroup-linux.md","raw":"---\ntitle: cgroups 使用简介\ndate: 2020-07-18 21:03:55\ntags:\n- Linux\ncategories: \n- 其它\n---\n\ncgroups 是 Linux 内核提供的一种可以限制、记录、隔离进程组所使用的物理资源的机制，本文简单介绍下 cgroups 的使用情况。\n\n<!-- more -->\n\n## cgroups 原理\n\ncgroups 的实现本质上是给系统进程挂上钩子（hooks），在 task 运行的过程中涉及到某个资源时就会触发钩子上所附带的 subsystem 进行检测，最终根据资源类别的不同使用对应的技术进行资源限制和优先级分配。cgroups 的目的是将任意进程进行分组化管理。\n\n> https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/index\n\n### 基本概念\n\ncgroups 主要由 task，cgroup，subsystem 以及 hierarchy 组成\n\n- task（任务）：在 cgroups 中，任务就是系统的一个进程；\n- cgroup （控制族群）：控制族群是一组按照某种标准划分的进程，cgroups 中的资源控制都是以控制族群为单位实现的。一个进程可以加入某个控制族群，也可以迁移至另一个控制族群；\n- hierarchy（层级）：控制族群可以组织成层级的形式，即一颗控制族群树,其上的子节点继承父节点的特定属性（cgroup 结构树）；\n- subsystem（子系统）：通常是一个资源控制器，例如 CPU 子系统可以控制 CPU 时间分配，一个子系统必须附加到控制族群树上才能起作用，该树上的所有控制族群都受到该子系统的控制；\n\n### 子系统\n\nsubsystem 实际上就是 cgroups 的资源控制系统，每种 subsystem 独立地控制一种资源，常见的子系统如下：\n\n- cpu：使用调度程序控制 task 对 CPU 的使用；\n- cpuset：可以为 cgroup 中的 task 分配独立的 CPU（此处针对多处理器系统）和内存；\n- memory：可以设定 cgroup 中 task 对内存使用量的限定；\n- blkio：可以为块设备设定输入/输出限制，比如物理驱动设备（包括磁盘、固态硬盘、USB等）；\n\n## cgroup 使用\n\n```shell\n# 关键信息\n1. cat /proc/cgroups 查看当前 cgroup 运行情况\n2. mount | grep cgroup 查看 cgroup 挂载情况\n3. cgroup 内的节点保持继承关系，子目录自动继承父目录的规则\n4. 删除 cgroup 下的目录时，不能直接 rm -rf ，需要使用 rmdir\n5. 通过规则目录下的 cgroup.procs 与进程进行绑定，限定进程的资源\n```\n\n### CPU 隔离\n\nCPU 隔离有两种模式：共享模式和独享模式，其中共享模式：\n\n1. 通过 cpu 子系统进行限制，/cgroup/cpu/xxx\n2. 主要由以下文件进行配置：\n\n```\n-rw-r--r-- 1 root root 0 Sep 23 14:54 cpu.cfs_period_us\n-rw-r--r-- 1 root root 0 Sep 23 14:54 cpu.cfs_quota_us\n```\n\n独享模式：\n\n1. 通过 cpuset 子系统进行限制，/cgroup/cpuset/xxx\n2. 主要由以下文件进行配置：\n\n```\n-rw-r--r-- 1 root root 0 Sep 23 14:45 cpuset.cpus\n```\n\n注：\n\n1. cfs_period_us 用来配置时间周期长度，cfs_quota_us 用来配置当前 cgroup 在设置的周期长度内所能使用的 CPU 时间数。cfs_quota_us/cfs_period_us 可以当做是对应的核数限制；\n2. cpuset.cpus 需要设置成全部核，cpuset.mems 需要设置为 0；\n3. 通过 cgroup.procs 与进程进行绑定；\n4. cpuset.cpus 里直接绑定 cpu 核，cpu 核的信息可以通过 /proc/cpuinfo 进行查看；\n\n### Memory 隔离\n\nMemory 的隔离：\n\n1. 通过 memory 子系统进行限制，/cgroup/memory/xxx\n2. 主要由以下文件进行配置：\n\n```\n-rw-r--r-- 1 root root 0 Sep 23 14:54 memory.limit_in_bytes\n```\n\n注：memory.oom_control文件用来配置当内存超出限制后的是否需要kill申请内存的进程。\n\n### IOPS 限制\n\nIOPS 的隔离：\n\n1. 通过 blkio 子系统进行限制，/cgroup/blkio/xxx\n2. 主要由以下文件进行配置：\n\n```\n-rw-r--r-- 1 root root 0 Nov 19 16:41 blkio.throttle.read_iops_device\n-rw-r--r-- 1 root root 0 Nov 19 16:41 blkio.throttle.write_iops_device\n```\n\n注：与内存限制不同的是，IOPS 的限制其实是对于块设备的 IO 限制，所以配置文件中会指明对应的设备 ID。\n\n### 参考文献\n\n> https://staight.github.io/2019/03/07/linux资源管理器-cgroups理解\n>\n> https://segmentfault.com/a/1190000006917884\n>\n> https://segmentfault.com/a/1190000007241437\n>\n> https://segmentfault.com/a/1190000008125359\n>\n> https://segmentfault.com/a/1190000008323952","slug":"cgroup-linux","published":1,"updated":"2020-07-18T13:37:39.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgluc7210000owgmat85e1k9","content":"<p>cgroups 是 Linux 内核提供的一种可以限制、记录、隔离进程组所使用的物理资源的机制，本文简单介绍下 cgroups 的使用情况。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"cgroups-原理\"><a href=\"#cgroups-原理\" class=\"headerlink\" title=\"cgroups 原理\"></a>cgroups 原理</h2><p>cgroups 的实现本质上是给系统进程挂上钩子（hooks），在 task 运行的过程中涉及到某个资源时就会触发钩子上所附带的 subsystem 进行检测，最终根据资源类别的不同使用对应的技术进行资源限制和优先级分配。cgroups 的目的是将任意进程进行分组化管理。</p>\n<blockquote>\n<p><a href=\"https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/index\" target=\"_blank\" rel=\"noopener\">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/index</a></p>\n</blockquote>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>cgroups 主要由 task，cgroup，subsystem 以及 hierarchy 组成</p>\n<ul>\n<li>task（任务）：在 cgroups 中，任务就是系统的一个进程；</li>\n<li>cgroup （控制族群）：控制族群是一组按照某种标准划分的进程，cgroups 中的资源控制都是以控制族群为单位实现的。一个进程可以加入某个控制族群，也可以迁移至另一个控制族群；</li>\n<li>hierarchy（层级）：控制族群可以组织成层级的形式，即一颗控制族群树,其上的子节点继承父节点的特定属性（cgroup 结构树）；</li>\n<li>subsystem（子系统）：通常是一个资源控制器，例如 CPU 子系统可以控制 CPU 时间分配，一个子系统必须附加到控制族群树上才能起作用，该树上的所有控制族群都受到该子系统的控制；</li>\n</ul>\n<h3 id=\"子系统\"><a href=\"#子系统\" class=\"headerlink\" title=\"子系统\"></a>子系统</h3><p>subsystem 实际上就是 cgroups 的资源控制系统，每种 subsystem 独立地控制一种资源，常见的子系统如下：</p>\n<ul>\n<li>cpu：使用调度程序控制 task 对 CPU 的使用；</li>\n<li>cpuset：可以为 cgroup 中的 task 分配独立的 CPU（此处针对多处理器系统）和内存；</li>\n<li>memory：可以设定 cgroup 中 task 对内存使用量的限定；</li>\n<li>blkio：可以为块设备设定输入/输出限制，比如物理驱动设备（包括磁盘、固态硬盘、USB等）；</li>\n</ul>\n<h2 id=\"cgroup-使用\"><a href=\"#cgroup-使用\" class=\"headerlink\" title=\"cgroup 使用\"></a>cgroup 使用</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 关键信息</span></span><br><span class=\"line\">1. cat /proc/cgroups 查看当前 cgroup 运行情况</span><br><span class=\"line\">2. mount | grep cgroup 查看 cgroup 挂载情况</span><br><span class=\"line\">3. cgroup 内的节点保持继承关系，子目录自动继承父目录的规则</span><br><span class=\"line\">4. 删除 cgroup 下的目录时，不能直接 rm -rf ，需要使用 rmdir</span><br><span class=\"line\">5. 通过规则目录下的 cgroup.procs 与进程进行绑定，限定进程的资源</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CPU-隔离\"><a href=\"#CPU-隔离\" class=\"headerlink\" title=\"CPU 隔离\"></a>CPU 隔离</h3><p>CPU 隔离有两种模式：共享模式和独享模式，其中共享模式：</p>\n<ol>\n<li>通过 cpu 子系统进行限制，/cgroup/cpu/xxx</li>\n<li>主要由以下文件进行配置：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 root root 0 Sep 23 14:54 cpu.cfs_period_us</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 Sep 23 14:54 cpu.cfs_quota_us</span><br></pre></td></tr></table></figure>\n\n<p>独享模式：</p>\n<ol>\n<li>通过 cpuset 子系统进行限制，/cgroup/cpuset/xxx</li>\n<li>主要由以下文件进行配置：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 root root 0 Sep 23 14:45 cpuset.cpus</span><br></pre></td></tr></table></figure>\n\n<p>注：</p>\n<ol>\n<li>cfs_period_us 用来配置时间周期长度，cfs_quota_us 用来配置当前 cgroup 在设置的周期长度内所能使用的 CPU 时间数。cfs_quota_us/cfs_period_us 可以当做是对应的核数限制；</li>\n<li>cpuset.cpus 需要设置成全部核，cpuset.mems 需要设置为 0；</li>\n<li>通过 cgroup.procs 与进程进行绑定；</li>\n<li>cpuset.cpus 里直接绑定 cpu 核，cpu 核的信息可以通过 /proc/cpuinfo 进行查看；</li>\n</ol>\n<h3 id=\"Memory-隔离\"><a href=\"#Memory-隔离\" class=\"headerlink\" title=\"Memory 隔离\"></a>Memory 隔离</h3><p>Memory 的隔离：</p>\n<ol>\n<li>通过 memory 子系统进行限制，/cgroup/memory/xxx</li>\n<li>主要由以下文件进行配置：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 root root 0 Sep 23 14:54 memory.limit_in_bytes</span><br></pre></td></tr></table></figure>\n\n<p>注：memory.oom_control文件用来配置当内存超出限制后的是否需要kill申请内存的进程。</p>\n<h3 id=\"IOPS-限制\"><a href=\"#IOPS-限制\" class=\"headerlink\" title=\"IOPS 限制\"></a>IOPS 限制</h3><p>IOPS 的隔离：</p>\n<ol>\n<li>通过 blkio 子系统进行限制，/cgroup/blkio/xxx</li>\n<li>主要由以下文件进行配置：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 root root 0 Nov 19 16:41 blkio.throttle.read_iops_device</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 Nov 19 16:41 blkio.throttle.write_iops_device</span><br></pre></td></tr></table></figure>\n\n<p>注：与内存限制不同的是，IOPS 的限制其实是对于块设备的 IO 限制，所以配置文件中会指明对应的设备 ID。</p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><blockquote>\n<p><a href=\"https://staight.github.io/2019/03/07/linux资源管理器-cgroups理解\" target=\"_blank\" rel=\"noopener\">https://staight.github.io/2019/03/07/linux资源管理器-cgroups理解</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000006917884\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000006917884</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000007241437\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000007241437</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000008125359\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000008125359</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000008323952\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000008323952</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>cgroups 是 Linux 内核提供的一种可以限制、记录、隔离进程组所使用的物理资源的机制，本文简单介绍下 cgroups 的使用情况。</p>","more":"<h2 id=\"cgroups-原理\"><a href=\"#cgroups-原理\" class=\"headerlink\" title=\"cgroups 原理\"></a>cgroups 原理</h2><p>cgroups 的实现本质上是给系统进程挂上钩子（hooks），在 task 运行的过程中涉及到某个资源时就会触发钩子上所附带的 subsystem 进行检测，最终根据资源类别的不同使用对应的技术进行资源限制和优先级分配。cgroups 的目的是将任意进程进行分组化管理。</p>\n<blockquote>\n<p><a href=\"https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/index\" target=\"_blank\" rel=\"noopener\">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/index</a></p>\n</blockquote>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>cgroups 主要由 task，cgroup，subsystem 以及 hierarchy 组成</p>\n<ul>\n<li>task（任务）：在 cgroups 中，任务就是系统的一个进程；</li>\n<li>cgroup （控制族群）：控制族群是一组按照某种标准划分的进程，cgroups 中的资源控制都是以控制族群为单位实现的。一个进程可以加入某个控制族群，也可以迁移至另一个控制族群；</li>\n<li>hierarchy（层级）：控制族群可以组织成层级的形式，即一颗控制族群树,其上的子节点继承父节点的特定属性（cgroup 结构树）；</li>\n<li>subsystem（子系统）：通常是一个资源控制器，例如 CPU 子系统可以控制 CPU 时间分配，一个子系统必须附加到控制族群树上才能起作用，该树上的所有控制族群都受到该子系统的控制；</li>\n</ul>\n<h3 id=\"子系统\"><a href=\"#子系统\" class=\"headerlink\" title=\"子系统\"></a>子系统</h3><p>subsystem 实际上就是 cgroups 的资源控制系统，每种 subsystem 独立地控制一种资源，常见的子系统如下：</p>\n<ul>\n<li>cpu：使用调度程序控制 task 对 CPU 的使用；</li>\n<li>cpuset：可以为 cgroup 中的 task 分配独立的 CPU（此处针对多处理器系统）和内存；</li>\n<li>memory：可以设定 cgroup 中 task 对内存使用量的限定；</li>\n<li>blkio：可以为块设备设定输入/输出限制，比如物理驱动设备（包括磁盘、固态硬盘、USB等）；</li>\n</ul>\n<h2 id=\"cgroup-使用\"><a href=\"#cgroup-使用\" class=\"headerlink\" title=\"cgroup 使用\"></a>cgroup 使用</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 关键信息</span></span><br><span class=\"line\">1. cat /proc/cgroups 查看当前 cgroup 运行情况</span><br><span class=\"line\">2. mount | grep cgroup 查看 cgroup 挂载情况</span><br><span class=\"line\">3. cgroup 内的节点保持继承关系，子目录自动继承父目录的规则</span><br><span class=\"line\">4. 删除 cgroup 下的目录时，不能直接 rm -rf ，需要使用 rmdir</span><br><span class=\"line\">5. 通过规则目录下的 cgroup.procs 与进程进行绑定，限定进程的资源</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CPU-隔离\"><a href=\"#CPU-隔离\" class=\"headerlink\" title=\"CPU 隔离\"></a>CPU 隔离</h3><p>CPU 隔离有两种模式：共享模式和独享模式，其中共享模式：</p>\n<ol>\n<li>通过 cpu 子系统进行限制，/cgroup/cpu/xxx</li>\n<li>主要由以下文件进行配置：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 root root 0 Sep 23 14:54 cpu.cfs_period_us</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 Sep 23 14:54 cpu.cfs_quota_us</span><br></pre></td></tr></table></figure>\n\n<p>独享模式：</p>\n<ol>\n<li>通过 cpuset 子系统进行限制，/cgroup/cpuset/xxx</li>\n<li>主要由以下文件进行配置：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 root root 0 Sep 23 14:45 cpuset.cpus</span><br></pre></td></tr></table></figure>\n\n<p>注：</p>\n<ol>\n<li>cfs_period_us 用来配置时间周期长度，cfs_quota_us 用来配置当前 cgroup 在设置的周期长度内所能使用的 CPU 时间数。cfs_quota_us/cfs_period_us 可以当做是对应的核数限制；</li>\n<li>cpuset.cpus 需要设置成全部核，cpuset.mems 需要设置为 0；</li>\n<li>通过 cgroup.procs 与进程进行绑定；</li>\n<li>cpuset.cpus 里直接绑定 cpu 核，cpu 核的信息可以通过 /proc/cpuinfo 进行查看；</li>\n</ol>\n<h3 id=\"Memory-隔离\"><a href=\"#Memory-隔离\" class=\"headerlink\" title=\"Memory 隔离\"></a>Memory 隔离</h3><p>Memory 的隔离：</p>\n<ol>\n<li>通过 memory 子系统进行限制，/cgroup/memory/xxx</li>\n<li>主要由以下文件进行配置：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 root root 0 Sep 23 14:54 memory.limit_in_bytes</span><br></pre></td></tr></table></figure>\n\n<p>注：memory.oom_control文件用来配置当内存超出限制后的是否需要kill申请内存的进程。</p>\n<h3 id=\"IOPS-限制\"><a href=\"#IOPS-限制\" class=\"headerlink\" title=\"IOPS 限制\"></a>IOPS 限制</h3><p>IOPS 的隔离：</p>\n<ol>\n<li>通过 blkio 子系统进行限制，/cgroup/blkio/xxx</li>\n<li>主要由以下文件进行配置：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 root root 0 Nov 19 16:41 blkio.throttle.read_iops_device</span><br><span class=\"line\">-rw-r--r-- 1 root root 0 Nov 19 16:41 blkio.throttle.write_iops_device</span><br></pre></td></tr></table></figure>\n\n<p>注：与内存限制不同的是，IOPS 的限制其实是对于块设备的 IO 限制，所以配置文件中会指明对应的设备 ID。</p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><blockquote>\n<p><a href=\"https://staight.github.io/2019/03/07/linux资源管理器-cgroups理解\" target=\"_blank\" rel=\"noopener\">https://staight.github.io/2019/03/07/linux资源管理器-cgroups理解</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000006917884\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000006917884</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000007241437\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000007241437</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000008125359\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000008125359</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000008323952\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000008323952</a></p>\n</blockquote>"},{"title":"MySQL 中几种锁的使用","date":"2020-07-17T14:49:43.000Z","_content":"\nMySQL 中常用的几种锁包括：mysql_rwlock_t、mysql_mutex_t、mysql_cond_t，本文结合 MySQL 源码对各种锁的使用做一个简单的总结。\n\n<!-- more -->\n\n## mysql_rwlock_t\n\n### 数据结构\n\n```c++\n/**\n  Type of an instrumented rwlock.\n  @c mysql_rwlock_t is a drop-in replacement for @c pthread_rwlock_t.\n  @sa mysql_rwlock_init\n  @sa mysql_rwlock_rdlock\n  @sa mysql_rwlock_tryrdlock\n  @sa mysql_rwlock_wrlock\n  @sa mysql_rwlock_trywrlock\n  @sa mysql_rwlock_unlock\n  @sa mysql_rwlock_destroy\n*/\ntypedef struct st_mysql_rwlock mysql_rwlock_t;\n\nstruct st_mysql_rwlock\n{\n  /** The real rwlock */\n  native_rw_lock_t m_rwlock;\n  /**\n    The instrumentation hook.\n    Note that this hook is not conditionally defined,\n    for binary compatibility of the @c mysql_rwlock_t interface.\n  */\n  struct PSI_rwlock *m_psi;\n};\n\ntypedef pthread_rwlock_t native_rw_lock_t;\n```\n\n### 使用方式\n\n```c++\nPSI_rwlock_key key_rwlock_LOCK_xxx;\nmysql_rwlock_t m_lock;\n\nmysql_rwlock_init(key_rwlock_LOCK_xxx, &m_lock);\n\nmysql_rwlock_rdlock(&m_lock);\nmysql_rwlock_wrlock(&m_lock);\nmysql_rwlock_trywrlock(&m_lock);\nmysql_rwlock_unlock(&m_lock);\n\nmysql_rwlock_destroy(&m_lock);\n```\n\n### 说明\n\nmysql_rwlock_t 基本上可以看作是对 pthread_rwlock_t 的一个封装，pthread_rwlock_t 是读写锁，同时可以有多个线程获得读锁，同时只允许有一个线程获得写锁。其他线程在等待锁的时候同样会进入睡眠。读写锁在互斥锁的基础上，允许多个线程读，在某些场景下能提高性能。\n\n## mysql_mutex_t\n\n### 数据结构\n\n```c++\n/**\n  Type of an instrumented mutex.\n  @c mysql_mutex_t is a drop-in replacement for @c my_mutex_t.\n  @sa mysql_mutex_assert_owner\n  @sa mysql_mutex_assert_not_owner\n  @sa mysql_mutex_init\n  @sa mysql_mutex_lock\n  @sa mysql_mutex_unlock\n  @sa mysql_mutex_destroy\n*/\ntypedef struct st_mysql_mutex mysql_mutex_t;\n\nstruct st_mysql_mutex\n{\n  /** The real mutex. */\n  my_mutex_t m_mutex;\n  /**\n    The instrumentation hook.\n    Note that this hook is not conditionally defined,\n    for binary compatibility of the @c mysql_mutex_t interface.\n  */\n  struct PSI_mutex *m_psi;\n};\n\ntypedef native_mutex_t my_mutex_t;\n\ntypedef pthread_mutex_t native_mutex_t;\n```\n\n### 使用方式\n\n```c++\nPSI_mutex_key key_LOCK_xxx;\nmysql_mutex_t m_lock;\n\nmysql_mutex_init(key_LOCK_xxx, &m_lock, NULL);\n\nmysql_mutex_lock(&m_lock);\nmysql_mutex_unlock(&m_lock);\n\nmysql_mutex_destroy(&m_lock);\n```\n\n### 使用技巧\n\n1. Thread 如果已经获得了 mutex， 那么如果再次 lock 的话，会产生死锁，所以 MySQL 内部大量的 mutex_owner 判断逻辑（ mysql_mutex_assert_owner(&m_mutex) ）；\n2. 与1类似，可以在利用一个计数值来统计当前正在等到锁的线程个数，锁 owner 可以根据此计数值来判断是否需要释放锁。\n\n### 说明\n\nmysql_mutex_t 基本上可以看作是对 pthread_mutex_t 的一个封装，pthread_mutex_t 是互斥锁，同一瞬间只能有一个线程能够获取锁，其他线程在等待获取锁的时候会进入休眠状态。因此 pthread_mutex_t 消耗的 CPU 资源很小，但是性能不高，因为会引起线程切换。\n\n## mysql_cond_t\n\n### 数据结构\n\n```c++\n/**\n  Type of an instrumented condition.\n  @c mysql_cond_t is a drop-in replacement for @c pthread_cond_t.\n  @sa mysql_cond_init\n  @sa mysql_cond_wait\n  @sa mysql_cond_timedwait\n  @sa mysql_cond_signal\n  @sa mysql_cond_broadcast\n  @sa mysql_cond_destroy\n*/\ntypedef struct st_mysql_cond mysql_cond_t;\n\nstruct st_mysql_cond\n{\n  /** The real condition */\n  pthread_cond_t m_cond;\n  /**\n    The instrumentation hook.\n    Note that this hook is not conditionally defined,\n    for binary compatibility of the @c mysql_cond_t interface.\n  */\n  struct PSI_cond *m_psi;\n};\n```\n\n### 使用方式\n\n```c++\nPSI_cond_key key_COND_xxx;\nmysql_cond_t m_cond;\n\nmysql_cond_init(key_COND_xxx, &m_cond);\n\n// mysql_cond_t 需要与 mysql_mutex_t 配合使用\nstruct timespec abs_timeout;\nmysql_cond_timedwait(&m_cond, &m_mutex, &abs_timeout);\n\nmysql_cond_signal(&m_cond);\nmysql_cond_broadcast(&m_cond);\n\nmysql_cond_destroy(&m_cond);\n```\n\n## 补充\n\n除了 pthread_rwlock_t 和 pthread_mutex_t 之外，还有一个常用的锁 pthread_spinlock_t。pthread_spinlock_t 是自旋锁，同一瞬间也只能有一个线程能够获取锁，不同的是，其他线程在等待获取锁的过程中并不进入睡眠状态，而是在 CPU 上进入自旋等待。自旋锁的性能很高，但是只适合对很小的代码段加锁（或短期持有的锁），自旋锁对 CPU 的占用相对较高。","source":"_posts/cplusplus-lock.md","raw":"---\ntitle: MySQL 中几种锁的使用\ndate: 2020-07-17 22:49:43\ntags:\n- MySQL\ncategories: \n- C++\n---\n\nMySQL 中常用的几种锁包括：mysql_rwlock_t、mysql_mutex_t、mysql_cond_t，本文结合 MySQL 源码对各种锁的使用做一个简单的总结。\n\n<!-- more -->\n\n## mysql_rwlock_t\n\n### 数据结构\n\n```c++\n/**\n  Type of an instrumented rwlock.\n  @c mysql_rwlock_t is a drop-in replacement for @c pthread_rwlock_t.\n  @sa mysql_rwlock_init\n  @sa mysql_rwlock_rdlock\n  @sa mysql_rwlock_tryrdlock\n  @sa mysql_rwlock_wrlock\n  @sa mysql_rwlock_trywrlock\n  @sa mysql_rwlock_unlock\n  @sa mysql_rwlock_destroy\n*/\ntypedef struct st_mysql_rwlock mysql_rwlock_t;\n\nstruct st_mysql_rwlock\n{\n  /** The real rwlock */\n  native_rw_lock_t m_rwlock;\n  /**\n    The instrumentation hook.\n    Note that this hook is not conditionally defined,\n    for binary compatibility of the @c mysql_rwlock_t interface.\n  */\n  struct PSI_rwlock *m_psi;\n};\n\ntypedef pthread_rwlock_t native_rw_lock_t;\n```\n\n### 使用方式\n\n```c++\nPSI_rwlock_key key_rwlock_LOCK_xxx;\nmysql_rwlock_t m_lock;\n\nmysql_rwlock_init(key_rwlock_LOCK_xxx, &m_lock);\n\nmysql_rwlock_rdlock(&m_lock);\nmysql_rwlock_wrlock(&m_lock);\nmysql_rwlock_trywrlock(&m_lock);\nmysql_rwlock_unlock(&m_lock);\n\nmysql_rwlock_destroy(&m_lock);\n```\n\n### 说明\n\nmysql_rwlock_t 基本上可以看作是对 pthread_rwlock_t 的一个封装，pthread_rwlock_t 是读写锁，同时可以有多个线程获得读锁，同时只允许有一个线程获得写锁。其他线程在等待锁的时候同样会进入睡眠。读写锁在互斥锁的基础上，允许多个线程读，在某些场景下能提高性能。\n\n## mysql_mutex_t\n\n### 数据结构\n\n```c++\n/**\n  Type of an instrumented mutex.\n  @c mysql_mutex_t is a drop-in replacement for @c my_mutex_t.\n  @sa mysql_mutex_assert_owner\n  @sa mysql_mutex_assert_not_owner\n  @sa mysql_mutex_init\n  @sa mysql_mutex_lock\n  @sa mysql_mutex_unlock\n  @sa mysql_mutex_destroy\n*/\ntypedef struct st_mysql_mutex mysql_mutex_t;\n\nstruct st_mysql_mutex\n{\n  /** The real mutex. */\n  my_mutex_t m_mutex;\n  /**\n    The instrumentation hook.\n    Note that this hook is not conditionally defined,\n    for binary compatibility of the @c mysql_mutex_t interface.\n  */\n  struct PSI_mutex *m_psi;\n};\n\ntypedef native_mutex_t my_mutex_t;\n\ntypedef pthread_mutex_t native_mutex_t;\n```\n\n### 使用方式\n\n```c++\nPSI_mutex_key key_LOCK_xxx;\nmysql_mutex_t m_lock;\n\nmysql_mutex_init(key_LOCK_xxx, &m_lock, NULL);\n\nmysql_mutex_lock(&m_lock);\nmysql_mutex_unlock(&m_lock);\n\nmysql_mutex_destroy(&m_lock);\n```\n\n### 使用技巧\n\n1. Thread 如果已经获得了 mutex， 那么如果再次 lock 的话，会产生死锁，所以 MySQL 内部大量的 mutex_owner 判断逻辑（ mysql_mutex_assert_owner(&m_mutex) ）；\n2. 与1类似，可以在利用一个计数值来统计当前正在等到锁的线程个数，锁 owner 可以根据此计数值来判断是否需要释放锁。\n\n### 说明\n\nmysql_mutex_t 基本上可以看作是对 pthread_mutex_t 的一个封装，pthread_mutex_t 是互斥锁，同一瞬间只能有一个线程能够获取锁，其他线程在等待获取锁的时候会进入休眠状态。因此 pthread_mutex_t 消耗的 CPU 资源很小，但是性能不高，因为会引起线程切换。\n\n## mysql_cond_t\n\n### 数据结构\n\n```c++\n/**\n  Type of an instrumented condition.\n  @c mysql_cond_t is a drop-in replacement for @c pthread_cond_t.\n  @sa mysql_cond_init\n  @sa mysql_cond_wait\n  @sa mysql_cond_timedwait\n  @sa mysql_cond_signal\n  @sa mysql_cond_broadcast\n  @sa mysql_cond_destroy\n*/\ntypedef struct st_mysql_cond mysql_cond_t;\n\nstruct st_mysql_cond\n{\n  /** The real condition */\n  pthread_cond_t m_cond;\n  /**\n    The instrumentation hook.\n    Note that this hook is not conditionally defined,\n    for binary compatibility of the @c mysql_cond_t interface.\n  */\n  struct PSI_cond *m_psi;\n};\n```\n\n### 使用方式\n\n```c++\nPSI_cond_key key_COND_xxx;\nmysql_cond_t m_cond;\n\nmysql_cond_init(key_COND_xxx, &m_cond);\n\n// mysql_cond_t 需要与 mysql_mutex_t 配合使用\nstruct timespec abs_timeout;\nmysql_cond_timedwait(&m_cond, &m_mutex, &abs_timeout);\n\nmysql_cond_signal(&m_cond);\nmysql_cond_broadcast(&m_cond);\n\nmysql_cond_destroy(&m_cond);\n```\n\n## 补充\n\n除了 pthread_rwlock_t 和 pthread_mutex_t 之外，还有一个常用的锁 pthread_spinlock_t。pthread_spinlock_t 是自旋锁，同一瞬间也只能有一个线程能够获取锁，不同的是，其他线程在等待获取锁的过程中并不进入睡眠状态，而是在 CPU 上进入自旋等待。自旋锁的性能很高，但是只适合对很小的代码段加锁（或短期持有的锁），自旋锁对 CPU 的占用相对较高。","slug":"cplusplus-lock","published":1,"updated":"2020-07-17T15:07:26.364Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgluc7270002owgm472l8hpr","content":"<p>MySQL 中常用的几种锁包括：mysql_rwlock_t、mysql_mutex_t、mysql_cond_t，本文结合 MySQL 源码对各种锁的使用做一个简单的总结。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"mysql-rwlock-t\"><a href=\"#mysql-rwlock-t\" class=\"headerlink\" title=\"mysql_rwlock_t\"></a>mysql_rwlock_t</h2><h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  Type of an instrumented rwlock.</span></span><br><span class=\"line\"><span class=\"comment\">  @c mysql_rwlock_t is a drop-in replacement for @c pthread_rwlock_t.</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_init</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_rdlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_tryrdlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_wrlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_trywrlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_unlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_destroy</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_rwlock</span> <span class=\"title\">mysql_rwlock_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_rwlock</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/** The real rwlock */</span></span><br><span class=\"line\">  <span class=\"keyword\">native_rw_lock_t</span> m_rwlock;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    The instrumentation hook.</span></span><br><span class=\"line\"><span class=\"comment\">    Note that this hook is not conditionally defined,</span></span><br><span class=\"line\"><span class=\"comment\">    for binary compatibility of the @c mysql_rwlock_t interface.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PSI_rwlock</span> *<span class=\"title\">m_psi</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">pthread_rwlock_t</span> <span class=\"keyword\">native_rw_lock_t</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PSI_rwlock_key key_rwlock_LOCK_xxx;</span><br><span class=\"line\"><span class=\"keyword\">mysql_rwlock_t</span> m_lock;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_rwlock_init(key_rwlock_LOCK_xxx, &amp;m_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_rwlock_rdlock(&amp;m_lock);</span><br><span class=\"line\">mysql_rwlock_wrlock(&amp;m_lock);</span><br><span class=\"line\">mysql_rwlock_trywrlock(&amp;m_lock);</span><br><span class=\"line\">mysql_rwlock_unlock(&amp;m_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_rwlock_destroy(&amp;m_lock);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>mysql_rwlock_t 基本上可以看作是对 pthread_rwlock_t 的一个封装，pthread_rwlock_t 是读写锁，同时可以有多个线程获得读锁，同时只允许有一个线程获得写锁。其他线程在等待锁的时候同样会进入睡眠。读写锁在互斥锁的基础上，允许多个线程读，在某些场景下能提高性能。</p>\n<h2 id=\"mysql-mutex-t\"><a href=\"#mysql-mutex-t\" class=\"headerlink\" title=\"mysql_mutex_t\"></a>mysql_mutex_t</h2><h3 id=\"数据结构-1\"><a href=\"#数据结构-1\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  Type of an instrumented mutex.</span></span><br><span class=\"line\"><span class=\"comment\">  @c mysql_mutex_t is a drop-in replacement for @c my_mutex_t.</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_assert_owner</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_assert_not_owner</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_init</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_lock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_unlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_destroy</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_mutex</span> <span class=\"title\">mysql_mutex_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_mutex</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/** The real mutex. */</span></span><br><span class=\"line\">  <span class=\"keyword\">my_mutex_t</span> m_mutex;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    The instrumentation hook.</span></span><br><span class=\"line\"><span class=\"comment\">    Note that this hook is not conditionally defined,</span></span><br><span class=\"line\"><span class=\"comment\">    for binary compatibility of the @c mysql_mutex_t interface.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PSI_mutex</span> *<span class=\"title\">m_psi</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">native_mutex_t</span> <span class=\"keyword\">my_mutex_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">pthread_mutex_t</span> <span class=\"keyword\">native_mutex_t</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用方式-1\"><a href=\"#使用方式-1\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PSI_mutex_key key_LOCK_xxx;</span><br><span class=\"line\"><span class=\"keyword\">mysql_mutex_t</span> m_lock;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_mutex_init(key_LOCK_xxx, &amp;m_lock, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_mutex_lock(&amp;m_lock);</span><br><span class=\"line\">mysql_mutex_unlock(&amp;m_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_mutex_destroy(&amp;m_lock);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用技巧\"><a href=\"#使用技巧\" class=\"headerlink\" title=\"使用技巧\"></a>使用技巧</h3><ol>\n<li>Thread 如果已经获得了 mutex， 那么如果再次 lock 的话，会产生死锁，所以 MySQL 内部大量的 mutex_owner 判断逻辑（ mysql_mutex_assert_owner(&amp;m_mutex) ）；</li>\n<li>与1类似，可以在利用一个计数值来统计当前正在等到锁的线程个数，锁 owner 可以根据此计数值来判断是否需要释放锁。</li>\n</ol>\n<h3 id=\"说明-1\"><a href=\"#说明-1\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>mysql_mutex_t 基本上可以看作是对 pthread_mutex_t 的一个封装，pthread_mutex_t 是互斥锁，同一瞬间只能有一个线程能够获取锁，其他线程在等待获取锁的时候会进入休眠状态。因此 pthread_mutex_t 消耗的 CPU 资源很小，但是性能不高，因为会引起线程切换。</p>\n<h2 id=\"mysql-cond-t\"><a href=\"#mysql-cond-t\" class=\"headerlink\" title=\"mysql_cond_t\"></a>mysql_cond_t</h2><h3 id=\"数据结构-2\"><a href=\"#数据结构-2\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  Type of an instrumented condition.</span></span><br><span class=\"line\"><span class=\"comment\">  @c mysql_cond_t is a drop-in replacement for @c pthread_cond_t.</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_init</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_wait</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_timedwait</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_signal</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_broadcast</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_destroy</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_cond</span> <span class=\"title\">mysql_cond_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_cond</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/** The real condition */</span></span><br><span class=\"line\">  <span class=\"keyword\">pthread_cond_t</span> m_cond;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    The instrumentation hook.</span></span><br><span class=\"line\"><span class=\"comment\">    Note that this hook is not conditionally defined,</span></span><br><span class=\"line\"><span class=\"comment\">    for binary compatibility of the @c mysql_cond_t interface.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PSI_cond</span> *<span class=\"title\">m_psi</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用方式-2\"><a href=\"#使用方式-2\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PSI_cond_key key_COND_xxx;</span><br><span class=\"line\"><span class=\"keyword\">mysql_cond_t</span> m_cond;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_cond_init(key_COND_xxx, &amp;m_cond);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// mysql_cond_t 需要与 mysql_mutex_t 配合使用</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timespec</span> <span class=\"title\">abs_timeout</span>;</span></span><br><span class=\"line\">mysql_cond_timedwait(&amp;m_cond, &amp;m_mutex, &amp;abs_timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_cond_signal(&amp;m_cond);</span><br><span class=\"line\">mysql_cond_broadcast(&amp;m_cond);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_cond_destroy(&amp;m_cond);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><p>除了 pthread_rwlock_t 和 pthread_mutex_t 之外，还有一个常用的锁 pthread_spinlock_t。pthread_spinlock_t 是自旋锁，同一瞬间也只能有一个线程能够获取锁，不同的是，其他线程在等待获取锁的过程中并不进入睡眠状态，而是在 CPU 上进入自旋等待。自旋锁的性能很高，但是只适合对很小的代码段加锁（或短期持有的锁），自旋锁对 CPU 的占用相对较高。</p>\n","site":{"data":{}},"excerpt":"<p>MySQL 中常用的几种锁包括：mysql_rwlock_t、mysql_mutex_t、mysql_cond_t，本文结合 MySQL 源码对各种锁的使用做一个简单的总结。</p>","more":"<h2 id=\"mysql-rwlock-t\"><a href=\"#mysql-rwlock-t\" class=\"headerlink\" title=\"mysql_rwlock_t\"></a>mysql_rwlock_t</h2><h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  Type of an instrumented rwlock.</span></span><br><span class=\"line\"><span class=\"comment\">  @c mysql_rwlock_t is a drop-in replacement for @c pthread_rwlock_t.</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_init</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_rdlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_tryrdlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_wrlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_trywrlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_unlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_rwlock_destroy</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_rwlock</span> <span class=\"title\">mysql_rwlock_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_rwlock</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/** The real rwlock */</span></span><br><span class=\"line\">  <span class=\"keyword\">native_rw_lock_t</span> m_rwlock;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    The instrumentation hook.</span></span><br><span class=\"line\"><span class=\"comment\">    Note that this hook is not conditionally defined,</span></span><br><span class=\"line\"><span class=\"comment\">    for binary compatibility of the @c mysql_rwlock_t interface.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PSI_rwlock</span> *<span class=\"title\">m_psi</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">pthread_rwlock_t</span> <span class=\"keyword\">native_rw_lock_t</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PSI_rwlock_key key_rwlock_LOCK_xxx;</span><br><span class=\"line\"><span class=\"keyword\">mysql_rwlock_t</span> m_lock;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_rwlock_init(key_rwlock_LOCK_xxx, &amp;m_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_rwlock_rdlock(&amp;m_lock);</span><br><span class=\"line\">mysql_rwlock_wrlock(&amp;m_lock);</span><br><span class=\"line\">mysql_rwlock_trywrlock(&amp;m_lock);</span><br><span class=\"line\">mysql_rwlock_unlock(&amp;m_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_rwlock_destroy(&amp;m_lock);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>mysql_rwlock_t 基本上可以看作是对 pthread_rwlock_t 的一个封装，pthread_rwlock_t 是读写锁，同时可以有多个线程获得读锁，同时只允许有一个线程获得写锁。其他线程在等待锁的时候同样会进入睡眠。读写锁在互斥锁的基础上，允许多个线程读，在某些场景下能提高性能。</p>\n<h2 id=\"mysql-mutex-t\"><a href=\"#mysql-mutex-t\" class=\"headerlink\" title=\"mysql_mutex_t\"></a>mysql_mutex_t</h2><h3 id=\"数据结构-1\"><a href=\"#数据结构-1\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  Type of an instrumented mutex.</span></span><br><span class=\"line\"><span class=\"comment\">  @c mysql_mutex_t is a drop-in replacement for @c my_mutex_t.</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_assert_owner</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_assert_not_owner</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_init</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_lock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_unlock</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_mutex_destroy</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_mutex</span> <span class=\"title\">mysql_mutex_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_mutex</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/** The real mutex. */</span></span><br><span class=\"line\">  <span class=\"keyword\">my_mutex_t</span> m_mutex;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    The instrumentation hook.</span></span><br><span class=\"line\"><span class=\"comment\">    Note that this hook is not conditionally defined,</span></span><br><span class=\"line\"><span class=\"comment\">    for binary compatibility of the @c mysql_mutex_t interface.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PSI_mutex</span> *<span class=\"title\">m_psi</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">native_mutex_t</span> <span class=\"keyword\">my_mutex_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">pthread_mutex_t</span> <span class=\"keyword\">native_mutex_t</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用方式-1\"><a href=\"#使用方式-1\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PSI_mutex_key key_LOCK_xxx;</span><br><span class=\"line\"><span class=\"keyword\">mysql_mutex_t</span> m_lock;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_mutex_init(key_LOCK_xxx, &amp;m_lock, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_mutex_lock(&amp;m_lock);</span><br><span class=\"line\">mysql_mutex_unlock(&amp;m_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_mutex_destroy(&amp;m_lock);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用技巧\"><a href=\"#使用技巧\" class=\"headerlink\" title=\"使用技巧\"></a>使用技巧</h3><ol>\n<li>Thread 如果已经获得了 mutex， 那么如果再次 lock 的话，会产生死锁，所以 MySQL 内部大量的 mutex_owner 判断逻辑（ mysql_mutex_assert_owner(&amp;m_mutex) ）；</li>\n<li>与1类似，可以在利用一个计数值来统计当前正在等到锁的线程个数，锁 owner 可以根据此计数值来判断是否需要释放锁。</li>\n</ol>\n<h3 id=\"说明-1\"><a href=\"#说明-1\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>mysql_mutex_t 基本上可以看作是对 pthread_mutex_t 的一个封装，pthread_mutex_t 是互斥锁，同一瞬间只能有一个线程能够获取锁，其他线程在等待获取锁的时候会进入休眠状态。因此 pthread_mutex_t 消耗的 CPU 资源很小，但是性能不高，因为会引起线程切换。</p>\n<h2 id=\"mysql-cond-t\"><a href=\"#mysql-cond-t\" class=\"headerlink\" title=\"mysql_cond_t\"></a>mysql_cond_t</h2><h3 id=\"数据结构-2\"><a href=\"#数据结构-2\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  Type of an instrumented condition.</span></span><br><span class=\"line\"><span class=\"comment\">  @c mysql_cond_t is a drop-in replacement for @c pthread_cond_t.</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_init</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_wait</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_timedwait</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_signal</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_broadcast</span></span><br><span class=\"line\"><span class=\"comment\">  @sa mysql_cond_destroy</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_cond</span> <span class=\"title\">mysql_cond_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">st_mysql_cond</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/** The real condition */</span></span><br><span class=\"line\">  <span class=\"keyword\">pthread_cond_t</span> m_cond;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    The instrumentation hook.</span></span><br><span class=\"line\"><span class=\"comment\">    Note that this hook is not conditionally defined,</span></span><br><span class=\"line\"><span class=\"comment\">    for binary compatibility of the @c mysql_cond_t interface.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PSI_cond</span> *<span class=\"title\">m_psi</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用方式-2\"><a href=\"#使用方式-2\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PSI_cond_key key_COND_xxx;</span><br><span class=\"line\"><span class=\"keyword\">mysql_cond_t</span> m_cond;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_cond_init(key_COND_xxx, &amp;m_cond);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// mysql_cond_t 需要与 mysql_mutex_t 配合使用</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timespec</span> <span class=\"title\">abs_timeout</span>;</span></span><br><span class=\"line\">mysql_cond_timedwait(&amp;m_cond, &amp;m_mutex, &amp;abs_timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_cond_signal(&amp;m_cond);</span><br><span class=\"line\">mysql_cond_broadcast(&amp;m_cond);</span><br><span class=\"line\"></span><br><span class=\"line\">mysql_cond_destroy(&amp;m_cond);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><p>除了 pthread_rwlock_t 和 pthread_mutex_t 之外，还有一个常用的锁 pthread_spinlock_t。pthread_spinlock_t 是自旋锁，同一瞬间也只能有一个线程能够获取锁，不同的是，其他线程在等待获取锁的过程中并不进入睡眠状态，而是在 CPU 上进入自旋等待。自旋锁的性能很高，但是只适合对很小的代码段加锁（或短期持有的锁），自旋锁对 CPU 的占用相对较高。</p>"},{"title":"MySQL LF_HASH","date":"2020-07-17T15:07:18.000Z","_content":"\nMySQL 中有很多实现非常好的数据结构，本文要介绍的 LF_HASH 就是其中一个。\n\n<!-- more -->\n\n## 要解决的问题\n\nLF_HASH 主要解决的是以下两个问题：\n\n1. HASH 结构并发修改的问题，特别是查询、插入、删除并发操作时，如何保证当前查询到的元素不会被其它线程删除？\n2. 扩容问题，如何保证在数据元素增多时，有效的进行扩容，减少数据的移动工作？\n\n第一个问题，解决办法是引入 pin 的概念，通过 pin 来记录正在被使用的数据元素，防止被其它线程删除（和 Hazard Pointer 的异同点？）\n\n第二个问题，解决办法是先取 key 的 hash 值，然后对 hash 的二进制进行 reverse，将高位相同的元素放入同一个 bucket。扩容时，只需要在单个 bucket 内插入一个新的锚点，不需要进行任何的数据移动。\n\n> https://kernelmaker.github.io/MySQL_lf_allocator\n>\n> https://baotiao.github.io/2019/09/15/mysql-lf_hash/\n\n## 不解决的问题\n\nLF_HASH 只保证 HASH 结构的线程安全，并不保证单个元素不被修改，单个数据元素还是要通过单独的 lock 来进行保护。\n\n## 使用指南\n\nLF_HASH 的使用和普通 HASH 稍有区别，主要包括以下几点：\n\n### 初始化 LF_HASH\n\n```c++\n/*\n  Initializes lf_hash, the arguments are compatible with hash_init\n\n  @note element_size sets both the size of allocated memory block for\n  lf_alloc and a size of memcpy'ed block size in lf_hash_insert. Typically\n  they are the same, indeed. But LF_HASH::element_size can be decreased\n  after lf_hash_init, and then lf_alloc will allocate larger block that\n  lf_hash_insert will copy over. It is desireable if part of the element\n  is expensive to initialize - for example if there is a mutex or\n  DYNAMIC_ARRAY. In this case they should be initialize in the\n  LF_ALLOCATOR::constructor, and lf_hash_insert should not overwrite them.\n  See wt_init() for example.\n  As an alternative to using the above trick with decreasing\n  LF_HASH::element_size one can provide an \"initialize\" hook that will finish\n  initialization of object provided by LF_ALLOCATOR and set element key from\n  object passed as parameter to lf_hash_insert instead of doing simple memcpy.\n*/\nvoid lf_hash_init2(LF_HASH *hash, uint element_size, uint flags,\n                   uint key_offset, uint key_length,\n                   hash_get_key_function get_key, CHARSET_INFO *charset,\n                   lf_hash_func *hash_function, lf_allocator_func *ctor,\n                   lf_allocator_func *dtor, lf_hash_init_func *init) {\n  lf_alloc_init2(&hash->alloc, sizeof(LF_SLIST) + element_size,\n                 offsetof(LF_SLIST, key), ctor, dtor);\n  lf_dynarray_init(&hash->array, sizeof(LF_SLIST *));\n  hash->size = 1;\n  hash->count = 0;\n  hash->element_size = element_size;\n  hash->flags = flags;\n  hash->charset = charset ? charset : &my_charset_bin;\n  hash->key_offset = key_offset;\n  hash->key_length = key_length;\n  hash->get_key = get_key;\n  hash->hash_function = hash_function ? hash_function : cset_hash_sort_adapter;\n  hash->initialize = init;\n  DBUG_ASSERT(get_key ? !key_offset && !key_length : key_length);\n}\n\nvoid lf_hash_destroy(LF_HASH *hash) {\n  LF_SLIST *el, **head = (LF_SLIST **)lf_dynarray_value(&hash->array, 0);\n\n  if (unlikely(!head)) {\n    return;\n  }\n  el = *head;\n\n  while (el) {\n    LF_SLIST *next = el->link;\n    if (el->hashnr & 1) {\n      lf_alloc_direct_free(&hash->alloc, el); /* normal node */\n    } else {\n      my_free(el); /* dummy node */\n    }\n    el = (LF_SLIST *)next;\n  }\n  lf_alloc_destroy(&hash->alloc);\n  lf_dynarray_destroy(&hash->array);\n}\n```\n\n初始化时需要定义 key 的获取方式，构造&析构方式，插入方法等。其中构造&析构方式，插入方法可以缺省；\n\n### 查询 LF_HASH\n\n```c++\nlf_hash_get_pins(&m_hash);\n\nlf_hash_search(&m_hash, pins, key, length);\n\nlf_hash_search_unpin(pins);\n\nlf_hash_put_pins(pins);\n```\n\n注意，查询的时候必须用 pins&unpin 进行保护，不论查询的结果如何。为什么要这样处理呢？这里涉及到一个对“无锁”概念的理解问题。无锁 HASH 中的无锁到底指的是什么？\n\n无锁指的是：HASH 中的数据是安全的，特别指删除过程是安全的，查询的线程不会被删除的线程影响。如果做到安全呢？pin 在这个过程中起到了关键作用，LF_HASH 在删除时，不是立即删除，而是放入到内部的待删除队列，此时删除操作返回成功，再次查询也无法查询到结果。但是，已经 pin 住的查询依旧有效，数据的访问也正常，直到 unpin 操作完成，删除操作才会真正执行。\n\n### 插入 LF_HASH\n\n```c++\nlf_hash_get_pins(&m_hash);\n\nlf_hash_insert(&m_hash, pins, item);\n\nlf_hash_put_pins(pins); \n```\n\n###  删除 LF_HASH\n\n```c++\nlf_hash_get_pins(&m_hash);\n\nlf_hash_delete(&m_hash, pins, key, length);\n\nlf_hash_put_pins(pins);\n```\n\n## 注意事项\n\nLF_HASH 的使用过程中需要注意：由于 LF_HASH 的删除操作“同步返回，异步删除”的特点，HASH 中管理的对象最好利用一个状态位进行标记，删除前先维护状态位的值。\n\n\n\n","source":"_posts/lf_hash.md","raw":"---\ntitle: MySQL LF_HASH\ndate: 2020-07-17 23:07:18\ntags:\n- MySQL\ncategories: \n- C++\n---\n\nMySQL 中有很多实现非常好的数据结构，本文要介绍的 LF_HASH 就是其中一个。\n\n<!-- more -->\n\n## 要解决的问题\n\nLF_HASH 主要解决的是以下两个问题：\n\n1. HASH 结构并发修改的问题，特别是查询、插入、删除并发操作时，如何保证当前查询到的元素不会被其它线程删除？\n2. 扩容问题，如何保证在数据元素增多时，有效的进行扩容，减少数据的移动工作？\n\n第一个问题，解决办法是引入 pin 的概念，通过 pin 来记录正在被使用的数据元素，防止被其它线程删除（和 Hazard Pointer 的异同点？）\n\n第二个问题，解决办法是先取 key 的 hash 值，然后对 hash 的二进制进行 reverse，将高位相同的元素放入同一个 bucket。扩容时，只需要在单个 bucket 内插入一个新的锚点，不需要进行任何的数据移动。\n\n> https://kernelmaker.github.io/MySQL_lf_allocator\n>\n> https://baotiao.github.io/2019/09/15/mysql-lf_hash/\n\n## 不解决的问题\n\nLF_HASH 只保证 HASH 结构的线程安全，并不保证单个元素不被修改，单个数据元素还是要通过单独的 lock 来进行保护。\n\n## 使用指南\n\nLF_HASH 的使用和普通 HASH 稍有区别，主要包括以下几点：\n\n### 初始化 LF_HASH\n\n```c++\n/*\n  Initializes lf_hash, the arguments are compatible with hash_init\n\n  @note element_size sets both the size of allocated memory block for\n  lf_alloc and a size of memcpy'ed block size in lf_hash_insert. Typically\n  they are the same, indeed. But LF_HASH::element_size can be decreased\n  after lf_hash_init, and then lf_alloc will allocate larger block that\n  lf_hash_insert will copy over. It is desireable if part of the element\n  is expensive to initialize - for example if there is a mutex or\n  DYNAMIC_ARRAY. In this case they should be initialize in the\n  LF_ALLOCATOR::constructor, and lf_hash_insert should not overwrite them.\n  See wt_init() for example.\n  As an alternative to using the above trick with decreasing\n  LF_HASH::element_size one can provide an \"initialize\" hook that will finish\n  initialization of object provided by LF_ALLOCATOR and set element key from\n  object passed as parameter to lf_hash_insert instead of doing simple memcpy.\n*/\nvoid lf_hash_init2(LF_HASH *hash, uint element_size, uint flags,\n                   uint key_offset, uint key_length,\n                   hash_get_key_function get_key, CHARSET_INFO *charset,\n                   lf_hash_func *hash_function, lf_allocator_func *ctor,\n                   lf_allocator_func *dtor, lf_hash_init_func *init) {\n  lf_alloc_init2(&hash->alloc, sizeof(LF_SLIST) + element_size,\n                 offsetof(LF_SLIST, key), ctor, dtor);\n  lf_dynarray_init(&hash->array, sizeof(LF_SLIST *));\n  hash->size = 1;\n  hash->count = 0;\n  hash->element_size = element_size;\n  hash->flags = flags;\n  hash->charset = charset ? charset : &my_charset_bin;\n  hash->key_offset = key_offset;\n  hash->key_length = key_length;\n  hash->get_key = get_key;\n  hash->hash_function = hash_function ? hash_function : cset_hash_sort_adapter;\n  hash->initialize = init;\n  DBUG_ASSERT(get_key ? !key_offset && !key_length : key_length);\n}\n\nvoid lf_hash_destroy(LF_HASH *hash) {\n  LF_SLIST *el, **head = (LF_SLIST **)lf_dynarray_value(&hash->array, 0);\n\n  if (unlikely(!head)) {\n    return;\n  }\n  el = *head;\n\n  while (el) {\n    LF_SLIST *next = el->link;\n    if (el->hashnr & 1) {\n      lf_alloc_direct_free(&hash->alloc, el); /* normal node */\n    } else {\n      my_free(el); /* dummy node */\n    }\n    el = (LF_SLIST *)next;\n  }\n  lf_alloc_destroy(&hash->alloc);\n  lf_dynarray_destroy(&hash->array);\n}\n```\n\n初始化时需要定义 key 的获取方式，构造&析构方式，插入方法等。其中构造&析构方式，插入方法可以缺省；\n\n### 查询 LF_HASH\n\n```c++\nlf_hash_get_pins(&m_hash);\n\nlf_hash_search(&m_hash, pins, key, length);\n\nlf_hash_search_unpin(pins);\n\nlf_hash_put_pins(pins);\n```\n\n注意，查询的时候必须用 pins&unpin 进行保护，不论查询的结果如何。为什么要这样处理呢？这里涉及到一个对“无锁”概念的理解问题。无锁 HASH 中的无锁到底指的是什么？\n\n无锁指的是：HASH 中的数据是安全的，特别指删除过程是安全的，查询的线程不会被删除的线程影响。如果做到安全呢？pin 在这个过程中起到了关键作用，LF_HASH 在删除时，不是立即删除，而是放入到内部的待删除队列，此时删除操作返回成功，再次查询也无法查询到结果。但是，已经 pin 住的查询依旧有效，数据的访问也正常，直到 unpin 操作完成，删除操作才会真正执行。\n\n### 插入 LF_HASH\n\n```c++\nlf_hash_get_pins(&m_hash);\n\nlf_hash_insert(&m_hash, pins, item);\n\nlf_hash_put_pins(pins); \n```\n\n###  删除 LF_HASH\n\n```c++\nlf_hash_get_pins(&m_hash);\n\nlf_hash_delete(&m_hash, pins, key, length);\n\nlf_hash_put_pins(pins);\n```\n\n## 注意事项\n\nLF_HASH 的使用过程中需要注意：由于 LF_HASH 的删除操作“同步返回，异步删除”的特点，HASH 中管理的对象最好利用一个状态位进行标记，删除前先维护状态位的值。\n\n\n\n","slug":"lf_hash","published":1,"updated":"2020-07-17T15:35:02.564Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgluc72b0006owgmctnb4hyo","content":"<p>MySQL 中有很多实现非常好的数据结构，本文要介绍的 LF_HASH 就是其中一个。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"要解决的问题\"><a href=\"#要解决的问题\" class=\"headerlink\" title=\"要解决的问题\"></a>要解决的问题</h2><p>LF_HASH 主要解决的是以下两个问题：</p>\n<ol>\n<li>HASH 结构并发修改的问题，特别是查询、插入、删除并发操作时，如何保证当前查询到的元素不会被其它线程删除？</li>\n<li>扩容问题，如何保证在数据元素增多时，有效的进行扩容，减少数据的移动工作？</li>\n</ol>\n<p>第一个问题，解决办法是引入 pin 的概念，通过 pin 来记录正在被使用的数据元素，防止被其它线程删除（和 Hazard Pointer 的异同点？）</p>\n<p>第二个问题，解决办法是先取 key 的 hash 值，然后对 hash 的二进制进行 reverse，将高位相同的元素放入同一个 bucket。扩容时，只需要在单个 bucket 内插入一个新的锚点，不需要进行任何的数据移动。</p>\n<blockquote>\n<p><a href=\"https://kernelmaker.github.io/MySQL_lf_allocator\" target=\"_blank\" rel=\"noopener\">https://kernelmaker.github.io/MySQL_lf_allocator</a></p>\n<p><a href=\"https://baotiao.github.io/2019/09/15/mysql-lf_hash/\" target=\"_blank\" rel=\"noopener\">https://baotiao.github.io/2019/09/15/mysql-lf_hash/</a></p>\n</blockquote>\n<h2 id=\"不解决的问题\"><a href=\"#不解决的问题\" class=\"headerlink\" title=\"不解决的问题\"></a>不解决的问题</h2><p>LF_HASH 只保证 HASH 结构的线程安全，并不保证单个元素不被修改，单个数据元素还是要通过单独的 lock 来进行保护。</p>\n<h2 id=\"使用指南\"><a href=\"#使用指南\" class=\"headerlink\" title=\"使用指南\"></a>使用指南</h2><p>LF_HASH 的使用和普通 HASH 稍有区别，主要包括以下几点：</p>\n<h3 id=\"初始化-LF-HASH\"><a href=\"#初始化-LF-HASH\" class=\"headerlink\" title=\"初始化 LF_HASH\"></a>初始化 LF_HASH</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  Initializes lf_hash, the arguments are compatible with hash_init</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">  @note element_size sets both the size of allocated memory block for</span></span><br><span class=\"line\"><span class=\"comment\">  lf_alloc and a size of memcpy'ed block size in lf_hash_insert. Typically</span></span><br><span class=\"line\"><span class=\"comment\">  they are the same, indeed. But LF_HASH::element_size can be decreased</span></span><br><span class=\"line\"><span class=\"comment\">  after lf_hash_init, and then lf_alloc will allocate larger block that</span></span><br><span class=\"line\"><span class=\"comment\">  lf_hash_insert will copy over. It is desireable if part of the element</span></span><br><span class=\"line\"><span class=\"comment\">  is expensive to initialize - for example if there is a mutex or</span></span><br><span class=\"line\"><span class=\"comment\">  DYNAMIC_ARRAY. In this case they should be initialize in the</span></span><br><span class=\"line\"><span class=\"comment\">  LF_ALLOCATOR::constructor, and lf_hash_insert should not overwrite them.</span></span><br><span class=\"line\"><span class=\"comment\">  See wt_init() for example.</span></span><br><span class=\"line\"><span class=\"comment\">  As an alternative to using the above trick with decreasing</span></span><br><span class=\"line\"><span class=\"comment\">  LF_HASH::element_size one can provide an \"initialize\" hook that will finish</span></span><br><span class=\"line\"><span class=\"comment\">  initialization of object provided by LF_ALLOCATOR and set element key from</span></span><br><span class=\"line\"><span class=\"comment\">  object passed as parameter to lf_hash_insert instead of doing simple memcpy.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lf_hash_init2</span><span class=\"params\">(LF_HASH *hash, uint element_size, uint flags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   uint key_offset, uint key_length,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   hash_get_key_function get_key, CHARSET_INFO *charset,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   lf_hash_func *hash_function, lf_allocator_func *ctor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   lf_allocator_func *dtor, lf_hash_init_func *init)</span> </span>&#123;</span><br><span class=\"line\">  lf_alloc_init2(&amp;hash-&gt;alloc, <span class=\"keyword\">sizeof</span>(LF_SLIST) + element_size,</span><br><span class=\"line\">                 offsetof(LF_SLIST, key), ctor, dtor);</span><br><span class=\"line\">  lf_dynarray_init(&amp;hash-&gt;<span class=\"built_in\">array</span>, <span class=\"keyword\">sizeof</span>(LF_SLIST *));</span><br><span class=\"line\">  hash-&gt;<span class=\"built_in\">size</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">  hash-&gt;count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  hash-&gt;element_size = element_size;</span><br><span class=\"line\">  hash-&gt;flags = flags;</span><br><span class=\"line\">  hash-&gt;charset = charset ? charset : &amp;my_charset_bin;</span><br><span class=\"line\">  hash-&gt;key_offset = key_offset;</span><br><span class=\"line\">  hash-&gt;key_length = key_length;</span><br><span class=\"line\">  hash-&gt;get_key = get_key;</span><br><span class=\"line\">  hash-&gt;hash_function = hash_function ? hash_function : cset_hash_sort_adapter;</span><br><span class=\"line\">  hash-&gt;initialize = init;</span><br><span class=\"line\">  DBUG_ASSERT(get_key ? !key_offset &amp;&amp; !key_length : key_length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lf_hash_destroy</span><span class=\"params\">(LF_HASH *hash)</span> </span>&#123;</span><br><span class=\"line\">  LF_SLIST *el, **head = (LF_SLIST **)lf_dynarray_value(&amp;hash-&gt;<span class=\"built_in\">array</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (unlikely(!head)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  el = *head;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (el) &#123;</span><br><span class=\"line\">    LF_SLIST *next = el-&gt;link;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (el-&gt;hashnr &amp; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      lf_alloc_direct_free(&amp;hash-&gt;alloc, el); <span class=\"comment\">/* normal node */</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      my_free(el); <span class=\"comment\">/* dummy node */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    el = (LF_SLIST *)next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lf_alloc_destroy(&amp;hash-&gt;alloc);</span><br><span class=\"line\">  lf_dynarray_destroy(&amp;hash-&gt;<span class=\"built_in\">array</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始化时需要定义 key 的获取方式，构造&amp;析构方式，插入方法等。其中构造&amp;析构方式，插入方法可以缺省；</p>\n<h3 id=\"查询-LF-HASH\"><a href=\"#查询-LF-HASH\" class=\"headerlink\" title=\"查询 LF_HASH\"></a>查询 LF_HASH</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lf_hash_get_pins(&amp;m_hash);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_search(&amp;m_hash, pins, key, length);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_search_unpin(pins);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_put_pins(pins);</span><br></pre></td></tr></table></figure>\n\n<p>注意，查询的时候必须用 pins&amp;unpin 进行保护，不论查询的结果如何。为什么要这样处理呢？这里涉及到一个对“无锁”概念的理解问题。无锁 HASH 中的无锁到底指的是什么？</p>\n<p>无锁指的是：HASH 中的数据是安全的，特别指删除过程是安全的，查询的线程不会被删除的线程影响。如果做到安全呢？pin 在这个过程中起到了关键作用，LF_HASH 在删除时，不是立即删除，而是放入到内部的待删除队列，此时删除操作返回成功，再次查询也无法查询到结果。但是，已经 pin 住的查询依旧有效，数据的访问也正常，直到 unpin 操作完成，删除操作才会真正执行。</p>\n<h3 id=\"插入-LF-HASH\"><a href=\"#插入-LF-HASH\" class=\"headerlink\" title=\"插入 LF_HASH\"></a>插入 LF_HASH</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lf_hash_get_pins(&amp;m_hash);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_insert(&amp;m_hash, pins, item);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_put_pins(pins);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除-LF-HASH\"><a href=\"#删除-LF-HASH\" class=\"headerlink\" title=\"删除 LF_HASH\"></a>删除 LF_HASH</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lf_hash_get_pins(&amp;m_hash);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_delete(&amp;m_hash, pins, key, length);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_put_pins(pins);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>LF_HASH 的使用过程中需要注意：由于 LF_HASH 的删除操作“同步返回，异步删除”的特点，HASH 中管理的对象最好利用一个状态位进行标记，删除前先维护状态位的值。</p>\n","site":{"data":{}},"excerpt":"<p>MySQL 中有很多实现非常好的数据结构，本文要介绍的 LF_HASH 就是其中一个。</p>","more":"<h2 id=\"要解决的问题\"><a href=\"#要解决的问题\" class=\"headerlink\" title=\"要解决的问题\"></a>要解决的问题</h2><p>LF_HASH 主要解决的是以下两个问题：</p>\n<ol>\n<li>HASH 结构并发修改的问题，特别是查询、插入、删除并发操作时，如何保证当前查询到的元素不会被其它线程删除？</li>\n<li>扩容问题，如何保证在数据元素增多时，有效的进行扩容，减少数据的移动工作？</li>\n</ol>\n<p>第一个问题，解决办法是引入 pin 的概念，通过 pin 来记录正在被使用的数据元素，防止被其它线程删除（和 Hazard Pointer 的异同点？）</p>\n<p>第二个问题，解决办法是先取 key 的 hash 值，然后对 hash 的二进制进行 reverse，将高位相同的元素放入同一个 bucket。扩容时，只需要在单个 bucket 内插入一个新的锚点，不需要进行任何的数据移动。</p>\n<blockquote>\n<p><a href=\"https://kernelmaker.github.io/MySQL_lf_allocator\" target=\"_blank\" rel=\"noopener\">https://kernelmaker.github.io/MySQL_lf_allocator</a></p>\n<p><a href=\"https://baotiao.github.io/2019/09/15/mysql-lf_hash/\" target=\"_blank\" rel=\"noopener\">https://baotiao.github.io/2019/09/15/mysql-lf_hash/</a></p>\n</blockquote>\n<h2 id=\"不解决的问题\"><a href=\"#不解决的问题\" class=\"headerlink\" title=\"不解决的问题\"></a>不解决的问题</h2><p>LF_HASH 只保证 HASH 结构的线程安全，并不保证单个元素不被修改，单个数据元素还是要通过单独的 lock 来进行保护。</p>\n<h2 id=\"使用指南\"><a href=\"#使用指南\" class=\"headerlink\" title=\"使用指南\"></a>使用指南</h2><p>LF_HASH 的使用和普通 HASH 稍有区别，主要包括以下几点：</p>\n<h3 id=\"初始化-LF-HASH\"><a href=\"#初始化-LF-HASH\" class=\"headerlink\" title=\"初始化 LF_HASH\"></a>初始化 LF_HASH</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  Initializes lf_hash, the arguments are compatible with hash_init</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">  @note element_size sets both the size of allocated memory block for</span></span><br><span class=\"line\"><span class=\"comment\">  lf_alloc and a size of memcpy'ed block size in lf_hash_insert. Typically</span></span><br><span class=\"line\"><span class=\"comment\">  they are the same, indeed. But LF_HASH::element_size can be decreased</span></span><br><span class=\"line\"><span class=\"comment\">  after lf_hash_init, and then lf_alloc will allocate larger block that</span></span><br><span class=\"line\"><span class=\"comment\">  lf_hash_insert will copy over. It is desireable if part of the element</span></span><br><span class=\"line\"><span class=\"comment\">  is expensive to initialize - for example if there is a mutex or</span></span><br><span class=\"line\"><span class=\"comment\">  DYNAMIC_ARRAY. In this case they should be initialize in the</span></span><br><span class=\"line\"><span class=\"comment\">  LF_ALLOCATOR::constructor, and lf_hash_insert should not overwrite them.</span></span><br><span class=\"line\"><span class=\"comment\">  See wt_init() for example.</span></span><br><span class=\"line\"><span class=\"comment\">  As an alternative to using the above trick with decreasing</span></span><br><span class=\"line\"><span class=\"comment\">  LF_HASH::element_size one can provide an \"initialize\" hook that will finish</span></span><br><span class=\"line\"><span class=\"comment\">  initialization of object provided by LF_ALLOCATOR and set element key from</span></span><br><span class=\"line\"><span class=\"comment\">  object passed as parameter to lf_hash_insert instead of doing simple memcpy.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lf_hash_init2</span><span class=\"params\">(LF_HASH *hash, uint element_size, uint flags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   uint key_offset, uint key_length,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   hash_get_key_function get_key, CHARSET_INFO *charset,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   lf_hash_func *hash_function, lf_allocator_func *ctor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   lf_allocator_func *dtor, lf_hash_init_func *init)</span> </span>&#123;</span><br><span class=\"line\">  lf_alloc_init2(&amp;hash-&gt;alloc, <span class=\"keyword\">sizeof</span>(LF_SLIST) + element_size,</span><br><span class=\"line\">                 offsetof(LF_SLIST, key), ctor, dtor);</span><br><span class=\"line\">  lf_dynarray_init(&amp;hash-&gt;<span class=\"built_in\">array</span>, <span class=\"keyword\">sizeof</span>(LF_SLIST *));</span><br><span class=\"line\">  hash-&gt;<span class=\"built_in\">size</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">  hash-&gt;count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  hash-&gt;element_size = element_size;</span><br><span class=\"line\">  hash-&gt;flags = flags;</span><br><span class=\"line\">  hash-&gt;charset = charset ? charset : &amp;my_charset_bin;</span><br><span class=\"line\">  hash-&gt;key_offset = key_offset;</span><br><span class=\"line\">  hash-&gt;key_length = key_length;</span><br><span class=\"line\">  hash-&gt;get_key = get_key;</span><br><span class=\"line\">  hash-&gt;hash_function = hash_function ? hash_function : cset_hash_sort_adapter;</span><br><span class=\"line\">  hash-&gt;initialize = init;</span><br><span class=\"line\">  DBUG_ASSERT(get_key ? !key_offset &amp;&amp; !key_length : key_length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lf_hash_destroy</span><span class=\"params\">(LF_HASH *hash)</span> </span>&#123;</span><br><span class=\"line\">  LF_SLIST *el, **head = (LF_SLIST **)lf_dynarray_value(&amp;hash-&gt;<span class=\"built_in\">array</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (unlikely(!head)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  el = *head;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (el) &#123;</span><br><span class=\"line\">    LF_SLIST *next = el-&gt;link;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (el-&gt;hashnr &amp; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      lf_alloc_direct_free(&amp;hash-&gt;alloc, el); <span class=\"comment\">/* normal node */</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      my_free(el); <span class=\"comment\">/* dummy node */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    el = (LF_SLIST *)next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lf_alloc_destroy(&amp;hash-&gt;alloc);</span><br><span class=\"line\">  lf_dynarray_destroy(&amp;hash-&gt;<span class=\"built_in\">array</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始化时需要定义 key 的获取方式，构造&amp;析构方式，插入方法等。其中构造&amp;析构方式，插入方法可以缺省；</p>\n<h3 id=\"查询-LF-HASH\"><a href=\"#查询-LF-HASH\" class=\"headerlink\" title=\"查询 LF_HASH\"></a>查询 LF_HASH</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lf_hash_get_pins(&amp;m_hash);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_search(&amp;m_hash, pins, key, length);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_search_unpin(pins);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_put_pins(pins);</span><br></pre></td></tr></table></figure>\n\n<p>注意，查询的时候必须用 pins&amp;unpin 进行保护，不论查询的结果如何。为什么要这样处理呢？这里涉及到一个对“无锁”概念的理解问题。无锁 HASH 中的无锁到底指的是什么？</p>\n<p>无锁指的是：HASH 中的数据是安全的，特别指删除过程是安全的，查询的线程不会被删除的线程影响。如果做到安全呢？pin 在这个过程中起到了关键作用，LF_HASH 在删除时，不是立即删除，而是放入到内部的待删除队列，此时删除操作返回成功，再次查询也无法查询到结果。但是，已经 pin 住的查询依旧有效，数据的访问也正常，直到 unpin 操作完成，删除操作才会真正执行。</p>\n<h3 id=\"插入-LF-HASH\"><a href=\"#插入-LF-HASH\" class=\"headerlink\" title=\"插入 LF_HASH\"></a>插入 LF_HASH</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lf_hash_get_pins(&amp;m_hash);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_insert(&amp;m_hash, pins, item);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_put_pins(pins);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除-LF-HASH\"><a href=\"#删除-LF-HASH\" class=\"headerlink\" title=\"删除 LF_HASH\"></a>删除 LF_HASH</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lf_hash_get_pins(&amp;m_hash);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_delete(&amp;m_hash, pins, key, length);</span><br><span class=\"line\"></span><br><span class=\"line\">lf_hash_put_pins(pins);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>LF_HASH 的使用过程中需要注意：由于 LF_HASH 的删除操作“同步返回，异步删除”的特点，HASH 中管理的对象最好利用一个状态位进行标记，删除前先维护状态位的值。</p>"},{"title":"MySQL 建连过程分析","date":"2020-07-15T14:09:20.000Z","_content":"\n本文结合 MySQL 8.0 的源码对 MySQL 的连接处理过程进行一个介绍，其它版本与 8.0 版本基本类似。\n\n<!-- more -->\n\n## 数据结构\n\n在介绍 MySQL 建连过程之前，先整体看一下相关类的关系：\n\n<img src=\"/images/connection-handler-1.jpg\" width=\"88%\"/>\n\nMySQL 8.0 在 Linux 平台下使用的是 poll 机制，默认情况下每个用户连接会使用一个单独的线程进行处理。\n\n## MySQL 建连过程\n\nMySQL 建连过程可以分为以下几个步骤：\n\n### 初始化\n\n```c++\nstatic Connection_acceptor<Mysqld_socket_listener> *mysqld_socket_acceptor = NULL;\n\nstatic bool network_init(void) {\n  ...\n  /* 解析网络配置信息 */\n  Mysqld_socket_listener *mysqld_socket_listener = new (std::nothrow)\n      Mysqld_socket_listener(bind_addresses_info, mysqld_port,\n                             admin_address_info, mysqld_admin_port,\n                             listen_admin_interface_in_separate_thread,\n                             back_log, mysqld_port_timeout, unix_sock_name);\n\n  mysqld_socket_acceptor = new (std::nothrow)\n      Connection_acceptor<Mysqld_socket_listener>(mysqld_socket_listener);\n  ...\n  /* 初始化监听端口 */\n  if (mysqld_socket_acceptor->init_connection_acceptor())\n    return true;\n  ...\n}\n\nbool init_connection_acceptor() { return m_listener->setup_listener(); }\n\nbool Mysqld_socket_listener::setup_listener() {\n  ...\n  if (m_tcp_port) {\n    for (const auto &bind_address_info : m_bind_addresses) {\n      TCP_socket tcp_socket(bind_address_info.address,\n                            bind_address_info.network_namespace, m_tcp_port,\n                            m_backlog, m_port_timeout);\n\n      /* socket 初始化，底层调用的还是 socket/bind/listen 函数 */\n      MYSQL_SOCKET mysql_socket = tcp_socket.get_listener_socket();\n      if (mysql_socket.fd == INVALID_SOCKET) return true;\n\n      Socket_attr s(Socket_type::TCP_SOCKET,\n                    bind_address_info.network_namespace);\n      m_socket_map.insert(\n          std::pair<MYSQL_SOCKET, Socket_attr>(mysql_socket, s));\n    }\n  }\n\n  /* 将所有监听的 socket 信息加入到 m_poll_info 中 */\n  setup_connection_events(m_socket_map);\n  return false;\n}\n\n/* socker 初始化 */\nMYSQL_SOCKET TCP_socket::get_listener_socket() {\n  ...\n  MYSQL_SOCKET listener_socket = create_socket(ai_ptr.get(), AF_INET, &a);\n  mysql_socket_bind(listener_socket, a->ai_addr, a->ai_addrlen);\n  mysql_socket_listen(listener_socket, static_cast<int>(m_backlog);\n  ...\n}\n\nvoid Mysqld_socket_listener::setup_connection_events(\n    const socket_map_t &socket_map) {\n#ifdef HAVE_POLL\n  const socket_map_t::size_type total_number_of_addresses_to_bind =\n      socket_map.size();\n  m_poll_info.m_fds.reserve(total_number_of_addresses_to_bind);\n  m_poll_info.m_pfs_fds.reserve(total_number_of_addresses_to_bind);\n#endif\n\n  for (const auto &element : socket_map) add_socket_to_listener(element.first);\n}\n\nvoid Mysqld_socket_listener::add_socket_to_listener(\n    MYSQL_SOCKET listen_socket) {\n  mysql_socket_set_thread_owner(listen_socket);\n\n#ifdef HAVE_POLL\n  m_poll_info.m_fds.emplace_back(\n      pollfd{mysql_socket_getfd(listen_socket), POLLIN, 0});\n  m_poll_info.m_pfs_fds.push_back(listen_socket);\n#else\n  FD_SET(mysql_socket_getfd(listen_socket), &m_select_info.m_client_fds);\n  if ((uint)mysql_socket_getfd(listen_socket) >\n      m_select_info.m_max_used_connection)\n    m_select_info.m_max_used_connection = mysql_socket_getfd(listen_socket);\n#endif\n}\n```\n\n### 连接建立\n\n```c++\nint mysqld_main(int argc, char **argv) {\n  ...\n  mysqld_socket_acceptor->connection_event_loop();\n  ...\n}\n\nvoid connection_event_loop() {\n  Connection_handler_manager *mgr =\n    Connection_handler_manager::get_instance();\n  while (!connection_events_loop_aborted()) {\n    /* 监听到连接事件，开始 channel 处理 */\n    Channel_info *channel_info = m_listener->listen_for_connection_event();\n    if (channel_info != NULL) mgr->process_new_connection(channel_info);\n  }\n}\n\nChannel_info *Mysqld_socket_listener::listen_for_connection_event() {\n#ifdef HAVE_POLL\n  /* 通过 poll 机制进行监听 */\n  int retval = poll(&m_poll_info.m_fds[0], m_socket_map.size(), -1);\n#else\n  m_select_info.m_read_fds = m_select_info.m_client_fds;\n  int retval = select((int)m_select_info.m_max_used_connection,\n                      &m_select_info.m_read_fds, 0, 0, 0);\n#endif\n\n  bool is_unix_socket = false, is_admin_sock;\n  /* 获取到一个 ready 的 socket */\n  MYSQL_SOCKET listen_sock = get_ready_socket(&is_unix_socket, &is_admin_sock);\n  DBUG_ASSERT(mysql_socket_getfd(listen_sock) != INVALID_SOCKET);\n  \n  MYSQL_SOCKET connect_sock;\n  accept_connection(listen_sock, &connect_sock);\n\n  Channel_info *channel_info = NULL;\n  if (is_unix_socket)\n    channel_info = new (std::nothrow) Channel_info_local_socket(connect_sock);\n  else\n    channel_info = new (std::nothrow)\n        Channel_info_tcpip_socket(connect_sock, is_admin_sock);\n}\n\nvoid Connection_handler_manager::process_new_connection(\n    Channel_info *channel_info) {\n  ...\n  if (m_connection_handler->add_connection(channel_info)) {\n    inc_aborted_connects();\n    delete channel_info;\n  }\n}\n\n/* 一对一处理模式 */\nbool Per_thread_connection_handler::add_connection(Channel_info *channel_info) {\n  ...\n  /* 检查是否有空闲的线程 */\n  if (!check_idle_thread_and_enqueue_connection(channel_info)) return false;\n  \n  channel_info->set_prior_thr_create_utime();\n  /* 新建一个线程进行处理 */\n  error =\n      mysql_thread_create(key_thread_one_connection, &id, &connection_attrib,\n                          handle_connection, (void *)channel_info);\n  ...\n  if (error) {\n    connection_errors_internal++;\n    if (!create_thd_err_log_throttle.log())\n      LogErr(ERROR_LEVEL, ER_CONN_PER_THREAD_NO_THREAD, error);\n    channel_info->send_error_and_close_channel(ER_CANT_CREATE_THREAD, error,\n                                               true);\n\n    im::global_manager_dec_connection(NULL);\n    return true;\n  }\n  ...\n}\n\nstatic void *handle_connection(void *arg) {\n  ...\n  Channel_info *channel_info = static_cast<Channel_info *>(arg);\n  if (my_thread_init()) {\n    ...\n  }\n  ...\n  for (;;) {\n    THD *thd = init_new_thd(channel_info);\n    ...\n    while (thd_connection_alive(thd)) {\n      /* 开始请求处理 */\n      if (do_command(thd)) break;\n    }\n    ...\n    /* thread 复用 */\n    channel_info = Per_thread_connection_handler::block_until_new_connection();\n  }\n}\n```\n\n### 请求处理\n\n```c++\nbool do_command(THD *thd,\n                std::function<bool(THD *, const COM_DATA *,\n                                   enum enum_server_command)> *dispatcher) {\n  ...\n  thd->m_server_idle = true;\n  rc = thd->get_protocol()->get_command(&com_data, &command);\n  thd->m_server_idle = false;\n  ...\n  return_value = dispatch_command(thd, &com_data, command);\n  ...\n}\n\nbool dispatch_command(THD *thd, const COM_DATA *com_data,\n                      enum enum_server_command command) {\n  ...\n  thd->set_command(command);\n  ...\n  switch (command) {\n    ...\n    case COM_QUERY: {...}\n    ...\n  }\n}\n```\n\n## 附\n\nMySQL 5.7 可以参考：http://mysql.taobao.org/monthly/2016/07/04/","source":"_posts/connection-handler.md","raw":"---\ntitle: MySQL 建连过程分析\ndate: 2020-07-15 22:09:20\ntags:\n- MySQL\ncategories: \n- 数据库\n---\n\n本文结合 MySQL 8.0 的源码对 MySQL 的连接处理过程进行一个介绍，其它版本与 8.0 版本基本类似。\n\n<!-- more -->\n\n## 数据结构\n\n在介绍 MySQL 建连过程之前，先整体看一下相关类的关系：\n\n<img src=\"/images/connection-handler-1.jpg\" width=\"88%\"/>\n\nMySQL 8.0 在 Linux 平台下使用的是 poll 机制，默认情况下每个用户连接会使用一个单独的线程进行处理。\n\n## MySQL 建连过程\n\nMySQL 建连过程可以分为以下几个步骤：\n\n### 初始化\n\n```c++\nstatic Connection_acceptor<Mysqld_socket_listener> *mysqld_socket_acceptor = NULL;\n\nstatic bool network_init(void) {\n  ...\n  /* 解析网络配置信息 */\n  Mysqld_socket_listener *mysqld_socket_listener = new (std::nothrow)\n      Mysqld_socket_listener(bind_addresses_info, mysqld_port,\n                             admin_address_info, mysqld_admin_port,\n                             listen_admin_interface_in_separate_thread,\n                             back_log, mysqld_port_timeout, unix_sock_name);\n\n  mysqld_socket_acceptor = new (std::nothrow)\n      Connection_acceptor<Mysqld_socket_listener>(mysqld_socket_listener);\n  ...\n  /* 初始化监听端口 */\n  if (mysqld_socket_acceptor->init_connection_acceptor())\n    return true;\n  ...\n}\n\nbool init_connection_acceptor() { return m_listener->setup_listener(); }\n\nbool Mysqld_socket_listener::setup_listener() {\n  ...\n  if (m_tcp_port) {\n    for (const auto &bind_address_info : m_bind_addresses) {\n      TCP_socket tcp_socket(bind_address_info.address,\n                            bind_address_info.network_namespace, m_tcp_port,\n                            m_backlog, m_port_timeout);\n\n      /* socket 初始化，底层调用的还是 socket/bind/listen 函数 */\n      MYSQL_SOCKET mysql_socket = tcp_socket.get_listener_socket();\n      if (mysql_socket.fd == INVALID_SOCKET) return true;\n\n      Socket_attr s(Socket_type::TCP_SOCKET,\n                    bind_address_info.network_namespace);\n      m_socket_map.insert(\n          std::pair<MYSQL_SOCKET, Socket_attr>(mysql_socket, s));\n    }\n  }\n\n  /* 将所有监听的 socket 信息加入到 m_poll_info 中 */\n  setup_connection_events(m_socket_map);\n  return false;\n}\n\n/* socker 初始化 */\nMYSQL_SOCKET TCP_socket::get_listener_socket() {\n  ...\n  MYSQL_SOCKET listener_socket = create_socket(ai_ptr.get(), AF_INET, &a);\n  mysql_socket_bind(listener_socket, a->ai_addr, a->ai_addrlen);\n  mysql_socket_listen(listener_socket, static_cast<int>(m_backlog);\n  ...\n}\n\nvoid Mysqld_socket_listener::setup_connection_events(\n    const socket_map_t &socket_map) {\n#ifdef HAVE_POLL\n  const socket_map_t::size_type total_number_of_addresses_to_bind =\n      socket_map.size();\n  m_poll_info.m_fds.reserve(total_number_of_addresses_to_bind);\n  m_poll_info.m_pfs_fds.reserve(total_number_of_addresses_to_bind);\n#endif\n\n  for (const auto &element : socket_map) add_socket_to_listener(element.first);\n}\n\nvoid Mysqld_socket_listener::add_socket_to_listener(\n    MYSQL_SOCKET listen_socket) {\n  mysql_socket_set_thread_owner(listen_socket);\n\n#ifdef HAVE_POLL\n  m_poll_info.m_fds.emplace_back(\n      pollfd{mysql_socket_getfd(listen_socket), POLLIN, 0});\n  m_poll_info.m_pfs_fds.push_back(listen_socket);\n#else\n  FD_SET(mysql_socket_getfd(listen_socket), &m_select_info.m_client_fds);\n  if ((uint)mysql_socket_getfd(listen_socket) >\n      m_select_info.m_max_used_connection)\n    m_select_info.m_max_used_connection = mysql_socket_getfd(listen_socket);\n#endif\n}\n```\n\n### 连接建立\n\n```c++\nint mysqld_main(int argc, char **argv) {\n  ...\n  mysqld_socket_acceptor->connection_event_loop();\n  ...\n}\n\nvoid connection_event_loop() {\n  Connection_handler_manager *mgr =\n    Connection_handler_manager::get_instance();\n  while (!connection_events_loop_aborted()) {\n    /* 监听到连接事件，开始 channel 处理 */\n    Channel_info *channel_info = m_listener->listen_for_connection_event();\n    if (channel_info != NULL) mgr->process_new_connection(channel_info);\n  }\n}\n\nChannel_info *Mysqld_socket_listener::listen_for_connection_event() {\n#ifdef HAVE_POLL\n  /* 通过 poll 机制进行监听 */\n  int retval = poll(&m_poll_info.m_fds[0], m_socket_map.size(), -1);\n#else\n  m_select_info.m_read_fds = m_select_info.m_client_fds;\n  int retval = select((int)m_select_info.m_max_used_connection,\n                      &m_select_info.m_read_fds, 0, 0, 0);\n#endif\n\n  bool is_unix_socket = false, is_admin_sock;\n  /* 获取到一个 ready 的 socket */\n  MYSQL_SOCKET listen_sock = get_ready_socket(&is_unix_socket, &is_admin_sock);\n  DBUG_ASSERT(mysql_socket_getfd(listen_sock) != INVALID_SOCKET);\n  \n  MYSQL_SOCKET connect_sock;\n  accept_connection(listen_sock, &connect_sock);\n\n  Channel_info *channel_info = NULL;\n  if (is_unix_socket)\n    channel_info = new (std::nothrow) Channel_info_local_socket(connect_sock);\n  else\n    channel_info = new (std::nothrow)\n        Channel_info_tcpip_socket(connect_sock, is_admin_sock);\n}\n\nvoid Connection_handler_manager::process_new_connection(\n    Channel_info *channel_info) {\n  ...\n  if (m_connection_handler->add_connection(channel_info)) {\n    inc_aborted_connects();\n    delete channel_info;\n  }\n}\n\n/* 一对一处理模式 */\nbool Per_thread_connection_handler::add_connection(Channel_info *channel_info) {\n  ...\n  /* 检查是否有空闲的线程 */\n  if (!check_idle_thread_and_enqueue_connection(channel_info)) return false;\n  \n  channel_info->set_prior_thr_create_utime();\n  /* 新建一个线程进行处理 */\n  error =\n      mysql_thread_create(key_thread_one_connection, &id, &connection_attrib,\n                          handle_connection, (void *)channel_info);\n  ...\n  if (error) {\n    connection_errors_internal++;\n    if (!create_thd_err_log_throttle.log())\n      LogErr(ERROR_LEVEL, ER_CONN_PER_THREAD_NO_THREAD, error);\n    channel_info->send_error_and_close_channel(ER_CANT_CREATE_THREAD, error,\n                                               true);\n\n    im::global_manager_dec_connection(NULL);\n    return true;\n  }\n  ...\n}\n\nstatic void *handle_connection(void *arg) {\n  ...\n  Channel_info *channel_info = static_cast<Channel_info *>(arg);\n  if (my_thread_init()) {\n    ...\n  }\n  ...\n  for (;;) {\n    THD *thd = init_new_thd(channel_info);\n    ...\n    while (thd_connection_alive(thd)) {\n      /* 开始请求处理 */\n      if (do_command(thd)) break;\n    }\n    ...\n    /* thread 复用 */\n    channel_info = Per_thread_connection_handler::block_until_new_connection();\n  }\n}\n```\n\n### 请求处理\n\n```c++\nbool do_command(THD *thd,\n                std::function<bool(THD *, const COM_DATA *,\n                                   enum enum_server_command)> *dispatcher) {\n  ...\n  thd->m_server_idle = true;\n  rc = thd->get_protocol()->get_command(&com_data, &command);\n  thd->m_server_idle = false;\n  ...\n  return_value = dispatch_command(thd, &com_data, command);\n  ...\n}\n\nbool dispatch_command(THD *thd, const COM_DATA *com_data,\n                      enum enum_server_command command) {\n  ...\n  thd->set_command(command);\n  ...\n  switch (command) {\n    ...\n    case COM_QUERY: {...}\n    ...\n  }\n}\n```\n\n## 附\n\nMySQL 5.7 可以参考：http://mysql.taobao.org/monthly/2016/07/04/","slug":"connection-handler","published":1,"updated":"2020-07-20T12:24:04.907Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgluc72d0008owgm09z80ehy","content":"<p>本文结合 MySQL 8.0 的源码对 MySQL 的连接处理过程进行一个介绍，其它版本与 8.0 版本基本类似。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>在介绍 MySQL 建连过程之前，先整体看一下相关类的关系：</p>\n<img src=\"/images/connection-handler-1.jpg\" width=\"88%\"/>\n\n<p>MySQL 8.0 在 Linux 平台下使用的是 poll 机制，默认情况下每个用户连接会使用一个单独的线程进行处理。</p>\n<h2 id=\"MySQL-建连过程\"><a href=\"#MySQL-建连过程\" class=\"headerlink\" title=\"MySQL 建连过程\"></a>MySQL 建连过程</h2><p>MySQL 建连过程可以分为以下几个步骤：</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> Connection_acceptor&lt;Mysqld_socket_listener&gt; *mysqld_socket_acceptor = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> <span class=\"title\">network_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">/* 解析网络配置信息 */</span></span><br><span class=\"line\">  Mysqld_socket_listener *mysqld_socket_listener = <span class=\"keyword\">new</span> (<span class=\"built_in\">std</span>::nothrow)</span><br><span class=\"line\">      Mysqld_socket_listener(bind_addresses_info, mysqld_port,</span><br><span class=\"line\">                             admin_address_info, mysqld_admin_port,</span><br><span class=\"line\">                             listen_admin_interface_in_separate_thread,</span><br><span class=\"line\">                             back_log, mysqld_port_timeout, unix_sock_name);</span><br><span class=\"line\"></span><br><span class=\"line\">  mysqld_socket_acceptor = <span class=\"keyword\">new</span> (<span class=\"built_in\">std</span>::nothrow)</span><br><span class=\"line\">      Connection_acceptor&lt;Mysqld_socket_listener&gt;(mysqld_socket_listener);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">/* 初始化监听端口 */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mysqld_socket_acceptor-&gt;init_connection_acceptor())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">init_connection_acceptor</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_listener-&gt;setup_listener(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Mysqld_socket_listener::setup_listener</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (m_tcp_port) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> &amp;bind_address_info : m_bind_addresses) &#123;</span><br><span class=\"line\">      <span class=\"function\">TCP_socket <span class=\"title\">tcp_socket</span><span class=\"params\">(bind_address_info.address,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            bind_address_info.network_namespace, m_tcp_port,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            m_backlog, m_port_timeout)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/* socket 初始化，底层调用的还是 socket/bind/listen 函数 */</span></span><br><span class=\"line\">      MYSQL_SOCKET mysql_socket = tcp_socket.get_listener_socket();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (mysql_socket.fd == INVALID_SOCKET) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\">Socket_attr <span class=\"title\">s</span><span class=\"params\">(Socket_type::TCP_SOCKET,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    bind_address_info.network_namespace)</span></span>;</span><br><span class=\"line\">      m_socket_map.insert(</span><br><span class=\"line\">          <span class=\"built_in\">std</span>::pair&lt;MYSQL_SOCKET, Socket_attr&gt;(mysql_socket, s));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* 将所有监听的 socket 信息加入到 m_poll_info 中 */</span></span><br><span class=\"line\">  setup_connection_events(m_socket_map);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* socker 初始化 */</span></span><br><span class=\"line\"><span class=\"function\">MYSQL_SOCKET <span class=\"title\">TCP_socket::get_listener_socket</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  MYSQL_SOCKET listener_socket = create_socket(ai_ptr.<span class=\"built_in\">get</span>(), AF_INET, &amp;a);</span><br><span class=\"line\">  mysql_socket_bind(listener_socket, a-&gt;ai_addr, a-&gt;ai_addrlen);</span><br><span class=\"line\">  mysql_socket_listen(listener_socket, <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(m_backlog);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Mysqld_socket_listener::setup_connection_events(</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">socket_map_t</span> &amp;socket_map) &#123;</span><br><span class=\"line\">#ifdef HAVE_POLL</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">socket_map_t</span>::size_type total_number_of_addresses_to_bind =</span><br><span class=\"line\">      socket_map.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">  m_poll_info.m_fds.reserve(total_number_of_addresses_to_bind);</span><br><span class=\"line\">  m_poll_info.m_pfs_fds.reserve(total_number_of_addresses_to_bind);</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> &amp;element : socket_map) add_socket_to_listener(element.first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Mysqld_socket_listener::add_socket_to_listener(</span><br><span class=\"line\">    MYSQL_SOCKET listen_socket) &#123;</span><br><span class=\"line\">  mysql_socket_set_thread_owner(listen_socket);</span><br><span class=\"line\"></span><br><span class=\"line\">#ifdef HAVE_POLL</span><br><span class=\"line\">  m_poll_info.m_fds.emplace_back(</span><br><span class=\"line\">      pollfd&#123;mysql_socket_getfd(listen_socket), POLLIN, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">  m_poll_info.m_pfs_fds.push_back(listen_socket);</span><br><span class=\"line\">#<span class=\"keyword\">else</span></span><br><span class=\"line\">  FD_SET(mysql_socket_getfd(listen_socket), &amp;m_select_info.m_client_fds);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((uint)mysql_socket_getfd(listen_socket) &gt;</span><br><span class=\"line\">      m_select_info.m_max_used_connection)</span><br><span class=\"line\">    m_select_info.m_max_used_connection = mysql_socket_getfd(listen_socket);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"连接建立\"><a href=\"#连接建立\" class=\"headerlink\" title=\"连接建立\"></a>连接建立</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mysqld_main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  mysqld_socket_acceptor-&gt;connection_event_loop();</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">connection_event_loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Connection_handler_manager *mgr =</span><br><span class=\"line\">    Connection_handler_manager::get_instance();</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!connection_events_loop_aborted()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 监听到连接事件，开始 channel 处理 */</span></span><br><span class=\"line\">    Channel_info *channel_info = m_listener-&gt;listen_for_connection_event();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (channel_info != <span class=\"literal\">NULL</span>) mgr-&gt;process_new_connection(channel_info);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Channel_info *<span class=\"title\">Mysqld_socket_listener::listen_for_connection_event</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> HAVE_POLL</span></span><br><span class=\"line\">  <span class=\"comment\">/* 通过 poll 机制进行监听 */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> retval = poll(&amp;m_poll_info.m_fds[<span class=\"number\">0</span>], m_socket_map.<span class=\"built_in\">size</span>(), <span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">  m_select_info.m_read_fds = m_select_info.m_client_fds;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> retval = select((<span class=\"keyword\">int</span>)m_select_info.m_max_used_connection,</span><br><span class=\"line\">                      &amp;m_select_info.m_read_fds, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> is_unix_socket = <span class=\"literal\">false</span>, is_admin_sock;</span><br><span class=\"line\">  <span class=\"comment\">/* 获取到一个 ready 的 socket */</span></span><br><span class=\"line\">  MYSQL_SOCKET listen_sock = get_ready_socket(&amp;is_unix_socket, &amp;is_admin_sock);</span><br><span class=\"line\">  DBUG_ASSERT(mysql_socket_getfd(listen_sock) != INVALID_SOCKET);</span><br><span class=\"line\">  </span><br><span class=\"line\">  MYSQL_SOCKET connect_sock;</span><br><span class=\"line\">  accept_connection(listen_sock, &amp;connect_sock);</span><br><span class=\"line\"></span><br><span class=\"line\">  Channel_info *channel_info = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (is_unix_socket)</span><br><span class=\"line\">    channel_info = <span class=\"keyword\">new</span> (<span class=\"built_in\">std</span>::nothrow) Channel_info_local_socket(connect_sock);</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    channel_info = <span class=\"keyword\">new</span> (<span class=\"built_in\">std</span>::nothrow)</span><br><span class=\"line\">        Channel_info_tcpip_socket(connect_sock, is_admin_sock);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Connection_handler_manager::process_new_connection</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    Channel_info *channel_info)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (m_connection_handler-&gt;add_connection(channel_info)) &#123;</span><br><span class=\"line\">    inc_aborted_connects();</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> channel_info;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 一对一处理模式 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Per_thread_connection_handler::add_connection</span><span class=\"params\">(Channel_info *channel_info)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">/* 检查是否有空闲的线程 */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!check_idle_thread_and_enqueue_connection(channel_info)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  channel_info-&gt;set_prior_thr_create_utime();</span><br><span class=\"line\">  <span class=\"comment\">/* 新建一个线程进行处理 */</span></span><br><span class=\"line\">  error =</span><br><span class=\"line\">      mysql_thread_create(key_thread_one_connection, &amp;id, &amp;connection_attrib,</span><br><span class=\"line\">                          handle_connection, (<span class=\"keyword\">void</span> *)channel_info);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">    connection_errors_internal++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!create_thd_err_log_throttle.<span class=\"built_in\">log</span>())</span><br><span class=\"line\">      LogErr(ERROR_LEVEL, ER_CONN_PER_THREAD_NO_THREAD, error);</span><br><span class=\"line\">    channel_info-&gt;send_error_and_close_channel(ER_CANT_CREATE_THREAD, error,</span><br><span class=\"line\">                                               <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    im::global_manager_dec_connection(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *<span class=\"title\">handle_connection</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  Channel_info *channel_info = <span class=\"keyword\">static_cast</span>&lt;Channel_info *&gt;(arg);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (my_thread_init()) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    THD *thd = init_new_thd(channel_info);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (thd_connection_alive(thd)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* 开始请求处理 */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (do_command(thd)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">/* thread 复用 */</span></span><br><span class=\"line\">    channel_info = Per_thread_connection_handler::block_until_new_connection();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"请求处理\"><a href=\"#请求处理\" class=\"headerlink\" title=\"请求处理\"></a>请求处理</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">do_command</span><span class=\"params\">(THD *thd,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">bool</span>(THD *, <span class=\"keyword\">const</span> COM_DATA *,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                   <span class=\"keyword\">enum</span> enum_server_command)&gt; *dispatcher)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  thd-&gt;m_server_idle = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  rc = thd-&gt;get_protocol()-&gt;get_command(&amp;com_data, &amp;command);</span><br><span class=\"line\">  thd-&gt;m_server_idle = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  return_value = dispatch_command(thd, &amp;com_data, command);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dispatch_command</span><span class=\"params\">(THD *thd, <span class=\"keyword\">const</span> COM_DATA *com_data,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      <span class=\"keyword\">enum</span> enum_server_command command)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  thd-&gt;set_command(command);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (command) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">case</span> COM_QUERY: &#123;...&#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h2><p>MySQL 5.7 可以参考：<a href=\"http://mysql.taobao.org/monthly/2016/07/04/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2016/07/04/</a></p>\n","site":{"data":{}},"excerpt":"<p>本文结合 MySQL 8.0 的源码对 MySQL 的连接处理过程进行一个介绍，其它版本与 8.0 版本基本类似。</p>","more":"<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>在介绍 MySQL 建连过程之前，先整体看一下相关类的关系：</p>\n<img src=\"/images/connection-handler-1.jpg\" width=\"88%\"/>\n\n<p>MySQL 8.0 在 Linux 平台下使用的是 poll 机制，默认情况下每个用户连接会使用一个单独的线程进行处理。</p>\n<h2 id=\"MySQL-建连过程\"><a href=\"#MySQL-建连过程\" class=\"headerlink\" title=\"MySQL 建连过程\"></a>MySQL 建连过程</h2><p>MySQL 建连过程可以分为以下几个步骤：</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> Connection_acceptor&lt;Mysqld_socket_listener&gt; *mysqld_socket_acceptor = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> <span class=\"title\">network_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">/* 解析网络配置信息 */</span></span><br><span class=\"line\">  Mysqld_socket_listener *mysqld_socket_listener = <span class=\"keyword\">new</span> (<span class=\"built_in\">std</span>::nothrow)</span><br><span class=\"line\">      Mysqld_socket_listener(bind_addresses_info, mysqld_port,</span><br><span class=\"line\">                             admin_address_info, mysqld_admin_port,</span><br><span class=\"line\">                             listen_admin_interface_in_separate_thread,</span><br><span class=\"line\">                             back_log, mysqld_port_timeout, unix_sock_name);</span><br><span class=\"line\"></span><br><span class=\"line\">  mysqld_socket_acceptor = <span class=\"keyword\">new</span> (<span class=\"built_in\">std</span>::nothrow)</span><br><span class=\"line\">      Connection_acceptor&lt;Mysqld_socket_listener&gt;(mysqld_socket_listener);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">/* 初始化监听端口 */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mysqld_socket_acceptor-&gt;init_connection_acceptor())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">init_connection_acceptor</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_listener-&gt;setup_listener(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Mysqld_socket_listener::setup_listener</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (m_tcp_port) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> &amp;bind_address_info : m_bind_addresses) &#123;</span><br><span class=\"line\">      <span class=\"function\">TCP_socket <span class=\"title\">tcp_socket</span><span class=\"params\">(bind_address_info.address,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            bind_address_info.network_namespace, m_tcp_port,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            m_backlog, m_port_timeout)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/* socket 初始化，底层调用的还是 socket/bind/listen 函数 */</span></span><br><span class=\"line\">      MYSQL_SOCKET mysql_socket = tcp_socket.get_listener_socket();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (mysql_socket.fd == INVALID_SOCKET) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\">Socket_attr <span class=\"title\">s</span><span class=\"params\">(Socket_type::TCP_SOCKET,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    bind_address_info.network_namespace)</span></span>;</span><br><span class=\"line\">      m_socket_map.insert(</span><br><span class=\"line\">          <span class=\"built_in\">std</span>::pair&lt;MYSQL_SOCKET, Socket_attr&gt;(mysql_socket, s));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* 将所有监听的 socket 信息加入到 m_poll_info 中 */</span></span><br><span class=\"line\">  setup_connection_events(m_socket_map);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* socker 初始化 */</span></span><br><span class=\"line\"><span class=\"function\">MYSQL_SOCKET <span class=\"title\">TCP_socket::get_listener_socket</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  MYSQL_SOCKET listener_socket = create_socket(ai_ptr.<span class=\"built_in\">get</span>(), AF_INET, &amp;a);</span><br><span class=\"line\">  mysql_socket_bind(listener_socket, a-&gt;ai_addr, a-&gt;ai_addrlen);</span><br><span class=\"line\">  mysql_socket_listen(listener_socket, <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(m_backlog);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Mysqld_socket_listener::setup_connection_events(</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">socket_map_t</span> &amp;socket_map) &#123;</span><br><span class=\"line\">#ifdef HAVE_POLL</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">socket_map_t</span>::size_type total_number_of_addresses_to_bind =</span><br><span class=\"line\">      socket_map.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">  m_poll_info.m_fds.reserve(total_number_of_addresses_to_bind);</span><br><span class=\"line\">  m_poll_info.m_pfs_fds.reserve(total_number_of_addresses_to_bind);</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> &amp;element : socket_map) add_socket_to_listener(element.first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Mysqld_socket_listener::add_socket_to_listener(</span><br><span class=\"line\">    MYSQL_SOCKET listen_socket) &#123;</span><br><span class=\"line\">  mysql_socket_set_thread_owner(listen_socket);</span><br><span class=\"line\"></span><br><span class=\"line\">#ifdef HAVE_POLL</span><br><span class=\"line\">  m_poll_info.m_fds.emplace_back(</span><br><span class=\"line\">      pollfd&#123;mysql_socket_getfd(listen_socket), POLLIN, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">  m_poll_info.m_pfs_fds.push_back(listen_socket);</span><br><span class=\"line\">#<span class=\"keyword\">else</span></span><br><span class=\"line\">  FD_SET(mysql_socket_getfd(listen_socket), &amp;m_select_info.m_client_fds);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((uint)mysql_socket_getfd(listen_socket) &gt;</span><br><span class=\"line\">      m_select_info.m_max_used_connection)</span><br><span class=\"line\">    m_select_info.m_max_used_connection = mysql_socket_getfd(listen_socket);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"连接建立\"><a href=\"#连接建立\" class=\"headerlink\" title=\"连接建立\"></a>连接建立</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mysqld_main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  mysqld_socket_acceptor-&gt;connection_event_loop();</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">connection_event_loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Connection_handler_manager *mgr =</span><br><span class=\"line\">    Connection_handler_manager::get_instance();</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!connection_events_loop_aborted()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 监听到连接事件，开始 channel 处理 */</span></span><br><span class=\"line\">    Channel_info *channel_info = m_listener-&gt;listen_for_connection_event();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (channel_info != <span class=\"literal\">NULL</span>) mgr-&gt;process_new_connection(channel_info);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Channel_info *<span class=\"title\">Mysqld_socket_listener::listen_for_connection_event</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> HAVE_POLL</span></span><br><span class=\"line\">  <span class=\"comment\">/* 通过 poll 机制进行监听 */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> retval = poll(&amp;m_poll_info.m_fds[<span class=\"number\">0</span>], m_socket_map.<span class=\"built_in\">size</span>(), <span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">  m_select_info.m_read_fds = m_select_info.m_client_fds;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> retval = select((<span class=\"keyword\">int</span>)m_select_info.m_max_used_connection,</span><br><span class=\"line\">                      &amp;m_select_info.m_read_fds, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> is_unix_socket = <span class=\"literal\">false</span>, is_admin_sock;</span><br><span class=\"line\">  <span class=\"comment\">/* 获取到一个 ready 的 socket */</span></span><br><span class=\"line\">  MYSQL_SOCKET listen_sock = get_ready_socket(&amp;is_unix_socket, &amp;is_admin_sock);</span><br><span class=\"line\">  DBUG_ASSERT(mysql_socket_getfd(listen_sock) != INVALID_SOCKET);</span><br><span class=\"line\">  </span><br><span class=\"line\">  MYSQL_SOCKET connect_sock;</span><br><span class=\"line\">  accept_connection(listen_sock, &amp;connect_sock);</span><br><span class=\"line\"></span><br><span class=\"line\">  Channel_info *channel_info = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (is_unix_socket)</span><br><span class=\"line\">    channel_info = <span class=\"keyword\">new</span> (<span class=\"built_in\">std</span>::nothrow) Channel_info_local_socket(connect_sock);</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    channel_info = <span class=\"keyword\">new</span> (<span class=\"built_in\">std</span>::nothrow)</span><br><span class=\"line\">        Channel_info_tcpip_socket(connect_sock, is_admin_sock);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Connection_handler_manager::process_new_connection</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    Channel_info *channel_info)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (m_connection_handler-&gt;add_connection(channel_info)) &#123;</span><br><span class=\"line\">    inc_aborted_connects();</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> channel_info;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 一对一处理模式 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Per_thread_connection_handler::add_connection</span><span class=\"params\">(Channel_info *channel_info)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">/* 检查是否有空闲的线程 */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!check_idle_thread_and_enqueue_connection(channel_info)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  channel_info-&gt;set_prior_thr_create_utime();</span><br><span class=\"line\">  <span class=\"comment\">/* 新建一个线程进行处理 */</span></span><br><span class=\"line\">  error =</span><br><span class=\"line\">      mysql_thread_create(key_thread_one_connection, &amp;id, &amp;connection_attrib,</span><br><span class=\"line\">                          handle_connection, (<span class=\"keyword\">void</span> *)channel_info);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">    connection_errors_internal++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!create_thd_err_log_throttle.<span class=\"built_in\">log</span>())</span><br><span class=\"line\">      LogErr(ERROR_LEVEL, ER_CONN_PER_THREAD_NO_THREAD, error);</span><br><span class=\"line\">    channel_info-&gt;send_error_and_close_channel(ER_CANT_CREATE_THREAD, error,</span><br><span class=\"line\">                                               <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    im::global_manager_dec_connection(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *<span class=\"title\">handle_connection</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  Channel_info *channel_info = <span class=\"keyword\">static_cast</span>&lt;Channel_info *&gt;(arg);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (my_thread_init()) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    THD *thd = init_new_thd(channel_info);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (thd_connection_alive(thd)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* 开始请求处理 */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (do_command(thd)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">/* thread 复用 */</span></span><br><span class=\"line\">    channel_info = Per_thread_connection_handler::block_until_new_connection();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"请求处理\"><a href=\"#请求处理\" class=\"headerlink\" title=\"请求处理\"></a>请求处理</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">do_command</span><span class=\"params\">(THD *thd,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">bool</span>(THD *, <span class=\"keyword\">const</span> COM_DATA *,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                   <span class=\"keyword\">enum</span> enum_server_command)&gt; *dispatcher)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  thd-&gt;m_server_idle = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  rc = thd-&gt;get_protocol()-&gt;get_command(&amp;com_data, &amp;command);</span><br><span class=\"line\">  thd-&gt;m_server_idle = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  return_value = dispatch_command(thd, &amp;com_data, command);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dispatch_command</span><span class=\"params\">(THD *thd, <span class=\"keyword\">const</span> COM_DATA *com_data,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                      <span class=\"keyword\">enum</span> enum_server_command command)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  thd-&gt;set_command(command);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (command) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">case</span> COM_QUERY: &#123;...&#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h2><p>MySQL 5.7 可以参考：<a href=\"http://mysql.taobao.org/monthly/2016/07/04/\" target=\"_blank\" rel=\"noopener\">http://mysql.taobao.org/monthly/2016/07/04/</a></p>"},{"title":"InnoDB 简介","date":"2020-07-18T12:02:35.000Z","_content":"\n最近在 Percona 的网站上看到了一张介绍 InnoDB 整体架构的图片，觉得总结的非常好，引用如下。\n\n<!-- more -->\n\n## InnoDB 整体架构\n\n<img src=\"/images/innodb-intro.png\" width=\"88%\"/>","source":"_posts/innodb-intro.md","raw":"---\ntitle: InnoDB 简介\ndate: 2020-07-18 20:02:35\ntags:\n- InnoDB\ncategories: \n- 数据库\n---\n\n最近在 Percona 的网站上看到了一张介绍 InnoDB 整体架构的图片，觉得总结的非常好，引用如下。\n\n<!-- more -->\n\n## InnoDB 整体架构\n\n<img src=\"/images/innodb-intro.png\" width=\"88%\"/>","slug":"innodb-intro","published":1,"updated":"2020-07-19T08:46:42.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgluc72e0009owgm9cls1gn2","content":"<p>最近在 Percona 的网站上看到了一张介绍 InnoDB 整体架构的图片，觉得总结的非常好，引用如下。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"InnoDB-整体架构\"><a href=\"#InnoDB-整体架构\" class=\"headerlink\" title=\"InnoDB 整体架构\"></a>InnoDB 整体架构</h2><img src=\"/images/innodb-intro.png\" width=\"88%\"/>","site":{"data":{}},"excerpt":"<p>最近在 Percona 的网站上看到了一张介绍 InnoDB 整体架构的图片，觉得总结的非常好，引用如下。</p>","more":"<h2 id=\"InnoDB-整体架构\"><a href=\"#InnoDB-整体架构\" class=\"headerlink\" title=\"InnoDB 整体架构\"></a>InnoDB 整体架构</h2><img src=\"/images/innodb-intro.png\" width=\"88%\"/>"},{"title":"InnoDB Buffer Page 生命周期","date":"2020-08-23T08:15:50.000Z","_content":"\nInnoDB 没有使用操作系统自己的 Page Cache 机制，而是自己设计了一套 Buffer Pool 来进行 Page 的管理，关于 InnoDB Buffer Pool 的介绍，可以参考[这篇文章](http://mysql.taobao.org/monthly/2017/05/01/)，里面对 InnoDB Buffer Pool 作了比较深入的介绍。本文尝试从另外一个角度介绍一下一个 Buffer Page 的生命周期。本文给出的所有示例代码均基于 MySQL 8.0.18 版本。\n\n<!-- more -->\n\n## 申请\n\n### Page 读取\n\nPage 的读取有一个统一的入口函数 `buffer_page_get_gen` ，该方法的主要入参为 `page_id` ，即获取指定的页，MySQL 8.0 中的主要流程如下：\n\n```c++\n/* 以 Buf_fetch_normal 为例 */\n|--> fetch.single_page\n|    |--> get(block) // loop\n|    |    |--> lookup\n|    |    |    |--> buf_page_hash_get_low // 检查 page_hash 中是否存在\n|    |    |--> buf_block_fix // buf_fix_count 计数 +1\n|    |    |\n|    |    |--> read_page\n|    |    |    |--> buf_read_page // 从文件中读取 page\n|    |    |    |    |--> buf_read_page_low\n|    |    |    |    |    |--> buf_page_init_for_read\n|    |    |    |    |    |    |--> buf_LRU_get_free_block // 申请 1 个 block\n|    |    |    |    |    |    |--> buf_page_hash_get_low // 再次检查 page_hash 中是否存在\n|    |    |    |    |    |    |--> buf_page_init\n|    |    |    |    |    |    |    |--> buf_block_init_low\n|    |    |    |    |    |    |    |--> buf_page_init_low\n|    |    |    |    |    |    |    |--> HASH_INSERT // 插入 page_hash\n|    |    |    |    |    |    |--> buf_page_set_io_fix // io_fix 设置为 BUF_IO_READ\n|    |    |    |    |    |    |--> buf_LRU_add_block // 添加到 LRU\n|    |    |    |    |    |\n|    |    |    |    |    |--> _fil_io // 读取文件\n|    |    |    |    |    |--> buf_page_io_complete // 同步模式 IO 完成\n|    |    |    |    |    |    |--> buf_page_set_io_fix // io_fix 设置为 BUF_IO_NONE\n|    |\n|    |--> buf_page_make_young_if_needed\n|    |\n|    |--> buf_read_ahead_linear\n```\n\n读取 1 个 Page 时，首先会检查 `page_hash` ，如果 `page_hash` 中存在，则直接读取并设置 `buf_fix_count` 后返回；否则需要从文件中读取 Page，从文件中读取 Page 时首先需要申请 1 个 Block（具体申请过程在后面介绍），然后添加到 `page_hash` 和 `LRU` 列表中，最后进行数据的读取。对于 1 个新的 Page 的创建过程，入口函数为 `buf_page_create` ，基本流程如下：\n\n```c++\n/* buf_page_create */\n|--> buf_page_create\n|    |--> buf_LRU_get_free_block // 申请 1 个 block\n|    |--> buf_page_hash_get_low // 检查 page_hash 中是否存在\n|    |\n|    |--> buf_page_init\n|    |    |--> buf_block_init_low\n|    |    |--> buf_page_init_low\n|    |    |--> HASH_INSERT // 插入 page_hash\n|    |--> buf_block_buf_fix_inc // buf_fix_count 计数 +1\n|    |--> buf_LRU_add_block // 添加到 LRU\n```\n\n### Block 申请\n\nBlock 申请的入口函数为 `buf_LRU_get_free_block` ，该方法会从 Buffer Pool 中申请 1 个 Block 供后续的 Page 读取使用。Block 申请的主要流程如下：\n\n```c++\n|--> buf_LRU_get_free_block // loop\n|    |--> buf_LRU_get_free_only // 从 free_list 分配\n|    |\n|    |--> buf_LRU_scan_and_free_block // 从 LRU 中回收\n|    |    |--> buf_LRU_free_from_unzip_LRU_list\n|    |    |    |--> buf_LRU_free_page\n|    |    |--> buf_LRU_free_from_common_LRU_list\n|    |    |    |--> buf_flush_ready_for_replace\n|    |    |    |--> buf_LRU_free_page\n|    |\n|    |--> os_event_set(buf_flush_event) // 唤醒刷脏线程\n|    |\n|    |--> buf_flush_single_page_from_LRU // 从 LRU 中刷脏\n|    |    |--> buf_LRU_free_page\n|    |    |--> buf_flush_page\n```\n\nBuffer Pool 中维护了三个列表：`free_list` 、`LRU` 、`flush_list` 。其中 `free_list` 列表是当前可供使用的 Block，`LRU` 列表中保存了当前所有已经使用的 Block，`flush_list` 列表中保存了所有脏页 Block。申请 1 个 Block 时：\n\n1. 首先判断当前 `free_list` 列表是否为空，若 `free_list` 列表非空，则直接从 `free_list` 列表中进行分配。若无法直接从 `free_list` 列表分配，则会尝试从 `LRU` 列表中进行回收。\n2. `LRU` 是一个非严格的最近使用列表，从 `LRU` 列表回收时会从列表尾部往前遍历（加入 `LRU` 列表时从头部加入），如果找到可回收的 Page（遇到脏页会跳过），则会释放 Page 并将对应的 Block 重新放入 `free_list` 列表中。`LRU` 列表的遍历过程并不是无限的，例如：在第一次遍历时，当检查的 Page 数目达到 `BUF_LRU_SEARCH_SCAN_THRESHOLD` 时会退出遍历过程。\n3. 如果无法从 `LRU` 列表中回收 Block，则会唤醒刷脏线程，刷脏线程的处理流程在下面会做介绍。\n4. 同时还会从 `LRU` 列表中进行刷脏，该过程是同步的，依然是遍历 `LRU` 列表，但此时不会跳过脏页，遇到脏页直接进行刷脏。\n\n## 管理\n\n### 加入 flush_list\n\n前面提到过 `flush_list` 列表中保存的是所有脏页 Block，脏页在 mtr 提交时会加入 `flush_list` 中，基本过程如下：\n\n```c++\n|--> mtr_t::Command::execute()\n|    |--> add_dirty_page_to_flush_list\n|    |    |--> buf_flush_note_modification\n|    |    |    |--> buf_flush_insert_into_flush_list\n|    |    |    |    |--> UT_LIST_ADD_FIRST // 插入 flush_list 头部\n```\n\n注意：`flush_list` 是一个非严格有序的列表（可以看做按照 `oldest_modification` 有序），脏页插入列表后位置不再修改，再次修改时仅修改 `newest_modification` 。\n\n### 加入 LRU\n\n`LRU` 列表中保存了当前所有已经使用的 Block，申请完 1 个 Block 并完成初始化后会加到 `LRU` 列表中（默认会加入到 old 区域头部），加入 `LRU` 列表的基本过程如下：\n\n```c++\n|--> buf_LRU_add_block\n|    |--> buf_LRU_add_block_low\n|    |    |--> UT_LIST_ADD_FIRST // 插入 young 区域头部\n|    |    |--> UT_LIST_INSERT_AFTER // 插入 old 区域头部\n|    |    |\n|    |    |--> buf_LRU_old_adjust_len // 调整 LRU\n```\n\n### 管理 LRU\n\n前面提到 `LRU` 是一个非严格的最近使用列表，InnoDB 将 `LRU` 列表划分为两个区域：young 区域和 old 区域。`LRU` 列表的示意图如下：\n\n```c++\n/** LRU 列表示意图\n                                                LRU_old\n                                                   |\n**********************young************************|********old*********\n|==================================================|===================|\n\n几个主要的常量：\nBUF_LRU_OLD_TOLERANCE      20\nBUF_LRU_NON_OLD_MIN_LEN    5\nBUF_LRU_OLD_MIN_LEN        512\nBUF_LRU_OLD_RATIO_DIV      1024\n\n参数控制：\ninnodb_old_block_pct       old 区域占比\n\n*/\n```\n\n`buf_LRU_old_adjust_len`  方法会根据 `innodb_old_block_pct` 参数，维护 young 区域和 old 区域的长度，主要逻辑如下：\n\n1. 当 `LRU` 长度小于 ` BUF_LRU_OLD_MIN_LEN` 时，不划分区域。\n2. 不是每次操作 `LRU` 列表后都需要立即调整，`BUF_LRU_OLD_TOLERANCE`  可以看成是容忍范围。\n3. 当 old 区域变大时，LRU_old 指针向前移动；反之向后移动。\n\n当 Block 被再次访问时，会触发 `buf_page_make_young_if_needed` 函数进行 Block 位置的调整，基本过程如下：\n\n```c++\n|--> buf_page_make_young_if_needed\n|    |--> buf_page_peek_if_too_old // 判断访问间隔\n|    |    |--> buf_page_peek_if_young // 判断 young 区域位置\n|    |\n|    |--> buf_page_make_young\n|    |    |--> buf_LRU_make_block_young\n|    |    |    |--> buf_LRU_remove_block\n|    |    |    |--> buf_LRU_add_block_low\n```\n\n`buf_page_make_young_if_needed` 移动 Block 时需要考虑：\n\n1. 访问间隔需要大于 `buf_LRU_old_threshold_ms` 。\n2. 当 Block 在 young 区域前 1/4 时，不需要移动。\n\nInnoDB 中 `LRU` 列表的设计虽然简单，但是也有许多优化在里面，感兴趣的同学可以仔细研究，本文仅是一个简单的介绍。\n\n## 回收\n\n### 释放 Page\n\n前面提到，当 `free_list` 列表为空时，会首先尝试从 `LRU` 列表中进行回收，Page 的释放入口函数为 `buf_LRU_free_page` ，该方法的主要处理流程如下：\n\n```c++\n|--> buf_LRU_free_page\n|    |--> buf_page_can_relocate // 检查 buf_fix_count 计数和 io_fix 状态\n|    |\n|    |--> buf_LRU_block_remove_hashed // 从 LRU 和 page_hash 中删除\n|    |    |--> buf_LRU_remove_block\n|    |    |    |--> buf_LRU_old_adjust_len\n|    |    |--> HASH_DELETE\n|    |\n|    |--> btr_search_drop_page_hash_index // 从 AHI 中删除\n|    |\n|    |--> buf_LRU_block_free_hashed_page // 放回 free_list\n|    |    |--> buf_LRU_block_free_non_file_page\n```\n\n释放 1 个 Page 时，首先需要检查 `io_fix` 状态和 `buf_fix_count` 计数，确保当前 Page 没有被使用，然后将 Block 从依次从 `LRU` 列表、`page_hash` 、`AHI` 中删除，最后将 Block 重新放入到 `free_list` 列表中。\n\n### 同步刷脏\n\n同步刷脏的入口函数为 `buf_flush_page` ，同步刷脏过程仅会刷 1 个 Page，保证能够获取到 1 个可用的 Block，主要处理流程如下：\n\n```c++\n|--> buf_flush_page // 刷单个 page\n|    |--> buf_page_set_io_fix // io_fix 设置为 BUF_IO_WRITE\n|    |--> buf_flush_write_block_low\n|    |    |--> log_write_up_to // 写 redo\n|    |    |\n|    |    |--> fil_io\n|    |    |--> buf_dblwr_write_single_page // 写数据页\n|    |    |\n|    |    |--> fil_flush\n|    |    |--> buf_page_io_complete\n|    |    |    |--> buf_flush_write_complete\n|    |    |    |    |--> buf_flush_remove\n|    |    |    |    |--> buf_page_set_io_fix // io_fix 设置为 BUF_IO_NONE\n|    |    |    |\n|    |    |    |--> buf_LRU_free_page\n```\n\nInnoDB 通过严格的 WAL 机制保证数据的一致性，刷脏过程同样如此。首先需要保证对应的日志文件落盘，然后再写入数据页。最后将 Block 从 `flush_list` 列表中移除，此时 Page 变成可回收状态，再次调用 `buf_LRU_free_page` 进行回收。\n\n同步刷脏的过程不仅在获取 Block 时会被调用，在表删除的时候同样会被调用，表删除时会根据 `space_id` 进行批量的刷脏，入口函数为 `buf_LRU_flush_or_remove_pages` ，处理流程如下：\n\n```c++\n|--> buf_LRU_flush_or_remove_pages // 根据 space_id 刷脏\n|    |--> buf_LRU_drop_page_hash_for_tablespace // 遍历 LRU\n|    |    |--> buf_LRU_drop_page_hash_batch\n|    |    |    |--> btr_search_drop_page_hash_when_freed\n|    |    |    |    |--> buf_page_get_gen\n|    |    |    |    |--> btr_search_drop_page_hash_index // 从 AHI 中删除\n|    |\n|    |--> buf_LRU_remove_pages\n|    |    |--> buf_LRU_remove_all_pages // 遍历 LRU\n|    |    |    |--> buf_LRU_block_remove_hashed // 从 LRU 和 page_hash 中删除\n|    |    |    |--> buf_LRU_block_free_hashed_page // 放回 free_list\n|    |    |\n|    |    |--> buf_flush_dirty_pages\n|    |    |    |--> buf_flush_or_remove_pages // 遍历 flush_list\n|    |    |    |    |--> buf_flush_or_remove_page\n|    |    |    |    |    |--> buf_flush_remove\n|    |    |    |    |    |\n|    |    |    |    |    |--> buf_flush_page\n```\n\n具体的过程在此不再赘述，大家可以自己去阅读相应的代码。需要注意的是：如果单个 session 中使用了临时表，那么在 session 退出的时候，也会进入到上述的刷脏流程，当 `LRU` 列表很大时，session 退出的性能将会受到很大的影响。\n\n### 异步刷脏\n\n除了同步刷脏之外，MySQL 中还引入单独的刷脏线程进行异步刷脏。刷脏线程按照功能划分包括两种：coordinator 线程和 cleaner 线程。coordinator 线程会计算最大的刷脏量，然后分配刷脏任务给 cleaner 线程，cleaner 线程进行实际的刷脏工作（coordinator 线程本身也会参与刷脏）。异步刷脏的入口函数为 `buf_flush_page_cleaner_init` ，基本流程如下：\n\n```c++\n|--> buf_flush_page_coordinator_thread\n|    |--> os_event_wait(buf_flush_event)\n|    \n|    /* loop */\n|    |--> page_cleaner_flush_pages_recommendation // 计算最大刷脏量\n|    |--> pc_request // 任务分发，slot 数目等于 bp_instance 数目\n|    |    |--> os_event_set(page_cleaner->is_requested)\n|    |--> pc_flush_slot // 参与刷脏\n|    |--> pc_wait_finished\n\n\n|--> buf_flush_page_cleaner_thread\n|    |--> os_event_wait(page_cleaner->is_requested)\n|    |--> pc_flush_slot // 1 个线程处理 1 个 bp_instance\n|    |    |--> buf_flush_LRU_list // 从 LRU 中刷脏\n|    |    |    |--> buf_flush_do_batch(BUF_FLUSH_LRU)\n|    |    |\n|    |    |--> buf_flush_do_batch(BUF_FLUSH_LIST) // 从 flush_list 刷脏\n|    |    |    |--> buf_flush_batch\n|    |    |    |    |--> buf_do_LRU_batch\n|    |    |    |    |    |--> buf_free_from_unzip_LRU_list_batch\n|    |    |    |    |    |--> buf_flush_LRU_list_batch\n|    |    |    |    |    |    |--> buf_LRU_free_page\n|    |    |    |    |    |    |--> buf_flush_page_and_try_neighbors\n|    |    |    |    |    |    |    |--> buf_flush_try_neighbors\n|    |    |    |    |    |    |    |    |--> buf_flush_page\n|    |    |    |    |\n|    |    |    |    |--> buf_do_flush_list_batch\n|    |    |    |    |    |--> buf_flush_page_and_try_neighbors\n```\n\n异步刷脏的具体过程可以参考[这篇文章](http://mysql.taobao.org/monthly/2018/09/02/)，异步刷脏过程中有一个非常重要的点就是 `page_cleaner_flush_pages_recommendation` 计算最大刷脏量，相关的细节在此不再展开，后面有机会再单独整理一篇各种后台线程的更新逻辑。\n\n## 总结\n\n本文从申请、管理、回收三部分对 InnoDB Buffer Page 的生命周期管理进行了介绍，文中的内容只是一个基本概要，更多的细节还需要读者在阅读代码的过程中慢慢发掘。","source":"_posts/innodb-buffer-page.md","raw":"---\ntitle: InnoDB Buffer Page 生命周期\ndate: 2020-08-23 16:15:50\ntags:\n- InnoDB\ncategories: \n- 数据库\n\n---\n\nInnoDB 没有使用操作系统自己的 Page Cache 机制，而是自己设计了一套 Buffer Pool 来进行 Page 的管理，关于 InnoDB Buffer Pool 的介绍，可以参考[这篇文章](http://mysql.taobao.org/monthly/2017/05/01/)，里面对 InnoDB Buffer Pool 作了比较深入的介绍。本文尝试从另外一个角度介绍一下一个 Buffer Page 的生命周期。本文给出的所有示例代码均基于 MySQL 8.0.18 版本。\n\n<!-- more -->\n\n## 申请\n\n### Page 读取\n\nPage 的读取有一个统一的入口函数 `buffer_page_get_gen` ，该方法的主要入参为 `page_id` ，即获取指定的页，MySQL 8.0 中的主要流程如下：\n\n```c++\n/* 以 Buf_fetch_normal 为例 */\n|--> fetch.single_page\n|    |--> get(block) // loop\n|    |    |--> lookup\n|    |    |    |--> buf_page_hash_get_low // 检查 page_hash 中是否存在\n|    |    |--> buf_block_fix // buf_fix_count 计数 +1\n|    |    |\n|    |    |--> read_page\n|    |    |    |--> buf_read_page // 从文件中读取 page\n|    |    |    |    |--> buf_read_page_low\n|    |    |    |    |    |--> buf_page_init_for_read\n|    |    |    |    |    |    |--> buf_LRU_get_free_block // 申请 1 个 block\n|    |    |    |    |    |    |--> buf_page_hash_get_low // 再次检查 page_hash 中是否存在\n|    |    |    |    |    |    |--> buf_page_init\n|    |    |    |    |    |    |    |--> buf_block_init_low\n|    |    |    |    |    |    |    |--> buf_page_init_low\n|    |    |    |    |    |    |    |--> HASH_INSERT // 插入 page_hash\n|    |    |    |    |    |    |--> buf_page_set_io_fix // io_fix 设置为 BUF_IO_READ\n|    |    |    |    |    |    |--> buf_LRU_add_block // 添加到 LRU\n|    |    |    |    |    |\n|    |    |    |    |    |--> _fil_io // 读取文件\n|    |    |    |    |    |--> buf_page_io_complete // 同步模式 IO 完成\n|    |    |    |    |    |    |--> buf_page_set_io_fix // io_fix 设置为 BUF_IO_NONE\n|    |\n|    |--> buf_page_make_young_if_needed\n|    |\n|    |--> buf_read_ahead_linear\n```\n\n读取 1 个 Page 时，首先会检查 `page_hash` ，如果 `page_hash` 中存在，则直接读取并设置 `buf_fix_count` 后返回；否则需要从文件中读取 Page，从文件中读取 Page 时首先需要申请 1 个 Block（具体申请过程在后面介绍），然后添加到 `page_hash` 和 `LRU` 列表中，最后进行数据的读取。对于 1 个新的 Page 的创建过程，入口函数为 `buf_page_create` ，基本流程如下：\n\n```c++\n/* buf_page_create */\n|--> buf_page_create\n|    |--> buf_LRU_get_free_block // 申请 1 个 block\n|    |--> buf_page_hash_get_low // 检查 page_hash 中是否存在\n|    |\n|    |--> buf_page_init\n|    |    |--> buf_block_init_low\n|    |    |--> buf_page_init_low\n|    |    |--> HASH_INSERT // 插入 page_hash\n|    |--> buf_block_buf_fix_inc // buf_fix_count 计数 +1\n|    |--> buf_LRU_add_block // 添加到 LRU\n```\n\n### Block 申请\n\nBlock 申请的入口函数为 `buf_LRU_get_free_block` ，该方法会从 Buffer Pool 中申请 1 个 Block 供后续的 Page 读取使用。Block 申请的主要流程如下：\n\n```c++\n|--> buf_LRU_get_free_block // loop\n|    |--> buf_LRU_get_free_only // 从 free_list 分配\n|    |\n|    |--> buf_LRU_scan_and_free_block // 从 LRU 中回收\n|    |    |--> buf_LRU_free_from_unzip_LRU_list\n|    |    |    |--> buf_LRU_free_page\n|    |    |--> buf_LRU_free_from_common_LRU_list\n|    |    |    |--> buf_flush_ready_for_replace\n|    |    |    |--> buf_LRU_free_page\n|    |\n|    |--> os_event_set(buf_flush_event) // 唤醒刷脏线程\n|    |\n|    |--> buf_flush_single_page_from_LRU // 从 LRU 中刷脏\n|    |    |--> buf_LRU_free_page\n|    |    |--> buf_flush_page\n```\n\nBuffer Pool 中维护了三个列表：`free_list` 、`LRU` 、`flush_list` 。其中 `free_list` 列表是当前可供使用的 Block，`LRU` 列表中保存了当前所有已经使用的 Block，`flush_list` 列表中保存了所有脏页 Block。申请 1 个 Block 时：\n\n1. 首先判断当前 `free_list` 列表是否为空，若 `free_list` 列表非空，则直接从 `free_list` 列表中进行分配。若无法直接从 `free_list` 列表分配，则会尝试从 `LRU` 列表中进行回收。\n2. `LRU` 是一个非严格的最近使用列表，从 `LRU` 列表回收时会从列表尾部往前遍历（加入 `LRU` 列表时从头部加入），如果找到可回收的 Page（遇到脏页会跳过），则会释放 Page 并将对应的 Block 重新放入 `free_list` 列表中。`LRU` 列表的遍历过程并不是无限的，例如：在第一次遍历时，当检查的 Page 数目达到 `BUF_LRU_SEARCH_SCAN_THRESHOLD` 时会退出遍历过程。\n3. 如果无法从 `LRU` 列表中回收 Block，则会唤醒刷脏线程，刷脏线程的处理流程在下面会做介绍。\n4. 同时还会从 `LRU` 列表中进行刷脏，该过程是同步的，依然是遍历 `LRU` 列表，但此时不会跳过脏页，遇到脏页直接进行刷脏。\n\n## 管理\n\n### 加入 flush_list\n\n前面提到过 `flush_list` 列表中保存的是所有脏页 Block，脏页在 mtr 提交时会加入 `flush_list` 中，基本过程如下：\n\n```c++\n|--> mtr_t::Command::execute()\n|    |--> add_dirty_page_to_flush_list\n|    |    |--> buf_flush_note_modification\n|    |    |    |--> buf_flush_insert_into_flush_list\n|    |    |    |    |--> UT_LIST_ADD_FIRST // 插入 flush_list 头部\n```\n\n注意：`flush_list` 是一个非严格有序的列表（可以看做按照 `oldest_modification` 有序），脏页插入列表后位置不再修改，再次修改时仅修改 `newest_modification` 。\n\n### 加入 LRU\n\n`LRU` 列表中保存了当前所有已经使用的 Block，申请完 1 个 Block 并完成初始化后会加到 `LRU` 列表中（默认会加入到 old 区域头部），加入 `LRU` 列表的基本过程如下：\n\n```c++\n|--> buf_LRU_add_block\n|    |--> buf_LRU_add_block_low\n|    |    |--> UT_LIST_ADD_FIRST // 插入 young 区域头部\n|    |    |--> UT_LIST_INSERT_AFTER // 插入 old 区域头部\n|    |    |\n|    |    |--> buf_LRU_old_adjust_len // 调整 LRU\n```\n\n### 管理 LRU\n\n前面提到 `LRU` 是一个非严格的最近使用列表，InnoDB 将 `LRU` 列表划分为两个区域：young 区域和 old 区域。`LRU` 列表的示意图如下：\n\n```c++\n/** LRU 列表示意图\n                                                LRU_old\n                                                   |\n**********************young************************|********old*********\n|==================================================|===================|\n\n几个主要的常量：\nBUF_LRU_OLD_TOLERANCE      20\nBUF_LRU_NON_OLD_MIN_LEN    5\nBUF_LRU_OLD_MIN_LEN        512\nBUF_LRU_OLD_RATIO_DIV      1024\n\n参数控制：\ninnodb_old_block_pct       old 区域占比\n\n*/\n```\n\n`buf_LRU_old_adjust_len`  方法会根据 `innodb_old_block_pct` 参数，维护 young 区域和 old 区域的长度，主要逻辑如下：\n\n1. 当 `LRU` 长度小于 ` BUF_LRU_OLD_MIN_LEN` 时，不划分区域。\n2. 不是每次操作 `LRU` 列表后都需要立即调整，`BUF_LRU_OLD_TOLERANCE`  可以看成是容忍范围。\n3. 当 old 区域变大时，LRU_old 指针向前移动；反之向后移动。\n\n当 Block 被再次访问时，会触发 `buf_page_make_young_if_needed` 函数进行 Block 位置的调整，基本过程如下：\n\n```c++\n|--> buf_page_make_young_if_needed\n|    |--> buf_page_peek_if_too_old // 判断访问间隔\n|    |    |--> buf_page_peek_if_young // 判断 young 区域位置\n|    |\n|    |--> buf_page_make_young\n|    |    |--> buf_LRU_make_block_young\n|    |    |    |--> buf_LRU_remove_block\n|    |    |    |--> buf_LRU_add_block_low\n```\n\n`buf_page_make_young_if_needed` 移动 Block 时需要考虑：\n\n1. 访问间隔需要大于 `buf_LRU_old_threshold_ms` 。\n2. 当 Block 在 young 区域前 1/4 时，不需要移动。\n\nInnoDB 中 `LRU` 列表的设计虽然简单，但是也有许多优化在里面，感兴趣的同学可以仔细研究，本文仅是一个简单的介绍。\n\n## 回收\n\n### 释放 Page\n\n前面提到，当 `free_list` 列表为空时，会首先尝试从 `LRU` 列表中进行回收，Page 的释放入口函数为 `buf_LRU_free_page` ，该方法的主要处理流程如下：\n\n```c++\n|--> buf_LRU_free_page\n|    |--> buf_page_can_relocate // 检查 buf_fix_count 计数和 io_fix 状态\n|    |\n|    |--> buf_LRU_block_remove_hashed // 从 LRU 和 page_hash 中删除\n|    |    |--> buf_LRU_remove_block\n|    |    |    |--> buf_LRU_old_adjust_len\n|    |    |--> HASH_DELETE\n|    |\n|    |--> btr_search_drop_page_hash_index // 从 AHI 中删除\n|    |\n|    |--> buf_LRU_block_free_hashed_page // 放回 free_list\n|    |    |--> buf_LRU_block_free_non_file_page\n```\n\n释放 1 个 Page 时，首先需要检查 `io_fix` 状态和 `buf_fix_count` 计数，确保当前 Page 没有被使用，然后将 Block 从依次从 `LRU` 列表、`page_hash` 、`AHI` 中删除，最后将 Block 重新放入到 `free_list` 列表中。\n\n### 同步刷脏\n\n同步刷脏的入口函数为 `buf_flush_page` ，同步刷脏过程仅会刷 1 个 Page，保证能够获取到 1 个可用的 Block，主要处理流程如下：\n\n```c++\n|--> buf_flush_page // 刷单个 page\n|    |--> buf_page_set_io_fix // io_fix 设置为 BUF_IO_WRITE\n|    |--> buf_flush_write_block_low\n|    |    |--> log_write_up_to // 写 redo\n|    |    |\n|    |    |--> fil_io\n|    |    |--> buf_dblwr_write_single_page // 写数据页\n|    |    |\n|    |    |--> fil_flush\n|    |    |--> buf_page_io_complete\n|    |    |    |--> buf_flush_write_complete\n|    |    |    |    |--> buf_flush_remove\n|    |    |    |    |--> buf_page_set_io_fix // io_fix 设置为 BUF_IO_NONE\n|    |    |    |\n|    |    |    |--> buf_LRU_free_page\n```\n\nInnoDB 通过严格的 WAL 机制保证数据的一致性，刷脏过程同样如此。首先需要保证对应的日志文件落盘，然后再写入数据页。最后将 Block 从 `flush_list` 列表中移除，此时 Page 变成可回收状态，再次调用 `buf_LRU_free_page` 进行回收。\n\n同步刷脏的过程不仅在获取 Block 时会被调用，在表删除的时候同样会被调用，表删除时会根据 `space_id` 进行批量的刷脏，入口函数为 `buf_LRU_flush_or_remove_pages` ，处理流程如下：\n\n```c++\n|--> buf_LRU_flush_or_remove_pages // 根据 space_id 刷脏\n|    |--> buf_LRU_drop_page_hash_for_tablespace // 遍历 LRU\n|    |    |--> buf_LRU_drop_page_hash_batch\n|    |    |    |--> btr_search_drop_page_hash_when_freed\n|    |    |    |    |--> buf_page_get_gen\n|    |    |    |    |--> btr_search_drop_page_hash_index // 从 AHI 中删除\n|    |\n|    |--> buf_LRU_remove_pages\n|    |    |--> buf_LRU_remove_all_pages // 遍历 LRU\n|    |    |    |--> buf_LRU_block_remove_hashed // 从 LRU 和 page_hash 中删除\n|    |    |    |--> buf_LRU_block_free_hashed_page // 放回 free_list\n|    |    |\n|    |    |--> buf_flush_dirty_pages\n|    |    |    |--> buf_flush_or_remove_pages // 遍历 flush_list\n|    |    |    |    |--> buf_flush_or_remove_page\n|    |    |    |    |    |--> buf_flush_remove\n|    |    |    |    |    |\n|    |    |    |    |    |--> buf_flush_page\n```\n\n具体的过程在此不再赘述，大家可以自己去阅读相应的代码。需要注意的是：如果单个 session 中使用了临时表，那么在 session 退出的时候，也会进入到上述的刷脏流程，当 `LRU` 列表很大时，session 退出的性能将会受到很大的影响。\n\n### 异步刷脏\n\n除了同步刷脏之外，MySQL 中还引入单独的刷脏线程进行异步刷脏。刷脏线程按照功能划分包括两种：coordinator 线程和 cleaner 线程。coordinator 线程会计算最大的刷脏量，然后分配刷脏任务给 cleaner 线程，cleaner 线程进行实际的刷脏工作（coordinator 线程本身也会参与刷脏）。异步刷脏的入口函数为 `buf_flush_page_cleaner_init` ，基本流程如下：\n\n```c++\n|--> buf_flush_page_coordinator_thread\n|    |--> os_event_wait(buf_flush_event)\n|    \n|    /* loop */\n|    |--> page_cleaner_flush_pages_recommendation // 计算最大刷脏量\n|    |--> pc_request // 任务分发，slot 数目等于 bp_instance 数目\n|    |    |--> os_event_set(page_cleaner->is_requested)\n|    |--> pc_flush_slot // 参与刷脏\n|    |--> pc_wait_finished\n\n\n|--> buf_flush_page_cleaner_thread\n|    |--> os_event_wait(page_cleaner->is_requested)\n|    |--> pc_flush_slot // 1 个线程处理 1 个 bp_instance\n|    |    |--> buf_flush_LRU_list // 从 LRU 中刷脏\n|    |    |    |--> buf_flush_do_batch(BUF_FLUSH_LRU)\n|    |    |\n|    |    |--> buf_flush_do_batch(BUF_FLUSH_LIST) // 从 flush_list 刷脏\n|    |    |    |--> buf_flush_batch\n|    |    |    |    |--> buf_do_LRU_batch\n|    |    |    |    |    |--> buf_free_from_unzip_LRU_list_batch\n|    |    |    |    |    |--> buf_flush_LRU_list_batch\n|    |    |    |    |    |    |--> buf_LRU_free_page\n|    |    |    |    |    |    |--> buf_flush_page_and_try_neighbors\n|    |    |    |    |    |    |    |--> buf_flush_try_neighbors\n|    |    |    |    |    |    |    |    |--> buf_flush_page\n|    |    |    |    |\n|    |    |    |    |--> buf_do_flush_list_batch\n|    |    |    |    |    |--> buf_flush_page_and_try_neighbors\n```\n\n异步刷脏的具体过程可以参考[这篇文章](http://mysql.taobao.org/monthly/2018/09/02/)，异步刷脏过程中有一个非常重要的点就是 `page_cleaner_flush_pages_recommendation` 计算最大刷脏量，相关的细节在此不再展开，后面有机会再单独整理一篇各种后台线程的更新逻辑。\n\n## 总结\n\n本文从申请、管理、回收三部分对 InnoDB Buffer Page 的生命周期管理进行了介绍，文中的内容只是一个基本概要，更多的细节还需要读者在阅读代码的过程中慢慢发掘。","slug":"innodb-buffer-page","published":1,"updated":"2020-08-27T08:44:14.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgluc72g000dowgm28fi419i","content":"<p>InnoDB 没有使用操作系统自己的 Page Cache 机制，而是自己设计了一套 Buffer Pool 来进行 Page 的管理，关于 InnoDB Buffer Pool 的介绍，可以参考<a href=\"http://mysql.taobao.org/monthly/2017/05/01/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，里面对 InnoDB Buffer Pool 作了比较深入的介绍。本文尝试从另外一个角度介绍一下一个 Buffer Page 的生命周期。本文给出的所有示例代码均基于 MySQL 8.0.18 版本。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"申请\"><a href=\"#申请\" class=\"headerlink\" title=\"申请\"></a>申请</h2><h3 id=\"Page-读取\"><a href=\"#Page-读取\" class=\"headerlink\" title=\"Page 读取\"></a>Page 读取</h3><p>Page 的读取有一个统一的入口函数 <code>buffer_page_get_gen</code> ，该方法的主要入参为 <code>page_id</code> ，即获取指定的页，MySQL 8.0 中的主要流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 以 Buf_fetch_normal 为例 */</span></span><br><span class=\"line\">|--&gt; fetch.single_page</span><br><span class=\"line\">|    |--&gt; <span class=\"built_in\">get</span>(block) <span class=\"comment\">// loop</span></span><br><span class=\"line\">|    |    |--&gt; lookup</span><br><span class=\"line\">|    |    |    |--&gt; buf_page_hash_get_low <span class=\"comment\">// 检查 page_hash 中是否存在</span></span><br><span class=\"line\">|    |    |--&gt; buf_block_fix <span class=\"comment\">// buf_fix_count 计数 +1</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; read_page</span><br><span class=\"line\">|    |    |    |--&gt; buf_read_page <span class=\"comment\">// 从文件中读取 page</span></span><br><span class=\"line\">|    |    |    |    |--&gt; buf_read_page_low</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_page_init_for_read</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_LRU_get_free_block <span class=\"comment\">// 申请 1 个 block</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_page_hash_get_low <span class=\"comment\">// 再次检查 page_hash 中是否存在</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_page_init</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; buf_block_init_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; buf_page_init_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; HASH_INSERT <span class=\"comment\">// 插入 page_hash</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_page_set_io_fix <span class=\"comment\">// io_fix 设置为 BUF_IO_READ</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_LRU_add_block <span class=\"comment\">// 添加到 LRU</span></span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; _fil_io <span class=\"comment\">// 读取文件</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_page_io_complete <span class=\"comment\">// 同步模式 IO 完成</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_page_set_io_fix <span class=\"comment\">// io_fix 设置为 BUF_IO_NONE</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_page_make_young_if_needed</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_read_ahead_linear</span><br></pre></td></tr></table></figure>\n\n<p>读取 1 个 Page 时，首先会检查 <code>page_hash</code> ，如果 <code>page_hash</code> 中存在，则直接读取并设置 <code>buf_fix_count</code> 后返回；否则需要从文件中读取 Page，从文件中读取 Page 时首先需要申请 1 个 Block（具体申请过程在后面介绍），然后添加到 <code>page_hash</code> 和 <code>LRU</code> 列表中，最后进行数据的读取。对于 1 个新的 Page 的创建过程，入口函数为 <code>buf_page_create</code> ，基本流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* buf_page_create */</span></span><br><span class=\"line\">|--&gt; buf_page_create</span><br><span class=\"line\">|    |--&gt; buf_LRU_get_free_block <span class=\"comment\">// 申请 1 个 block</span></span><br><span class=\"line\">|    |--&gt; buf_page_hash_get_low <span class=\"comment\">// 检查 page_hash 中是否存在</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_page_init</span><br><span class=\"line\">|    |    |--&gt; buf_block_init_low</span><br><span class=\"line\">|    |    |--&gt; buf_page_init_low</span><br><span class=\"line\">|    |    |--&gt; HASH_INSERT <span class=\"comment\">// 插入 page_hash</span></span><br><span class=\"line\">|    |--&gt; buf_block_buf_fix_inc <span class=\"comment\">// buf_fix_count 计数 +1</span></span><br><span class=\"line\">|    |--&gt; buf_LRU_add_block <span class=\"comment\">// 添加到 LRU</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Block-申请\"><a href=\"#Block-申请\" class=\"headerlink\" title=\"Block 申请\"></a>Block 申请</h3><p>Block 申请的入口函数为 <code>buf_LRU_get_free_block</code> ，该方法会从 Buffer Pool 中申请 1 个 Block 供后续的 Page 读取使用。Block 申请的主要流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_LRU_get_free_block <span class=\"comment\">// loop</span></span><br><span class=\"line\">|    |--&gt; buf_LRU_get_free_only <span class=\"comment\">// 从 free_list 分配</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_LRU_scan_and_free_block <span class=\"comment\">// 从 LRU 中回收</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_free_from_unzip_LRU_list</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |    |--&gt; buf_LRU_free_from_common_LRU_list</span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_ready_for_replace</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; os_event_set(buf_flush_event) <span class=\"comment\">// 唤醒刷脏线程</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_flush_single_page_from_LRU <span class=\"comment\">// 从 LRU 中刷脏</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |    |--&gt; buf_flush_page</span><br></pre></td></tr></table></figure>\n\n<p>Buffer Pool 中维护了三个列表：<code>free_list</code> 、<code>LRU</code> 、<code>flush_list</code> 。其中 <code>free_list</code> 列表是当前可供使用的 Block，<code>LRU</code> 列表中保存了当前所有已经使用的 Block，<code>flush_list</code> 列表中保存了所有脏页 Block。申请 1 个 Block 时：</p>\n<ol>\n<li>首先判断当前 <code>free_list</code> 列表是否为空，若 <code>free_list</code> 列表非空，则直接从 <code>free_list</code> 列表中进行分配。若无法直接从 <code>free_list</code> 列表分配，则会尝试从 <code>LRU</code> 列表中进行回收。</li>\n<li><code>LRU</code> 是一个非严格的最近使用列表，从 <code>LRU</code> 列表回收时会从列表尾部往前遍历（加入 <code>LRU</code> 列表时从头部加入），如果找到可回收的 Page（遇到脏页会跳过），则会释放 Page 并将对应的 Block 重新放入 <code>free_list</code> 列表中。<code>LRU</code> 列表的遍历过程并不是无限的，例如：在第一次遍历时，当检查的 Page 数目达到 <code>BUF_LRU_SEARCH_SCAN_THRESHOLD</code> 时会退出遍历过程。</li>\n<li>如果无法从 <code>LRU</code> 列表中回收 Block，则会唤醒刷脏线程，刷脏线程的处理流程在下面会做介绍。</li>\n<li>同时还会从 <code>LRU</code> 列表中进行刷脏，该过程是同步的，依然是遍历 <code>LRU</code> 列表，但此时不会跳过脏页，遇到脏页直接进行刷脏。</li>\n</ol>\n<h2 id=\"管理\"><a href=\"#管理\" class=\"headerlink\" title=\"管理\"></a>管理</h2><h3 id=\"加入-flush-list\"><a href=\"#加入-flush-list\" class=\"headerlink\" title=\"加入 flush_list\"></a>加入 flush_list</h3><p>前面提到过 <code>flush_list</code> 列表中保存的是所有脏页 Block，脏页在 mtr 提交时会加入 <code>flush_list</code> 中，基本过程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; <span class=\"keyword\">mtr_t</span>::Command::execute()</span><br><span class=\"line\">|    |--&gt; add_dirty_page_to_flush_list</span><br><span class=\"line\">|    |    |--&gt; buf_flush_note_modification</span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_insert_into_flush_list</span><br><span class=\"line\">|    |    |    |    |--&gt; UT_LIST_ADD_FIRST <span class=\"comment\">// 插入 flush_list 头部</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：<code>flush_list</code> 是一个非严格有序的列表（可以看做按照 <code>oldest_modification</code> 有序），脏页插入列表后位置不再修改，再次修改时仅修改 <code>newest_modification</code> 。</p>\n<h3 id=\"加入-LRU\"><a href=\"#加入-LRU\" class=\"headerlink\" title=\"加入 LRU\"></a>加入 LRU</h3><p><code>LRU</code> 列表中保存了当前所有已经使用的 Block，申请完 1 个 Block 并完成初始化后会加到 <code>LRU</code> 列表中（默认会加入到 old 区域头部），加入 <code>LRU</code> 列表的基本过程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_LRU_add_block</span><br><span class=\"line\">|    |--&gt; buf_LRU_add_block_low</span><br><span class=\"line\">|    |    |--&gt; UT_LIST_ADD_FIRST <span class=\"comment\">// 插入 young 区域头部</span></span><br><span class=\"line\">|    |    |--&gt; UT_LIST_INSERT_AFTER <span class=\"comment\">// 插入 old 区域头部</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; buf_LRU_old_adjust_len <span class=\"comment\">// 调整 LRU</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"管理-LRU\"><a href=\"#管理-LRU\" class=\"headerlink\" title=\"管理 LRU\"></a>管理 LRU</h3><p>前面提到 <code>LRU</code> 是一个非严格的最近使用列表，InnoDB 将 <code>LRU</code> 列表划分为两个区域：young 区域和 old 区域。<code>LRU</code> 列表的示意图如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** LRU 列表示意图</span></span><br><span class=\"line\"><span class=\"comment\">                                                LRU_old</span></span><br><span class=\"line\"><span class=\"comment\">                                                   |</span></span><br><span class=\"line\"><span class=\"comment\">**********************young************************|********old*********</span></span><br><span class=\"line\"><span class=\"comment\">|==================================================|===================|</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">几个主要的常量：</span></span><br><span class=\"line\"><span class=\"comment\">BUF_LRU_OLD_TOLERANCE      20</span></span><br><span class=\"line\"><span class=\"comment\">BUF_LRU_NON_OLD_MIN_LEN    5</span></span><br><span class=\"line\"><span class=\"comment\">BUF_LRU_OLD_MIN_LEN        512</span></span><br><span class=\"line\"><span class=\"comment\">BUF_LRU_OLD_RATIO_DIV      1024</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">参数控制：</span></span><br><span class=\"line\"><span class=\"comment\">innodb_old_block_pct       old 区域占比</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p><code>buf_LRU_old_adjust_len</code>  方法会根据 <code>innodb_old_block_pct</code> 参数，维护 young 区域和 old 区域的长度，主要逻辑如下：</p>\n<ol>\n<li>当 <code>LRU</code> 长度小于 <code>BUF_LRU_OLD_MIN_LEN</code> 时，不划分区域。</li>\n<li>不是每次操作 <code>LRU</code> 列表后都需要立即调整，<code>BUF_LRU_OLD_TOLERANCE</code>  可以看成是容忍范围。</li>\n<li>当 old 区域变大时，LRU_old 指针向前移动；反之向后移动。</li>\n</ol>\n<p>当 Block 被再次访问时，会触发 <code>buf_page_make_young_if_needed</code> 函数进行 Block 位置的调整，基本过程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_page_make_young_if_needed</span><br><span class=\"line\">|    |--&gt; buf_page_peek_if_too_old <span class=\"comment\">// 判断访问间隔</span></span><br><span class=\"line\">|    |    |--&gt; buf_page_peek_if_young <span class=\"comment\">// 判断 young 区域位置</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_page_make_young</span><br><span class=\"line\">|    |    |--&gt; buf_LRU_make_block_young</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_remove_block</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_add_block_low</span><br></pre></td></tr></table></figure>\n\n<p><code>buf_page_make_young_if_needed</code> 移动 Block 时需要考虑：</p>\n<ol>\n<li>访问间隔需要大于 <code>buf_LRU_old_threshold_ms</code> 。</li>\n<li>当 Block 在 young 区域前 1/4 时，不需要移动。</li>\n</ol>\n<p>InnoDB 中 <code>LRU</code> 列表的设计虽然简单，但是也有许多优化在里面，感兴趣的同学可以仔细研究，本文仅是一个简单的介绍。</p>\n<h2 id=\"回收\"><a href=\"#回收\" class=\"headerlink\" title=\"回收\"></a>回收</h2><h3 id=\"释放-Page\"><a href=\"#释放-Page\" class=\"headerlink\" title=\"释放 Page\"></a>释放 Page</h3><p>前面提到，当 <code>free_list</code> 列表为空时，会首先尝试从 <code>LRU</code> 列表中进行回收，Page 的释放入口函数为 <code>buf_LRU_free_page</code> ，该方法的主要处理流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |--&gt; buf_page_can_relocate <span class=\"comment\">// 检查 buf_fix_count 计数和 io_fix 状态</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_LRU_block_remove_hashed <span class=\"comment\">// 从 LRU 和 page_hash 中删除</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_remove_block</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_old_adjust_len</span><br><span class=\"line\">|    |    |--&gt; HASH_DELETE</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; btr_search_drop_page_hash_index <span class=\"comment\">// 从 AHI 中删除</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_LRU_block_free_hashed_page <span class=\"comment\">// 放回 free_list</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_block_free_non_file_page</span><br></pre></td></tr></table></figure>\n\n<p>释放 1 个 Page 时，首先需要检查 <code>io_fix</code> 状态和 <code>buf_fix_count</code> 计数，确保当前 Page 没有被使用，然后将 Block 从依次从 <code>LRU</code> 列表、<code>page_hash</code> 、<code>AHI</code> 中删除，最后将 Block 重新放入到 <code>free_list</code> 列表中。</p>\n<h3 id=\"同步刷脏\"><a href=\"#同步刷脏\" class=\"headerlink\" title=\"同步刷脏\"></a>同步刷脏</h3><p>同步刷脏的入口函数为 <code>buf_flush_page</code> ，同步刷脏过程仅会刷 1 个 Page，保证能够获取到 1 个可用的 Block，主要处理流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_flush_page <span class=\"comment\">// 刷单个 page</span></span><br><span class=\"line\">|    |--&gt; buf_page_set_io_fix <span class=\"comment\">// io_fix 设置为 BUF_IO_WRITE</span></span><br><span class=\"line\">|    |--&gt; buf_flush_write_block_low</span><br><span class=\"line\">|    |    |--&gt; log_write_up_to <span class=\"comment\">// 写 redo</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; fil_io</span><br><span class=\"line\">|    |    |--&gt; buf_dblwr_write_single_page <span class=\"comment\">// 写数据页</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; fil_flush</span><br><span class=\"line\">|    |    |--&gt; buf_page_io_complete</span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_write_complete</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_flush_remove</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_page_set_io_fix <span class=\"comment\">// io_fix 设置为 BUF_IO_NONE</span></span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_free_page</span><br></pre></td></tr></table></figure>\n\n<p>InnoDB 通过严格的 WAL 机制保证数据的一致性，刷脏过程同样如此。首先需要保证对应的日志文件落盘，然后再写入数据页。最后将 Block 从 <code>flush_list</code> 列表中移除，此时 Page 变成可回收状态，再次调用 <code>buf_LRU_free_page</code> 进行回收。</p>\n<p>同步刷脏的过程不仅在获取 Block 时会被调用，在表删除的时候同样会被调用，表删除时会根据 <code>space_id</code> 进行批量的刷脏，入口函数为 <code>buf_LRU_flush_or_remove_pages</code> ，处理流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_LRU_flush_or_remove_pages <span class=\"comment\">// 根据 space_id 刷脏</span></span><br><span class=\"line\">|    |--&gt; buf_LRU_drop_page_hash_for_tablespace <span class=\"comment\">// 遍历 LRU</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_drop_page_hash_batch</span><br><span class=\"line\">|    |    |    |--&gt; btr_search_drop_page_hash_when_freed</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_page_get_gen</span><br><span class=\"line\">|    |    |    |    |--&gt; btr_search_drop_page_hash_index <span class=\"comment\">// 从 AHI 中删除</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_LRU_remove_pages</span><br><span class=\"line\">|    |    |--&gt; buf_LRU_remove_all_pages <span class=\"comment\">// 遍历 LRU</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_block_remove_hashed <span class=\"comment\">// 从 LRU 和 page_hash 中删除</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_block_free_hashed_page <span class=\"comment\">// 放回 free_list</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; buf_flush_dirty_pages</span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_or_remove_pages <span class=\"comment\">// 遍历 flush_list</span></span><br><span class=\"line\">|    |    |    |    |--&gt; buf_flush_or_remove_page</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_flush_remove</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_flush_page</span><br></pre></td></tr></table></figure>\n\n<p>具体的过程在此不再赘述，大家可以自己去阅读相应的代码。需要注意的是：如果单个 session 中使用了临时表，那么在 session 退出的时候，也会进入到上述的刷脏流程，当 <code>LRU</code> 列表很大时，session 退出的性能将会受到很大的影响。</p>\n<h3 id=\"异步刷脏\"><a href=\"#异步刷脏\" class=\"headerlink\" title=\"异步刷脏\"></a>异步刷脏</h3><p>除了同步刷脏之外，MySQL 中还引入单独的刷脏线程进行异步刷脏。刷脏线程按照功能划分包括两种：coordinator 线程和 cleaner 线程。coordinator 线程会计算最大的刷脏量，然后分配刷脏任务给 cleaner 线程，cleaner 线程进行实际的刷脏工作（coordinator 线程本身也会参与刷脏）。异步刷脏的入口函数为 <code>buf_flush_page_cleaner_init</code> ，基本流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_flush_page_coordinator_thread</span><br><span class=\"line\">|    |--&gt; os_event_wait(buf_flush_event)</span><br><span class=\"line\">|    </span><br><span class=\"line\">|    <span class=\"comment\">/* loop */</span></span><br><span class=\"line\">|    |--&gt; page_cleaner_flush_pages_recommendation <span class=\"comment\">// 计算最大刷脏量</span></span><br><span class=\"line\">|    |--&gt; pc_request <span class=\"comment\">// 任务分发，slot 数目等于 bp_instance 数目</span></span><br><span class=\"line\">|    |    |--&gt; os_event_set(page_cleaner-&gt;is_requested)</span><br><span class=\"line\">|    |--&gt; pc_flush_slot <span class=\"comment\">// 参与刷脏</span></span><br><span class=\"line\">|    |--&gt; pc_wait_finished</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; buf_flush_page_cleaner_thread</span><br><span class=\"line\">|    |--&gt; os_event_wait(page_cleaner-&gt;is_requested)</span><br><span class=\"line\">|    |--&gt; pc_flush_slot <span class=\"comment\">// 1 个线程处理 1 个 bp_instance</span></span><br><span class=\"line\">|    |    |--&gt; buf_flush_LRU_list <span class=\"comment\">// 从 LRU 中刷脏</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_do_batch(BUF_FLUSH_LRU)</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; buf_flush_do_batch(BUF_FLUSH_LIST) <span class=\"comment\">// 从 flush_list 刷脏</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_batch</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_do_LRU_batch</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_free_from_unzip_LRU_list_batch</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_flush_LRU_list_batch</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_flush_page_and_try_neighbors</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; buf_flush_try_neighbors</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; buf_flush_page</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_do_flush_list_batch</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_flush_page_and_try_neighbors</span><br></pre></td></tr></table></figure>\n\n<p>异步刷脏的具体过程可以参考<a href=\"http://mysql.taobao.org/monthly/2018/09/02/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，异步刷脏过程中有一个非常重要的点就是 <code>page_cleaner_flush_pages_recommendation</code> 计算最大刷脏量，相关的细节在此不再展开，后面有机会再单独整理一篇各种后台线程的更新逻辑。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文从申请、管理、回收三部分对 InnoDB Buffer Page 的生命周期管理进行了介绍，文中的内容只是一个基本概要，更多的细节还需要读者在阅读代码的过程中慢慢发掘。</p>\n","site":{"data":{}},"excerpt":"<p>InnoDB 没有使用操作系统自己的 Page Cache 机制，而是自己设计了一套 Buffer Pool 来进行 Page 的管理，关于 InnoDB Buffer Pool 的介绍，可以参考<a href=\"http://mysql.taobao.org/monthly/2017/05/01/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，里面对 InnoDB Buffer Pool 作了比较深入的介绍。本文尝试从另外一个角度介绍一下一个 Buffer Page 的生命周期。本文给出的所有示例代码均基于 MySQL 8.0.18 版本。</p>","more":"<h2 id=\"申请\"><a href=\"#申请\" class=\"headerlink\" title=\"申请\"></a>申请</h2><h3 id=\"Page-读取\"><a href=\"#Page-读取\" class=\"headerlink\" title=\"Page 读取\"></a>Page 读取</h3><p>Page 的读取有一个统一的入口函数 <code>buffer_page_get_gen</code> ，该方法的主要入参为 <code>page_id</code> ，即获取指定的页，MySQL 8.0 中的主要流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 以 Buf_fetch_normal 为例 */</span></span><br><span class=\"line\">|--&gt; fetch.single_page</span><br><span class=\"line\">|    |--&gt; <span class=\"built_in\">get</span>(block) <span class=\"comment\">// loop</span></span><br><span class=\"line\">|    |    |--&gt; lookup</span><br><span class=\"line\">|    |    |    |--&gt; buf_page_hash_get_low <span class=\"comment\">// 检查 page_hash 中是否存在</span></span><br><span class=\"line\">|    |    |--&gt; buf_block_fix <span class=\"comment\">// buf_fix_count 计数 +1</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; read_page</span><br><span class=\"line\">|    |    |    |--&gt; buf_read_page <span class=\"comment\">// 从文件中读取 page</span></span><br><span class=\"line\">|    |    |    |    |--&gt; buf_read_page_low</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_page_init_for_read</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_LRU_get_free_block <span class=\"comment\">// 申请 1 个 block</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_page_hash_get_low <span class=\"comment\">// 再次检查 page_hash 中是否存在</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_page_init</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; buf_block_init_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; buf_page_init_low</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; HASH_INSERT <span class=\"comment\">// 插入 page_hash</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_page_set_io_fix <span class=\"comment\">// io_fix 设置为 BUF_IO_READ</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_LRU_add_block <span class=\"comment\">// 添加到 LRU</span></span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; _fil_io <span class=\"comment\">// 读取文件</span></span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_page_io_complete <span class=\"comment\">// 同步模式 IO 完成</span></span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_page_set_io_fix <span class=\"comment\">// io_fix 设置为 BUF_IO_NONE</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_page_make_young_if_needed</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_read_ahead_linear</span><br></pre></td></tr></table></figure>\n\n<p>读取 1 个 Page 时，首先会检查 <code>page_hash</code> ，如果 <code>page_hash</code> 中存在，则直接读取并设置 <code>buf_fix_count</code> 后返回；否则需要从文件中读取 Page，从文件中读取 Page 时首先需要申请 1 个 Block（具体申请过程在后面介绍），然后添加到 <code>page_hash</code> 和 <code>LRU</code> 列表中，最后进行数据的读取。对于 1 个新的 Page 的创建过程，入口函数为 <code>buf_page_create</code> ，基本流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* buf_page_create */</span></span><br><span class=\"line\">|--&gt; buf_page_create</span><br><span class=\"line\">|    |--&gt; buf_LRU_get_free_block <span class=\"comment\">// 申请 1 个 block</span></span><br><span class=\"line\">|    |--&gt; buf_page_hash_get_low <span class=\"comment\">// 检查 page_hash 中是否存在</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_page_init</span><br><span class=\"line\">|    |    |--&gt; buf_block_init_low</span><br><span class=\"line\">|    |    |--&gt; buf_page_init_low</span><br><span class=\"line\">|    |    |--&gt; HASH_INSERT <span class=\"comment\">// 插入 page_hash</span></span><br><span class=\"line\">|    |--&gt; buf_block_buf_fix_inc <span class=\"comment\">// buf_fix_count 计数 +1</span></span><br><span class=\"line\">|    |--&gt; buf_LRU_add_block <span class=\"comment\">// 添加到 LRU</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Block-申请\"><a href=\"#Block-申请\" class=\"headerlink\" title=\"Block 申请\"></a>Block 申请</h3><p>Block 申请的入口函数为 <code>buf_LRU_get_free_block</code> ，该方法会从 Buffer Pool 中申请 1 个 Block 供后续的 Page 读取使用。Block 申请的主要流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_LRU_get_free_block <span class=\"comment\">// loop</span></span><br><span class=\"line\">|    |--&gt; buf_LRU_get_free_only <span class=\"comment\">// 从 free_list 分配</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_LRU_scan_and_free_block <span class=\"comment\">// 从 LRU 中回收</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_free_from_unzip_LRU_list</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |    |--&gt; buf_LRU_free_from_common_LRU_list</span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_ready_for_replace</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; os_event_set(buf_flush_event) <span class=\"comment\">// 唤醒刷脏线程</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_flush_single_page_from_LRU <span class=\"comment\">// 从 LRU 中刷脏</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |    |--&gt; buf_flush_page</span><br></pre></td></tr></table></figure>\n\n<p>Buffer Pool 中维护了三个列表：<code>free_list</code> 、<code>LRU</code> 、<code>flush_list</code> 。其中 <code>free_list</code> 列表是当前可供使用的 Block，<code>LRU</code> 列表中保存了当前所有已经使用的 Block，<code>flush_list</code> 列表中保存了所有脏页 Block。申请 1 个 Block 时：</p>\n<ol>\n<li>首先判断当前 <code>free_list</code> 列表是否为空，若 <code>free_list</code> 列表非空，则直接从 <code>free_list</code> 列表中进行分配。若无法直接从 <code>free_list</code> 列表分配，则会尝试从 <code>LRU</code> 列表中进行回收。</li>\n<li><code>LRU</code> 是一个非严格的最近使用列表，从 <code>LRU</code> 列表回收时会从列表尾部往前遍历（加入 <code>LRU</code> 列表时从头部加入），如果找到可回收的 Page（遇到脏页会跳过），则会释放 Page 并将对应的 Block 重新放入 <code>free_list</code> 列表中。<code>LRU</code> 列表的遍历过程并不是无限的，例如：在第一次遍历时，当检查的 Page 数目达到 <code>BUF_LRU_SEARCH_SCAN_THRESHOLD</code> 时会退出遍历过程。</li>\n<li>如果无法从 <code>LRU</code> 列表中回收 Block，则会唤醒刷脏线程，刷脏线程的处理流程在下面会做介绍。</li>\n<li>同时还会从 <code>LRU</code> 列表中进行刷脏，该过程是同步的，依然是遍历 <code>LRU</code> 列表，但此时不会跳过脏页，遇到脏页直接进行刷脏。</li>\n</ol>\n<h2 id=\"管理\"><a href=\"#管理\" class=\"headerlink\" title=\"管理\"></a>管理</h2><h3 id=\"加入-flush-list\"><a href=\"#加入-flush-list\" class=\"headerlink\" title=\"加入 flush_list\"></a>加入 flush_list</h3><p>前面提到过 <code>flush_list</code> 列表中保存的是所有脏页 Block，脏页在 mtr 提交时会加入 <code>flush_list</code> 中，基本过程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; <span class=\"keyword\">mtr_t</span>::Command::execute()</span><br><span class=\"line\">|    |--&gt; add_dirty_page_to_flush_list</span><br><span class=\"line\">|    |    |--&gt; buf_flush_note_modification</span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_insert_into_flush_list</span><br><span class=\"line\">|    |    |    |    |--&gt; UT_LIST_ADD_FIRST <span class=\"comment\">// 插入 flush_list 头部</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：<code>flush_list</code> 是一个非严格有序的列表（可以看做按照 <code>oldest_modification</code> 有序），脏页插入列表后位置不再修改，再次修改时仅修改 <code>newest_modification</code> 。</p>\n<h3 id=\"加入-LRU\"><a href=\"#加入-LRU\" class=\"headerlink\" title=\"加入 LRU\"></a>加入 LRU</h3><p><code>LRU</code> 列表中保存了当前所有已经使用的 Block，申请完 1 个 Block 并完成初始化后会加到 <code>LRU</code> 列表中（默认会加入到 old 区域头部），加入 <code>LRU</code> 列表的基本过程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_LRU_add_block</span><br><span class=\"line\">|    |--&gt; buf_LRU_add_block_low</span><br><span class=\"line\">|    |    |--&gt; UT_LIST_ADD_FIRST <span class=\"comment\">// 插入 young 区域头部</span></span><br><span class=\"line\">|    |    |--&gt; UT_LIST_INSERT_AFTER <span class=\"comment\">// 插入 old 区域头部</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; buf_LRU_old_adjust_len <span class=\"comment\">// 调整 LRU</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"管理-LRU\"><a href=\"#管理-LRU\" class=\"headerlink\" title=\"管理 LRU\"></a>管理 LRU</h3><p>前面提到 <code>LRU</code> 是一个非严格的最近使用列表，InnoDB 将 <code>LRU</code> 列表划分为两个区域：young 区域和 old 区域。<code>LRU</code> 列表的示意图如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** LRU 列表示意图</span></span><br><span class=\"line\"><span class=\"comment\">                                                LRU_old</span></span><br><span class=\"line\"><span class=\"comment\">                                                   |</span></span><br><span class=\"line\"><span class=\"comment\">**********************young************************|********old*********</span></span><br><span class=\"line\"><span class=\"comment\">|==================================================|===================|</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">几个主要的常量：</span></span><br><span class=\"line\"><span class=\"comment\">BUF_LRU_OLD_TOLERANCE      20</span></span><br><span class=\"line\"><span class=\"comment\">BUF_LRU_NON_OLD_MIN_LEN    5</span></span><br><span class=\"line\"><span class=\"comment\">BUF_LRU_OLD_MIN_LEN        512</span></span><br><span class=\"line\"><span class=\"comment\">BUF_LRU_OLD_RATIO_DIV      1024</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">参数控制：</span></span><br><span class=\"line\"><span class=\"comment\">innodb_old_block_pct       old 区域占比</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p><code>buf_LRU_old_adjust_len</code>  方法会根据 <code>innodb_old_block_pct</code> 参数，维护 young 区域和 old 区域的长度，主要逻辑如下：</p>\n<ol>\n<li>当 <code>LRU</code> 长度小于 <code>BUF_LRU_OLD_MIN_LEN</code> 时，不划分区域。</li>\n<li>不是每次操作 <code>LRU</code> 列表后都需要立即调整，<code>BUF_LRU_OLD_TOLERANCE</code>  可以看成是容忍范围。</li>\n<li>当 old 区域变大时，LRU_old 指针向前移动；反之向后移动。</li>\n</ol>\n<p>当 Block 被再次访问时，会触发 <code>buf_page_make_young_if_needed</code> 函数进行 Block 位置的调整，基本过程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_page_make_young_if_needed</span><br><span class=\"line\">|    |--&gt; buf_page_peek_if_too_old <span class=\"comment\">// 判断访问间隔</span></span><br><span class=\"line\">|    |    |--&gt; buf_page_peek_if_young <span class=\"comment\">// 判断 young 区域位置</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_page_make_young</span><br><span class=\"line\">|    |    |--&gt; buf_LRU_make_block_young</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_remove_block</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_add_block_low</span><br></pre></td></tr></table></figure>\n\n<p><code>buf_page_make_young_if_needed</code> 移动 Block 时需要考虑：</p>\n<ol>\n<li>访问间隔需要大于 <code>buf_LRU_old_threshold_ms</code> 。</li>\n<li>当 Block 在 young 区域前 1/4 时，不需要移动。</li>\n</ol>\n<p>InnoDB 中 <code>LRU</code> 列表的设计虽然简单，但是也有许多优化在里面，感兴趣的同学可以仔细研究，本文仅是一个简单的介绍。</p>\n<h2 id=\"回收\"><a href=\"#回收\" class=\"headerlink\" title=\"回收\"></a>回收</h2><h3 id=\"释放-Page\"><a href=\"#释放-Page\" class=\"headerlink\" title=\"释放 Page\"></a>释放 Page</h3><p>前面提到，当 <code>free_list</code> 列表为空时，会首先尝试从 <code>LRU</code> 列表中进行回收，Page 的释放入口函数为 <code>buf_LRU_free_page</code> ，该方法的主要处理流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |--&gt; buf_page_can_relocate <span class=\"comment\">// 检查 buf_fix_count 计数和 io_fix 状态</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_LRU_block_remove_hashed <span class=\"comment\">// 从 LRU 和 page_hash 中删除</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_remove_block</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_old_adjust_len</span><br><span class=\"line\">|    |    |--&gt; HASH_DELETE</span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; btr_search_drop_page_hash_index <span class=\"comment\">// 从 AHI 中删除</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_LRU_block_free_hashed_page <span class=\"comment\">// 放回 free_list</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_block_free_non_file_page</span><br></pre></td></tr></table></figure>\n\n<p>释放 1 个 Page 时，首先需要检查 <code>io_fix</code> 状态和 <code>buf_fix_count</code> 计数，确保当前 Page 没有被使用，然后将 Block 从依次从 <code>LRU</code> 列表、<code>page_hash</code> 、<code>AHI</code> 中删除，最后将 Block 重新放入到 <code>free_list</code> 列表中。</p>\n<h3 id=\"同步刷脏\"><a href=\"#同步刷脏\" class=\"headerlink\" title=\"同步刷脏\"></a>同步刷脏</h3><p>同步刷脏的入口函数为 <code>buf_flush_page</code> ，同步刷脏过程仅会刷 1 个 Page，保证能够获取到 1 个可用的 Block，主要处理流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_flush_page <span class=\"comment\">// 刷单个 page</span></span><br><span class=\"line\">|    |--&gt; buf_page_set_io_fix <span class=\"comment\">// io_fix 设置为 BUF_IO_WRITE</span></span><br><span class=\"line\">|    |--&gt; buf_flush_write_block_low</span><br><span class=\"line\">|    |    |--&gt; log_write_up_to <span class=\"comment\">// 写 redo</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; fil_io</span><br><span class=\"line\">|    |    |--&gt; buf_dblwr_write_single_page <span class=\"comment\">// 写数据页</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; fil_flush</span><br><span class=\"line\">|    |    |--&gt; buf_page_io_complete</span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_write_complete</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_flush_remove</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_page_set_io_fix <span class=\"comment\">// io_fix 设置为 BUF_IO_NONE</span></span><br><span class=\"line\">|    |    |    |</span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_free_page</span><br></pre></td></tr></table></figure>\n\n<p>InnoDB 通过严格的 WAL 机制保证数据的一致性，刷脏过程同样如此。首先需要保证对应的日志文件落盘，然后再写入数据页。最后将 Block 从 <code>flush_list</code> 列表中移除，此时 Page 变成可回收状态，再次调用 <code>buf_LRU_free_page</code> 进行回收。</p>\n<p>同步刷脏的过程不仅在获取 Block 时会被调用，在表删除的时候同样会被调用，表删除时会根据 <code>space_id</code> 进行批量的刷脏，入口函数为 <code>buf_LRU_flush_or_remove_pages</code> ，处理流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_LRU_flush_or_remove_pages <span class=\"comment\">// 根据 space_id 刷脏</span></span><br><span class=\"line\">|    |--&gt; buf_LRU_drop_page_hash_for_tablespace <span class=\"comment\">// 遍历 LRU</span></span><br><span class=\"line\">|    |    |--&gt; buf_LRU_drop_page_hash_batch</span><br><span class=\"line\">|    |    |    |--&gt; btr_search_drop_page_hash_when_freed</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_page_get_gen</span><br><span class=\"line\">|    |    |    |    |--&gt; btr_search_drop_page_hash_index <span class=\"comment\">// 从 AHI 中删除</span></span><br><span class=\"line\">|    |</span><br><span class=\"line\">|    |--&gt; buf_LRU_remove_pages</span><br><span class=\"line\">|    |    |--&gt; buf_LRU_remove_all_pages <span class=\"comment\">// 遍历 LRU</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_block_remove_hashed <span class=\"comment\">// 从 LRU 和 page_hash 中删除</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_LRU_block_free_hashed_page <span class=\"comment\">// 放回 free_list</span></span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; buf_flush_dirty_pages</span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_or_remove_pages <span class=\"comment\">// 遍历 flush_list</span></span><br><span class=\"line\">|    |    |    |    |--&gt; buf_flush_or_remove_page</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_flush_remove</span><br><span class=\"line\">|    |    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_flush_page</span><br></pre></td></tr></table></figure>\n\n<p>具体的过程在此不再赘述，大家可以自己去阅读相应的代码。需要注意的是：如果单个 session 中使用了临时表，那么在 session 退出的时候，也会进入到上述的刷脏流程，当 <code>LRU</code> 列表很大时，session 退出的性能将会受到很大的影响。</p>\n<h3 id=\"异步刷脏\"><a href=\"#异步刷脏\" class=\"headerlink\" title=\"异步刷脏\"></a>异步刷脏</h3><p>除了同步刷脏之外，MySQL 中还引入单独的刷脏线程进行异步刷脏。刷脏线程按照功能划分包括两种：coordinator 线程和 cleaner 线程。coordinator 线程会计算最大的刷脏量，然后分配刷脏任务给 cleaner 线程，cleaner 线程进行实际的刷脏工作（coordinator 线程本身也会参与刷脏）。异步刷脏的入口函数为 <code>buf_flush_page_cleaner_init</code> ，基本流程如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|--&gt; buf_flush_page_coordinator_thread</span><br><span class=\"line\">|    |--&gt; os_event_wait(buf_flush_event)</span><br><span class=\"line\">|    </span><br><span class=\"line\">|    <span class=\"comment\">/* loop */</span></span><br><span class=\"line\">|    |--&gt; page_cleaner_flush_pages_recommendation <span class=\"comment\">// 计算最大刷脏量</span></span><br><span class=\"line\">|    |--&gt; pc_request <span class=\"comment\">// 任务分发，slot 数目等于 bp_instance 数目</span></span><br><span class=\"line\">|    |    |--&gt; os_event_set(page_cleaner-&gt;is_requested)</span><br><span class=\"line\">|    |--&gt; pc_flush_slot <span class=\"comment\">// 参与刷脏</span></span><br><span class=\"line\">|    |--&gt; pc_wait_finished</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">|--&gt; buf_flush_page_cleaner_thread</span><br><span class=\"line\">|    |--&gt; os_event_wait(page_cleaner-&gt;is_requested)</span><br><span class=\"line\">|    |--&gt; pc_flush_slot <span class=\"comment\">// 1 个线程处理 1 个 bp_instance</span></span><br><span class=\"line\">|    |    |--&gt; buf_flush_LRU_list <span class=\"comment\">// 从 LRU 中刷脏</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_do_batch(BUF_FLUSH_LRU)</span><br><span class=\"line\">|    |    |</span><br><span class=\"line\">|    |    |--&gt; buf_flush_do_batch(BUF_FLUSH_LIST) <span class=\"comment\">// 从 flush_list 刷脏</span></span><br><span class=\"line\">|    |    |    |--&gt; buf_flush_batch</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_do_LRU_batch</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_free_from_unzip_LRU_list_batch</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_flush_LRU_list_batch</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_LRU_free_page</span><br><span class=\"line\">|    |    |    |    |    |    |--&gt; buf_flush_page_and_try_neighbors</span><br><span class=\"line\">|    |    |    |    |    |    |    |--&gt; buf_flush_try_neighbors</span><br><span class=\"line\">|    |    |    |    |    |    |    |    |--&gt; buf_flush_page</span><br><span class=\"line\">|    |    |    |    |</span><br><span class=\"line\">|    |    |    |    |--&gt; buf_do_flush_list_batch</span><br><span class=\"line\">|    |    |    |    |    |--&gt; buf_flush_page_and_try_neighbors</span><br></pre></td></tr></table></figure>\n\n<p>异步刷脏的具体过程可以参考<a href=\"http://mysql.taobao.org/monthly/2018/09/02/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，异步刷脏过程中有一个非常重要的点就是 <code>page_cleaner_flush_pages_recommendation</code> 计算最大刷脏量，相关的细节在此不再展开，后面有机会再单独整理一篇各种后台线程的更新逻辑。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文从申请、管理、回收三部分对 InnoDB Buffer Page 的生命周期管理进行了介绍，文中的内容只是一个基本概要，更多的细节还需要读者在阅读代码的过程中慢慢发掘。</p>"},{"title":"总 (Li) 体 (Xia) 说明 (Flag)","date":"2020-07-04T04:06:18.000Z","_content":"声明：本文档仅作为个人学习过程中的总结与归纳，如果存在错误或者不严谨的描述，欢迎拍砖。\n\n<!-- more -->\n\n## 整体说明\n\n整个文档包括但是不限于以下内容：\n\n- 数据库管理系统 (DataBase Management System)\n- 分布式系统 (Distributed System)\n- 操作系统 (Operating System)\n- 网络与并行处理 (Network and Parallel Processing)\n- 编程语言 (Program Language)\n- 算法与数据结构 (Algorithm and Data Structure)\n- 其它 (Others)\n\n文档的整理和更新过程比较佛系，希望自己能够长期坚持 : )\n\n### 数据库系统\n\n最早接触数据库是在大学课堂，学校的数据库课程更侧重数据库的使用，当然也有一些数据库的理论介绍，但是体感并不强烈。至少笔者在学完数据库课程之后，留下的印象就只有以下几个关键字：SQL、事务、ACID。随着最近一两年更多的接触数据库，才开始慢慢对数据库有了更多的了解，也希望自己的一些体会能够帮助更多的人认识数据库。\n\n数据库的基础知识这一部分，暂定会从以下几个方面进行介绍：\n\n- 数据库系统与文件系统\n- 一条 SQL 的执行过程\n- 索引与 B-tree 介绍\n- 事务系统\n- Redo 和 Undo\n- 关于 DDL 的说明\n- BufferPool 介绍\n- 高可用与读写分离\n- 存储计算分离\n\n### 分布式系统\n\n分布式系统可以说是最近几年 IT 领域最热门的词汇之一，好像所有的应用系统，不带上“分布式”都显得不够逼格。这里也谈谈自己对分布式系统的一点浅薄的理解：\n\n- Scale Up or Scale Out\n- Paxos and Raft\n- 分布式数据库\n- 分布式文件系统\n\n### 操作系统\n\n不管在什么版本的程序猿鄙视链条中，操作系统内核程序猿永远都是位于顶端的那一拨，由此可见操作系统的重要性，关于操作系统的介绍，完全是结合遇到的问题展开，谈不上深入了解，只能算是一个记录：\n\n- Page Cache\n- IO 模型\n- mmap 的一点说明\n- 神奇的 fork\n- 系统监控\n- VFS 虚拟文件系统\n\n### 网络与并行处理\n\n从理论和实践两个维度对网络相关的知识作一个总结：\n\n- 网络七层\n- 三次握手\n- tcp 与 socket\n- http 与 https\n- pool and epool\n- react 反应堆模式\n- Netty 入门\n- Mycat 介绍\n\n### 编程语言\n\n本人接触的编程语言不算多，迄今为止重度使用的包括：Java、Python、C++。不同的语言有不同的特点，也有一些想通的地方，本部分的文章主要记录编程语言中的一些重要特征和注意事项：\n\n- 面向对象\n- Java 中的并发包\n- C++ 之指针\n- Python = 慢 ？\n- C++ STL\n- 容器类的使用\n- 多线程\n- 同步与异步\n- 生产者与消费者\n- 设计模式\n- 内存管理\n- 常用的测试框架\n\n### 算法与数据结构\n\n这部分会记录一些常见算法与数据结构，当然也包括LeetCode的随笔，内容随缘。\n\n### 其它\n\n所有不能归为上面类型的都放到这里了，包括一些常见的工具使用：\n\n- perf 使用\n- tcpdump 使用\n- wireshark 使用\n- gdb 使用\n- pdb 使用\n- git 使用总结\n- vim 使用总结\n- cgroup 介绍\n- docker 介绍\n\n以上就是本文档的一个总体说明，Flag 已经立下了，希望自己能够坚持。","source":"_posts/menu.md","raw":"---\ntitle: 总 (Li) 体 (Xia) 说明 (Flag)\ndate: 2020-07-04 12:06:18\n---\n声明：本文档仅作为个人学习过程中的总结与归纳，如果存在错误或者不严谨的描述，欢迎拍砖。\n\n<!-- more -->\n\n## 整体说明\n\n整个文档包括但是不限于以下内容：\n\n- 数据库管理系统 (DataBase Management System)\n- 分布式系统 (Distributed System)\n- 操作系统 (Operating System)\n- 网络与并行处理 (Network and Parallel Processing)\n- 编程语言 (Program Language)\n- 算法与数据结构 (Algorithm and Data Structure)\n- 其它 (Others)\n\n文档的整理和更新过程比较佛系，希望自己能够长期坚持 : )\n\n### 数据库系统\n\n最早接触数据库是在大学课堂，学校的数据库课程更侧重数据库的使用，当然也有一些数据库的理论介绍，但是体感并不强烈。至少笔者在学完数据库课程之后，留下的印象就只有以下几个关键字：SQL、事务、ACID。随着最近一两年更多的接触数据库，才开始慢慢对数据库有了更多的了解，也希望自己的一些体会能够帮助更多的人认识数据库。\n\n数据库的基础知识这一部分，暂定会从以下几个方面进行介绍：\n\n- 数据库系统与文件系统\n- 一条 SQL 的执行过程\n- 索引与 B-tree 介绍\n- 事务系统\n- Redo 和 Undo\n- 关于 DDL 的说明\n- BufferPool 介绍\n- 高可用与读写分离\n- 存储计算分离\n\n### 分布式系统\n\n分布式系统可以说是最近几年 IT 领域最热门的词汇之一，好像所有的应用系统，不带上“分布式”都显得不够逼格。这里也谈谈自己对分布式系统的一点浅薄的理解：\n\n- Scale Up or Scale Out\n- Paxos and Raft\n- 分布式数据库\n- 分布式文件系统\n\n### 操作系统\n\n不管在什么版本的程序猿鄙视链条中，操作系统内核程序猿永远都是位于顶端的那一拨，由此可见操作系统的重要性，关于操作系统的介绍，完全是结合遇到的问题展开，谈不上深入了解，只能算是一个记录：\n\n- Page Cache\n- IO 模型\n- mmap 的一点说明\n- 神奇的 fork\n- 系统监控\n- VFS 虚拟文件系统\n\n### 网络与并行处理\n\n从理论和实践两个维度对网络相关的知识作一个总结：\n\n- 网络七层\n- 三次握手\n- tcp 与 socket\n- http 与 https\n- pool and epool\n- react 反应堆模式\n- Netty 入门\n- Mycat 介绍\n\n### 编程语言\n\n本人接触的编程语言不算多，迄今为止重度使用的包括：Java、Python、C++。不同的语言有不同的特点，也有一些想通的地方，本部分的文章主要记录编程语言中的一些重要特征和注意事项：\n\n- 面向对象\n- Java 中的并发包\n- C++ 之指针\n- Python = 慢 ？\n- C++ STL\n- 容器类的使用\n- 多线程\n- 同步与异步\n- 生产者与消费者\n- 设计模式\n- 内存管理\n- 常用的测试框架\n\n### 算法与数据结构\n\n这部分会记录一些常见算法与数据结构，当然也包括LeetCode的随笔，内容随缘。\n\n### 其它\n\n所有不能归为上面类型的都放到这里了，包括一些常见的工具使用：\n\n- perf 使用\n- tcpdump 使用\n- wireshark 使用\n- gdb 使用\n- pdb 使用\n- git 使用总结\n- vim 使用总结\n- cgroup 介绍\n- docker 介绍\n\n以上就是本文档的一个总体说明，Flag 已经立下了，希望自己能够坚持。","slug":"menu","published":1,"updated":"2020-07-17T14:48:42.273Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgluc72h000eowgmfisbeseg","content":"<p>声明：本文档仅作为个人学习过程中的总结与归纳，如果存在错误或者不严谨的描述，欢迎拍砖。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"整体说明\"><a href=\"#整体说明\" class=\"headerlink\" title=\"整体说明\"></a>整体说明</h2><p>整个文档包括但是不限于以下内容：</p>\n<ul>\n<li>数据库管理系统 (DataBase Management System)</li>\n<li>分布式系统 (Distributed System)</li>\n<li>操作系统 (Operating System)</li>\n<li>网络与并行处理 (Network and Parallel Processing)</li>\n<li>编程语言 (Program Language)</li>\n<li>算法与数据结构 (Algorithm and Data Structure)</li>\n<li>其它 (Others)</li>\n</ul>\n<p>文档的整理和更新过程比较佛系，希望自己能够长期坚持 : )</p>\n<h3 id=\"数据库系统\"><a href=\"#数据库系统\" class=\"headerlink\" title=\"数据库系统\"></a>数据库系统</h3><p>最早接触数据库是在大学课堂，学校的数据库课程更侧重数据库的使用，当然也有一些数据库的理论介绍，但是体感并不强烈。至少笔者在学完数据库课程之后，留下的印象就只有以下几个关键字：SQL、事务、ACID。随着最近一两年更多的接触数据库，才开始慢慢对数据库有了更多的了解，也希望自己的一些体会能够帮助更多的人认识数据库。</p>\n<p>数据库的基础知识这一部分，暂定会从以下几个方面进行介绍：</p>\n<ul>\n<li>数据库系统与文件系统</li>\n<li>一条 SQL 的执行过程</li>\n<li>索引与 B-tree 介绍</li>\n<li>事务系统</li>\n<li>Redo 和 Undo</li>\n<li>关于 DDL 的说明</li>\n<li>BufferPool 介绍</li>\n<li>高可用与读写分离</li>\n<li>存储计算分离</li>\n</ul>\n<h3 id=\"分布式系统\"><a href=\"#分布式系统\" class=\"headerlink\" title=\"分布式系统\"></a>分布式系统</h3><p>分布式系统可以说是最近几年 IT 领域最热门的词汇之一，好像所有的应用系统，不带上“分布式”都显得不够逼格。这里也谈谈自己对分布式系统的一点浅薄的理解：</p>\n<ul>\n<li>Scale Up or Scale Out</li>\n<li>Paxos and Raft</li>\n<li>分布式数据库</li>\n<li>分布式文件系统</li>\n</ul>\n<h3 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h3><p>不管在什么版本的程序猿鄙视链条中，操作系统内核程序猿永远都是位于顶端的那一拨，由此可见操作系统的重要性，关于操作系统的介绍，完全是结合遇到的问题展开，谈不上深入了解，只能算是一个记录：</p>\n<ul>\n<li>Page Cache</li>\n<li>IO 模型</li>\n<li>mmap 的一点说明</li>\n<li>神奇的 fork</li>\n<li>系统监控</li>\n<li>VFS 虚拟文件系统</li>\n</ul>\n<h3 id=\"网络与并行处理\"><a href=\"#网络与并行处理\" class=\"headerlink\" title=\"网络与并行处理\"></a>网络与并行处理</h3><p>从理论和实践两个维度对网络相关的知识作一个总结：</p>\n<ul>\n<li>网络七层</li>\n<li>三次握手</li>\n<li>tcp 与 socket</li>\n<li>http 与 https</li>\n<li>pool and epool</li>\n<li>react 反应堆模式</li>\n<li>Netty 入门</li>\n<li>Mycat 介绍</li>\n</ul>\n<h3 id=\"编程语言\"><a href=\"#编程语言\" class=\"headerlink\" title=\"编程语言\"></a>编程语言</h3><p>本人接触的编程语言不算多，迄今为止重度使用的包括：Java、Python、C++。不同的语言有不同的特点，也有一些想通的地方，本部分的文章主要记录编程语言中的一些重要特征和注意事项：</p>\n<ul>\n<li>面向对象</li>\n<li>Java 中的并发包</li>\n<li>C++ 之指针</li>\n<li>Python = 慢 ？</li>\n<li>C++ STL</li>\n<li>容器类的使用</li>\n<li>多线程</li>\n<li>同步与异步</li>\n<li>生产者与消费者</li>\n<li>设计模式</li>\n<li>内存管理</li>\n<li>常用的测试框架</li>\n</ul>\n<h3 id=\"算法与数据结构\"><a href=\"#算法与数据结构\" class=\"headerlink\" title=\"算法与数据结构\"></a>算法与数据结构</h3><p>这部分会记录一些常见算法与数据结构，当然也包括LeetCode的随笔，内容随缘。</p>\n<h3 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h3><p>所有不能归为上面类型的都放到这里了，包括一些常见的工具使用：</p>\n<ul>\n<li>perf 使用</li>\n<li>tcpdump 使用</li>\n<li>wireshark 使用</li>\n<li>gdb 使用</li>\n<li>pdb 使用</li>\n<li>git 使用总结</li>\n<li>vim 使用总结</li>\n<li>cgroup 介绍</li>\n<li>docker 介绍</li>\n</ul>\n<p>以上就是本文档的一个总体说明，Flag 已经立下了，希望自己能够坚持。</p>\n","site":{"data":{}},"excerpt":"<p>声明：本文档仅作为个人学习过程中的总结与归纳，如果存在错误或者不严谨的描述，欢迎拍砖。</p>","more":"<h2 id=\"整体说明\"><a href=\"#整体说明\" class=\"headerlink\" title=\"整体说明\"></a>整体说明</h2><p>整个文档包括但是不限于以下内容：</p>\n<ul>\n<li>数据库管理系统 (DataBase Management System)</li>\n<li>分布式系统 (Distributed System)</li>\n<li>操作系统 (Operating System)</li>\n<li>网络与并行处理 (Network and Parallel Processing)</li>\n<li>编程语言 (Program Language)</li>\n<li>算法与数据结构 (Algorithm and Data Structure)</li>\n<li>其它 (Others)</li>\n</ul>\n<p>文档的整理和更新过程比较佛系，希望自己能够长期坚持 : )</p>\n<h3 id=\"数据库系统\"><a href=\"#数据库系统\" class=\"headerlink\" title=\"数据库系统\"></a>数据库系统</h3><p>最早接触数据库是在大学课堂，学校的数据库课程更侧重数据库的使用，当然也有一些数据库的理论介绍，但是体感并不强烈。至少笔者在学完数据库课程之后，留下的印象就只有以下几个关键字：SQL、事务、ACID。随着最近一两年更多的接触数据库，才开始慢慢对数据库有了更多的了解，也希望自己的一些体会能够帮助更多的人认识数据库。</p>\n<p>数据库的基础知识这一部分，暂定会从以下几个方面进行介绍：</p>\n<ul>\n<li>数据库系统与文件系统</li>\n<li>一条 SQL 的执行过程</li>\n<li>索引与 B-tree 介绍</li>\n<li>事务系统</li>\n<li>Redo 和 Undo</li>\n<li>关于 DDL 的说明</li>\n<li>BufferPool 介绍</li>\n<li>高可用与读写分离</li>\n<li>存储计算分离</li>\n</ul>\n<h3 id=\"分布式系统\"><a href=\"#分布式系统\" class=\"headerlink\" title=\"分布式系统\"></a>分布式系统</h3><p>分布式系统可以说是最近几年 IT 领域最热门的词汇之一，好像所有的应用系统，不带上“分布式”都显得不够逼格。这里也谈谈自己对分布式系统的一点浅薄的理解：</p>\n<ul>\n<li>Scale Up or Scale Out</li>\n<li>Paxos and Raft</li>\n<li>分布式数据库</li>\n<li>分布式文件系统</li>\n</ul>\n<h3 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h3><p>不管在什么版本的程序猿鄙视链条中，操作系统内核程序猿永远都是位于顶端的那一拨，由此可见操作系统的重要性，关于操作系统的介绍，完全是结合遇到的问题展开，谈不上深入了解，只能算是一个记录：</p>\n<ul>\n<li>Page Cache</li>\n<li>IO 模型</li>\n<li>mmap 的一点说明</li>\n<li>神奇的 fork</li>\n<li>系统监控</li>\n<li>VFS 虚拟文件系统</li>\n</ul>\n<h3 id=\"网络与并行处理\"><a href=\"#网络与并行处理\" class=\"headerlink\" title=\"网络与并行处理\"></a>网络与并行处理</h3><p>从理论和实践两个维度对网络相关的知识作一个总结：</p>\n<ul>\n<li>网络七层</li>\n<li>三次握手</li>\n<li>tcp 与 socket</li>\n<li>http 与 https</li>\n<li>pool and epool</li>\n<li>react 反应堆模式</li>\n<li>Netty 入门</li>\n<li>Mycat 介绍</li>\n</ul>\n<h3 id=\"编程语言\"><a href=\"#编程语言\" class=\"headerlink\" title=\"编程语言\"></a>编程语言</h3><p>本人接触的编程语言不算多，迄今为止重度使用的包括：Java、Python、C++。不同的语言有不同的特点，也有一些想通的地方，本部分的文章主要记录编程语言中的一些重要特征和注意事项：</p>\n<ul>\n<li>面向对象</li>\n<li>Java 中的并发包</li>\n<li>C++ 之指针</li>\n<li>Python = 慢 ？</li>\n<li>C++ STL</li>\n<li>容器类的使用</li>\n<li>多线程</li>\n<li>同步与异步</li>\n<li>生产者与消费者</li>\n<li>设计模式</li>\n<li>内存管理</li>\n<li>常用的测试框架</li>\n</ul>\n<h3 id=\"算法与数据结构\"><a href=\"#算法与数据结构\" class=\"headerlink\" title=\"算法与数据结构\"></a>算法与数据结构</h3><p>这部分会记录一些常见算法与数据结构，当然也包括LeetCode的随笔，内容随缘。</p>\n<h3 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h3><p>所有不能归为上面类型的都放到这里了，包括一些常见的工具使用：</p>\n<ul>\n<li>perf 使用</li>\n<li>tcpdump 使用</li>\n<li>wireshark 使用</li>\n<li>gdb 使用</li>\n<li>pdb 使用</li>\n<li>git 使用总结</li>\n<li>vim 使用总结</li>\n<li>cgroup 介绍</li>\n<li>docker 介绍</li>\n</ul>\n<p>以上就是本文档的一个总体说明，Flag 已经立下了，希望自己能够坚持。</p>"},{"title":"磁盘 IO 性能分析","date":"2020-09-13T09:32:55.000Z","_content":"\n数据库管理系统是基于文件系统建立起来的，在考虑数据库性能的时候，一个重要的考虑指标就是磁盘的 IO 性能，本篇文章就传统的机械磁盘（HDD）、固态硬盘（SSD）的 IO 性能进行定量的分析。\n\n<!-- more -->\n\n> https://cloud.tencent.com/developer/article/1159044\n>\n> https://juejin.im/post/6844904088715411463\n>\n> https://zhuanlan.zhihu.com/p/59514527\n\n","source":"_posts/io-performance.md","raw":"---\ntitle: 磁盘 IO 性能分析\ndate: 2020-09-13 17:32:55\ncategories: \n- 其它\n\n---\n\n数据库管理系统是基于文件系统建立起来的，在考虑数据库性能的时候，一个重要的考虑指标就是磁盘的 IO 性能，本篇文章就传统的机械磁盘（HDD）、固态硬盘（SSD）的 IO 性能进行定量的分析。\n\n<!-- more -->\n\n> https://cloud.tencent.com/developer/article/1159044\n>\n> https://juejin.im/post/6844904088715411463\n>\n> https://zhuanlan.zhihu.com/p/59514527\n\n","slug":"io-performance","published":1,"updated":"2020-09-14T01:41:28.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgluc72j000iowgm2lhb3ghj","content":"<p>数据库管理系统是基于文件系统建立起来的，在考虑数据库性能的时候，一个重要的考虑指标就是磁盘的 IO 性能，本篇文章就传统的机械磁盘（HDD）、固态硬盘（SSD）的 IO 性能进行定量的分析。</p>\n<a id=\"more\"></a>\n\n<blockquote>\n<p><a href=\"https://cloud.tencent.com/developer/article/1159044\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/article/1159044</a></p>\n<p><a href=\"https://juejin.im/post/6844904088715411463\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/6844904088715411463</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/59514527\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/59514527</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>数据库管理系统是基于文件系统建立起来的，在考虑数据库性能的时候，一个重要的考虑指标就是磁盘的 IO 性能，本篇文章就传统的机械磁盘（HDD）、固态硬盘（SSD）的 IO 性能进行定量的分析。</p>","more":"<blockquote>\n<p><a href=\"https://cloud.tencent.com/developer/article/1159044\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/article/1159044</a></p>\n<p><a href=\"https://juejin.im/post/6844904088715411463\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/6844904088715411463</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/59514527\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/59514527</a></p>\n</blockquote>"},{"title":"perf 工具使用简介","date":"2020-07-18T12:07:30.000Z","_content":"\nperf 工具是 Linux 平台下进行性能分析的一个非常常用的工具，这篇文章对 perf 工具的使用进行一个简单的介绍。\n\n<!-- more -->\n\n## perf 工具介绍\n\nperf 是 Linux 平台下用来进行软件性能分析的工具。最初的时候叫做 Performance Counter，在 2.6.31 中第一次亮相，此后成为内核开发最为活跃的一个领域，在 2.6.32 中正式改名为 Performance Event，因为 perf 已不再仅仅作为 PMU 的抽象，而是能够处理所有的性能相关的事件。通过它，应用程序可以利用 PMU，tracepoint 和内核中的特殊计数器来进行性能统计。\n\nperf 不但可以分析指定应用程序的性能问题（per thread），也可以用来分析内核的性能问题，当然也可以同时分析应用代码和内核，从而全面理解应用程序中的性能瓶颈。使用 perf 可以分析程序运行期间发生的硬件事件，比如 instructions retired ，processor clock cycles 等；也可以分析软件事件，比如 Page Fault 和进程切换。\n\n## 命令\n\n下面简单介绍下 perf 工具常见的几种使用模式，更加丰富的使用说明，可以参考：\n\n> http://www.brendangregg.com/perf.html\n\n### perf stat\n\n执行一个命令并收集其运行过程中的各个数据，可以提供一个程序运行情况的总体概览，使用方式如下：\n\n```shell\nperf stat cmd\n```\n\n### perf top\n\n实时显示当前系统的性能统计信息。该命令主要用来观察整个系统当前的状态，比如可以通过查看该命令的输出来查看当前系统最耗时的内核函数或某个用户进程，也可以用来实时查看某个进程的运行情况，使用方式如下：\n\n```she\nperf top\n\nperf top -p $PID\n```\n\n### perf report\n\n记录单个函数级别的统计信息，常用来分析某个进程的热点，perf record 不会将结果显示出来，而是将结果输出到文件中，可以用 perf report 来进行解析，使用方式如下：\n\n```shell\nperf record -F 99 -p PID -g -- sleep 10\n\nperf report\n```\n\n","source":"_posts/perf-linux.md","raw":"---\ntitle: perf 工具使用简介\ndate: 2020-07-18 20:07:30\ntags:\n- Linux\ncategories: \n- 其它\n---\n\nperf 工具是 Linux 平台下进行性能分析的一个非常常用的工具，这篇文章对 perf 工具的使用进行一个简单的介绍。\n\n<!-- more -->\n\n## perf 工具介绍\n\nperf 是 Linux 平台下用来进行软件性能分析的工具。最初的时候叫做 Performance Counter，在 2.6.31 中第一次亮相，此后成为内核开发最为活跃的一个领域，在 2.6.32 中正式改名为 Performance Event，因为 perf 已不再仅仅作为 PMU 的抽象，而是能够处理所有的性能相关的事件。通过它，应用程序可以利用 PMU，tracepoint 和内核中的特殊计数器来进行性能统计。\n\nperf 不但可以分析指定应用程序的性能问题（per thread），也可以用来分析内核的性能问题，当然也可以同时分析应用代码和内核，从而全面理解应用程序中的性能瓶颈。使用 perf 可以分析程序运行期间发生的硬件事件，比如 instructions retired ，processor clock cycles 等；也可以分析软件事件，比如 Page Fault 和进程切换。\n\n## 命令\n\n下面简单介绍下 perf 工具常见的几种使用模式，更加丰富的使用说明，可以参考：\n\n> http://www.brendangregg.com/perf.html\n\n### perf stat\n\n执行一个命令并收集其运行过程中的各个数据，可以提供一个程序运行情况的总体概览，使用方式如下：\n\n```shell\nperf stat cmd\n```\n\n### perf top\n\n实时显示当前系统的性能统计信息。该命令主要用来观察整个系统当前的状态，比如可以通过查看该命令的输出来查看当前系统最耗时的内核函数或某个用户进程，也可以用来实时查看某个进程的运行情况，使用方式如下：\n\n```she\nperf top\n\nperf top -p $PID\n```\n\n### perf report\n\n记录单个函数级别的统计信息，常用来分析某个进程的热点，perf record 不会将结果显示出来，而是将结果输出到文件中，可以用 perf report 来进行解析，使用方式如下：\n\n```shell\nperf record -F 99 -p PID -g -- sleep 10\n\nperf report\n```\n\n","slug":"perf-linux","published":1,"updated":"2020-07-18T13:36:36.261Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgluc72l000kowgm90ejea7q","content":"<p>perf 工具是 Linux 平台下进行性能分析的一个非常常用的工具，这篇文章对 perf 工具的使用进行一个简单的介绍。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"perf-工具介绍\"><a href=\"#perf-工具介绍\" class=\"headerlink\" title=\"perf 工具介绍\"></a>perf 工具介绍</h2><p>perf 是 Linux 平台下用来进行软件性能分析的工具。最初的时候叫做 Performance Counter，在 2.6.31 中第一次亮相，此后成为内核开发最为活跃的一个领域，在 2.6.32 中正式改名为 Performance Event，因为 perf 已不再仅仅作为 PMU 的抽象，而是能够处理所有的性能相关的事件。通过它，应用程序可以利用 PMU，tracepoint 和内核中的特殊计数器来进行性能统计。</p>\n<p>perf 不但可以分析指定应用程序的性能问题（per thread），也可以用来分析内核的性能问题，当然也可以同时分析应用代码和内核，从而全面理解应用程序中的性能瓶颈。使用 perf 可以分析程序运行期间发生的硬件事件，比如 instructions retired ，processor clock cycles 等；也可以分析软件事件，比如 Page Fault 和进程切换。</p>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p>下面简单介绍下 perf 工具常见的几种使用模式，更加丰富的使用说明，可以参考：</p>\n<blockquote>\n<p><a href=\"http://www.brendangregg.com/perf.html\" target=\"_blank\" rel=\"noopener\">http://www.brendangregg.com/perf.html</a></p>\n</blockquote>\n<h3 id=\"perf-stat\"><a href=\"#perf-stat\" class=\"headerlink\" title=\"perf stat\"></a>perf stat</h3><p>执行一个命令并收集其运行过程中的各个数据，可以提供一个程序运行情况的总体概览，使用方式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perf stat cmd</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"perf-top\"><a href=\"#perf-top\" class=\"headerlink\" title=\"perf top\"></a>perf top</h3><p>实时显示当前系统的性能统计信息。该命令主要用来观察整个系统当前的状态，比如可以通过查看该命令的输出来查看当前系统最耗时的内核函数或某个用户进程，也可以用来实时查看某个进程的运行情况，使用方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perf top</span><br><span class=\"line\"></span><br><span class=\"line\">perf top -p $PID</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"perf-report\"><a href=\"#perf-report\" class=\"headerlink\" title=\"perf report\"></a>perf report</h3><p>记录单个函数级别的统计信息，常用来分析某个进程的热点，perf record 不会将结果显示出来，而是将结果输出到文件中，可以用 perf report 来进行解析，使用方式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perf record -F 99 -p PID -g -- sleep 10</span><br><span class=\"line\"></span><br><span class=\"line\">perf report</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>perf 工具是 Linux 平台下进行性能分析的一个非常常用的工具，这篇文章对 perf 工具的使用进行一个简单的介绍。</p>","more":"<h2 id=\"perf-工具介绍\"><a href=\"#perf-工具介绍\" class=\"headerlink\" title=\"perf 工具介绍\"></a>perf 工具介绍</h2><p>perf 是 Linux 平台下用来进行软件性能分析的工具。最初的时候叫做 Performance Counter，在 2.6.31 中第一次亮相，此后成为内核开发最为活跃的一个领域，在 2.6.32 中正式改名为 Performance Event，因为 perf 已不再仅仅作为 PMU 的抽象，而是能够处理所有的性能相关的事件。通过它，应用程序可以利用 PMU，tracepoint 和内核中的特殊计数器来进行性能统计。</p>\n<p>perf 不但可以分析指定应用程序的性能问题（per thread），也可以用来分析内核的性能问题，当然也可以同时分析应用代码和内核，从而全面理解应用程序中的性能瓶颈。使用 perf 可以分析程序运行期间发生的硬件事件，比如 instructions retired ，processor clock cycles 等；也可以分析软件事件，比如 Page Fault 和进程切换。</p>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p>下面简单介绍下 perf 工具常见的几种使用模式，更加丰富的使用说明，可以参考：</p>\n<blockquote>\n<p><a href=\"http://www.brendangregg.com/perf.html\" target=\"_blank\" rel=\"noopener\">http://www.brendangregg.com/perf.html</a></p>\n</blockquote>\n<h3 id=\"perf-stat\"><a href=\"#perf-stat\" class=\"headerlink\" title=\"perf stat\"></a>perf stat</h3><p>执行一个命令并收集其运行过程中的各个数据，可以提供一个程序运行情况的总体概览，使用方式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perf stat cmd</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"perf-top\"><a href=\"#perf-top\" class=\"headerlink\" title=\"perf top\"></a>perf top</h3><p>实时显示当前系统的性能统计信息。该命令主要用来观察整个系统当前的状态，比如可以通过查看该命令的输出来查看当前系统最耗时的内核函数或某个用户进程，也可以用来实时查看某个进程的运行情况，使用方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perf top</span><br><span class=\"line\"></span><br><span class=\"line\">perf top -p $PID</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"perf-report\"><a href=\"#perf-report\" class=\"headerlink\" title=\"perf report\"></a>perf report</h3><p>记录单个函数级别的统计信息，常用来分析某个进程的热点，perf record 不会将结果显示出来，而是将结果输出到文件中，可以用 perf report 来进行解析，使用方式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perf record -F 99 -p PID -g -- sleep 10</span><br><span class=\"line\"></span><br><span class=\"line\">perf report</span><br></pre></td></tr></table></figure>"},{"title":"tcpdump 工具使用简介","date":"2020-07-18T12:38:37.000Z","_content":"\ntcpdump 工具是 Linux 平台下进行网络抓包的工具，tcpdump 抓包 + wireshark 分析也是分析网络问题的黄金搭档。本文对 tcpdump 的使用进行一个简单总结。\n\n<!-- more -->\n\n## tcpdump 工具介绍\n\ntcpdump 是一款强大的网络抓包工具，它使用 libpcap 库来抓取网络数据包，最初设计用于观察 TCP/IP 性能问题，但是后来逐步发展成为一个完整的网络分析工具。\n\n## 命令\n\n下面简单介绍下 tcpdump 工具常见的几种使用模式，更加丰富的使用说明，可以参考：\n\n> https://www.tcpdump.org/manpages/tcpdump.1.html\n>\n> https://github.com/mylxsw/growing-up/blob/master/doc/tcpdump简明教程.md\n\n### 简易命令\n\n```shell\ntcpdump -tttt -s0 -X -vv tcp port 8080 -w xxx.cap\n```\n\n### 使用选项\n\n- **-i any** 监听所有的网卡接口，用来查看是否有网络流量\n- **-i eth0** 只监听 eth0 网卡接口\n- **-D** 显示可用的接口列表\n- **-n** 不要解析主机名\n- **-nn** 不要解析主机名或者端口名\n- **-q** 显示更少的输出（更加 quiet）\n- **-t** 输出可读的时间戳\n- **-tttt** 输出最大程度可读的时间戳\n- **-X** 以 hex 和 ASCII 两种形式显示包的内容\n- **-XX** 与 **-X** 类似，增加以太网header的显示\n- **-v, -vv, -vvv** 显示更加多的包信息\n- **-c** 只读取 x 个包，然后停止\n- **-w file**  把捕获的包数据写入到文件中\n- **-C size**  使用 **-w** 写入文件时，限制文件的最大大小，超出时新开一个文件，单位 MB\n- **-s** 指定每一个包捕获的长度，单位是 byte，使用 -s0 可以捕获整个包的内容\n- **-S** 输出绝对的序列号\n- **-e** 获取以太网 header\n- **-E** 使用提供的秘钥解密 IPSEC 流量\n\n### 表达式\n\n可以使用表达式过滤指定类型的流量，有三种主要的表达式类型：\n\n- 类型（type）选项包含：host，net，port\n- 方向（dir）选项包含：src，dst\n- 协议（proto）选项包含：tcp，udp，icmp，ah 等","source":"_posts/tcpdump-linux.md","raw":"---\ntitle: tcpdump 工具使用简介\ndate: 2020-07-18 20:38:37\ntags:\n- Linux\ncategories: \n- 其它\n---\n\ntcpdump 工具是 Linux 平台下进行网络抓包的工具，tcpdump 抓包 + wireshark 分析也是分析网络问题的黄金搭档。本文对 tcpdump 的使用进行一个简单总结。\n\n<!-- more -->\n\n## tcpdump 工具介绍\n\ntcpdump 是一款强大的网络抓包工具，它使用 libpcap 库来抓取网络数据包，最初设计用于观察 TCP/IP 性能问题，但是后来逐步发展成为一个完整的网络分析工具。\n\n## 命令\n\n下面简单介绍下 tcpdump 工具常见的几种使用模式，更加丰富的使用说明，可以参考：\n\n> https://www.tcpdump.org/manpages/tcpdump.1.html\n>\n> https://github.com/mylxsw/growing-up/blob/master/doc/tcpdump简明教程.md\n\n### 简易命令\n\n```shell\ntcpdump -tttt -s0 -X -vv tcp port 8080 -w xxx.cap\n```\n\n### 使用选项\n\n- **-i any** 监听所有的网卡接口，用来查看是否有网络流量\n- **-i eth0** 只监听 eth0 网卡接口\n- **-D** 显示可用的接口列表\n- **-n** 不要解析主机名\n- **-nn** 不要解析主机名或者端口名\n- **-q** 显示更少的输出（更加 quiet）\n- **-t** 输出可读的时间戳\n- **-tttt** 输出最大程度可读的时间戳\n- **-X** 以 hex 和 ASCII 两种形式显示包的内容\n- **-XX** 与 **-X** 类似，增加以太网header的显示\n- **-v, -vv, -vvv** 显示更加多的包信息\n- **-c** 只读取 x 个包，然后停止\n- **-w file**  把捕获的包数据写入到文件中\n- **-C size**  使用 **-w** 写入文件时，限制文件的最大大小，超出时新开一个文件，单位 MB\n- **-s** 指定每一个包捕获的长度，单位是 byte，使用 -s0 可以捕获整个包的内容\n- **-S** 输出绝对的序列号\n- **-e** 获取以太网 header\n- **-E** 使用提供的秘钥解密 IPSEC 流量\n\n### 表达式\n\n可以使用表达式过滤指定类型的流量，有三种主要的表达式类型：\n\n- 类型（type）选项包含：host，net，port\n- 方向（dir）选项包含：src，dst\n- 协议（proto）选项包含：tcp，udp，icmp，ah 等","slug":"tcpdump-linux","published":1,"updated":"2020-07-18T13:02:58.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgluc72n000oowgm31bk5puk","content":"<p>tcpdump 工具是 Linux 平台下进行网络抓包的工具，tcpdump 抓包 + wireshark 分析也是分析网络问题的黄金搭档。本文对 tcpdump 的使用进行一个简单总结。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"tcpdump-工具介绍\"><a href=\"#tcpdump-工具介绍\" class=\"headerlink\" title=\"tcpdump 工具介绍\"></a>tcpdump 工具介绍</h2><p>tcpdump 是一款强大的网络抓包工具，它使用 libpcap 库来抓取网络数据包，最初设计用于观察 TCP/IP 性能问题，但是后来逐步发展成为一个完整的网络分析工具。</p>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p>下面简单介绍下 tcpdump 工具常见的几种使用模式，更加丰富的使用说明，可以参考：</p>\n<blockquote>\n<p><a href=\"https://www.tcpdump.org/manpages/tcpdump.1.html\" target=\"_blank\" rel=\"noopener\">https://www.tcpdump.org/manpages/tcpdump.1.html</a></p>\n<p><a href=\"https://github.com/mylxsw/growing-up/blob/master/doc/tcpdump简明教程.md\" target=\"_blank\" rel=\"noopener\">https://github.com/mylxsw/growing-up/blob/master/doc/tcpdump简明教程.md</a></p>\n</blockquote>\n<h3 id=\"简易命令\"><a href=\"#简易命令\" class=\"headerlink\" title=\"简易命令\"></a>简易命令</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcpdump -tttt -s0 -X -vv tcp port 8080 -w xxx.cap</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用选项\"><a href=\"#使用选项\" class=\"headerlink\" title=\"使用选项\"></a>使用选项</h3><ul>\n<li><strong>-i any</strong> 监听所有的网卡接口，用来查看是否有网络流量</li>\n<li><strong>-i eth0</strong> 只监听 eth0 网卡接口</li>\n<li><strong>-D</strong> 显示可用的接口列表</li>\n<li><strong>-n</strong> 不要解析主机名</li>\n<li><strong>-nn</strong> 不要解析主机名或者端口名</li>\n<li><strong>-q</strong> 显示更少的输出（更加 quiet）</li>\n<li><strong>-t</strong> 输出可读的时间戳</li>\n<li><strong>-tttt</strong> 输出最大程度可读的时间戳</li>\n<li><strong>-X</strong> 以 hex 和 ASCII 两种形式显示包的内容</li>\n<li><strong>-XX</strong> 与 <strong>-X</strong> 类似，增加以太网header的显示</li>\n<li><strong>-v, -vv, -vvv</strong> 显示更加多的包信息</li>\n<li><strong>-c</strong> 只读取 x 个包，然后停止</li>\n<li><strong>-w file</strong>  把捕获的包数据写入到文件中</li>\n<li><strong>-C size</strong>  使用 <strong>-w</strong> 写入文件时，限制文件的最大大小，超出时新开一个文件，单位 MB</li>\n<li><strong>-s</strong> 指定每一个包捕获的长度，单位是 byte，使用 -s0 可以捕获整个包的内容</li>\n<li><strong>-S</strong> 输出绝对的序列号</li>\n<li><strong>-e</strong> 获取以太网 header</li>\n<li><strong>-E</strong> 使用提供的秘钥解密 IPSEC 流量</li>\n</ul>\n<h3 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h3><p>可以使用表达式过滤指定类型的流量，有三种主要的表达式类型：</p>\n<ul>\n<li>类型（type）选项包含：host，net，port</li>\n<li>方向（dir）选项包含：src，dst</li>\n<li>协议（proto）选项包含：tcp，udp，icmp，ah 等</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>tcpdump 工具是 Linux 平台下进行网络抓包的工具，tcpdump 抓包 + wireshark 分析也是分析网络问题的黄金搭档。本文对 tcpdump 的使用进行一个简单总结。</p>","more":"<h2 id=\"tcpdump-工具介绍\"><a href=\"#tcpdump-工具介绍\" class=\"headerlink\" title=\"tcpdump 工具介绍\"></a>tcpdump 工具介绍</h2><p>tcpdump 是一款强大的网络抓包工具，它使用 libpcap 库来抓取网络数据包，最初设计用于观察 TCP/IP 性能问题，但是后来逐步发展成为一个完整的网络分析工具。</p>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p>下面简单介绍下 tcpdump 工具常见的几种使用模式，更加丰富的使用说明，可以参考：</p>\n<blockquote>\n<p><a href=\"https://www.tcpdump.org/manpages/tcpdump.1.html\" target=\"_blank\" rel=\"noopener\">https://www.tcpdump.org/manpages/tcpdump.1.html</a></p>\n<p><a href=\"https://github.com/mylxsw/growing-up/blob/master/doc/tcpdump简明教程.md\" target=\"_blank\" rel=\"noopener\">https://github.com/mylxsw/growing-up/blob/master/doc/tcpdump简明教程.md</a></p>\n</blockquote>\n<h3 id=\"简易命令\"><a href=\"#简易命令\" class=\"headerlink\" title=\"简易命令\"></a>简易命令</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcpdump -tttt -s0 -X -vv tcp port 8080 -w xxx.cap</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用选项\"><a href=\"#使用选项\" class=\"headerlink\" title=\"使用选项\"></a>使用选项</h3><ul>\n<li><strong>-i any</strong> 监听所有的网卡接口，用来查看是否有网络流量</li>\n<li><strong>-i eth0</strong> 只监听 eth0 网卡接口</li>\n<li><strong>-D</strong> 显示可用的接口列表</li>\n<li><strong>-n</strong> 不要解析主机名</li>\n<li><strong>-nn</strong> 不要解析主机名或者端口名</li>\n<li><strong>-q</strong> 显示更少的输出（更加 quiet）</li>\n<li><strong>-t</strong> 输出可读的时间戳</li>\n<li><strong>-tttt</strong> 输出最大程度可读的时间戳</li>\n<li><strong>-X</strong> 以 hex 和 ASCII 两种形式显示包的内容</li>\n<li><strong>-XX</strong> 与 <strong>-X</strong> 类似，增加以太网header的显示</li>\n<li><strong>-v, -vv, -vvv</strong> 显示更加多的包信息</li>\n<li><strong>-c</strong> 只读取 x 个包，然后停止</li>\n<li><strong>-w file</strong>  把捕获的包数据写入到文件中</li>\n<li><strong>-C size</strong>  使用 <strong>-w</strong> 写入文件时，限制文件的最大大小，超出时新开一个文件，单位 MB</li>\n<li><strong>-s</strong> 指定每一个包捕获的长度，单位是 byte，使用 -s0 可以捕获整个包的内容</li>\n<li><strong>-S</strong> 输出绝对的序列号</li>\n<li><strong>-e</strong> 获取以太网 header</li>\n<li><strong>-E</strong> 使用提供的秘钥解密 IPSEC 流量</li>\n</ul>\n<h3 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h3><p>可以使用表达式过滤指定类型的流量，有三种主要的表达式类型：</p>\n<ul>\n<li>类型（type）选项包含：host，net，port</li>\n<li>方向（dir）选项包含：src，dst</li>\n<li>协议（proto）选项包含：tcp，udp，icmp，ah 等</li>\n</ul>"},{"title":"一条 SQL 的执行过程","date":"2020-07-04T11:22:11.000Z","_content":"\n现代数据库是一个复杂的系统工程，但是一个典型的数据库系统都是由固定的部分组成，本文以一条 SQL 的执行过程作为入口，对数据库系统的全貌进行一个简单介绍。\n\n<!-- more -->\n\n## 整体架构\n\n如图所示是一个关系型数据库系统的简单架构图，可以看到数据系系统是一个典型的 CS 架构。以 MySQL 为例，一个典型的数据库系统通常由两部分组成：Server 和 Storage Engine。Server 层按照功能划分又可以分为：连接处理（Connection handler）、语法解析（Parser）、优化器（Optimizer）、执行器（Executor）等部分。Storage Engine 也可以有不同的实现方式。\n\n<img src=\"/images/sql-execute-1.jpg\" width=\"78%\"/>\n\n## SQL 执行过程\n\n还是以 MySQL 为例，介绍一条 SQL 的完整执行过程，其它关系型数据库的执行过程与 MySQL 基本类似。\n\n### 连接处理\n\nMySQL 客户端和服务端之间支持多种通信方式，除了最常用的 TCP 通讯外，还支持命名管道和共享内存的方式。以 TCP 通讯为例，MySQL 客户端与服务端的交互主要分为两个阶段：握手认证阶段和命令执行阶段。一次正常的连接过程如下：\n\n```sql\n# 1. 建立 TCP 连接\n\n# 2. 建立 MySQL 连接，协议认证\n\n# 3. 认证通过，等待执行命令\n\n# 4. 断开 MySQL 连接\n\n# 5. 断开 TCP 连接\n```\n\n其中，协议认证过程阶段就会对连接进行 ACL 认证，具体的认证过程和逻辑在此不作过多介绍，认证通过之后，就可以开始正式执行命令了。关于 MySQL 通讯协议的更多介绍，可以参考[这篇文章](https://jin-yang.github.io/post/mysql-protocol.html)。\n\n### 语法解析\n\nSQL 语法的设计也是数据库流行的一个重要原因，相比于传统的检索方式，SQL 语法可以说是相当的简单而且可读性高。SQL 语法有一个语法标准，但是各个数据库在实现的时候都会有自己的特点，以 MySQL 为例，MySQL 也只是兼容了部分 SQL 标准，对此社区有一个[说明](https://dev.mysql.com/doc/refman/8.0/en/compatibility.html)。\n\n语法解析阶段其实包括了：词法分析和语法分析。当前最常用的语法解析方案是 [LEX & YACC](http://dinosaur.compilertools.net/) 的方案，这也是数据库系统里面用的最多的方案。MySQL 采用了一种比较有趣的组合，MySQL 并没有直接使用 LEX 作为词法分析的方案，而是手写了一套词法分析逻辑，但是语法分析依然采用了 YACC。关于 MySQL 语法解析的逻辑，后面会再写一篇文章来进行介绍。需要知道的是：语法解析过程会生成一棵语法树（Lex tree），原始 SQL 中的所有信息都会被记录在这棵树中。\n\n注意：并不是所有的语句都需要经过语法解析的阶段，MySQL 内部实现了一套 Query Cache 机制，针对查询语句进行缓存，当缓存命中时，可以直接返回结果，此时不需要经过语法解析。\n\n### 优化器\n\n顾名思义，优化器的目的就是对用户的查询语句进行优化，找到一个合理的执行计划。之所以说是合理的执行计划，因为优化器本身并不保证所有的执行计划是最优的，而是尽量找到一个可以接受的执行计划。近些年，随着数据的膨胀和数据库本身的发展，对于优化器的研究也变得越来越热门，传统的 OLTP 型数据库也开始借鉴 OLAP 型数据库的优化思路。回到优化器本身，其要做的事情是：确定数据的读取方式和数据的计算方式。\n\n一个最简单的例子，在使用数据库的过程中，当查询很慢的时候，DBA 首先会告诉你的就是：“看一下有没有有索引”。这里面索引的选择就是优化器的工作。\n\n### 执行器\n\n和优化器对应，执行器的工作是执行数据的读取和计算。和存储引擎的交互也都是在执行器内完成。在开始执行前，MySQL 会首先检查一下执行权限，如果没有对应表的权限，会直接返回没有权限的错误。如果有权限，则会根据表的引擎类型，按照优化器生成的执行计划，调用具体的接口进行处理。\n\n### 存储引擎\n\nMySQL 在设计之初就是一个支持多引擎的结构，MySQL 在执行器层定义了一个 handler 接口，接口内描述了所有执行器需要用到的基本操作，所有的存储引擎都需要实现相应的接口。常用的存储引擎包括：MyISAM、InnoDB、CSV、RocksDB等。多引擎的设计确实让 MySQL 拥有了很好的可扩展性，用户可以根据需要在表级指定存储引擎。但是随着 InnoDB 成为 MySQL  的默认引擎，特别是 8.0 版本开始使用 InnoDB 保存数据字典，这种多引擎的支持也会慢慢退出历史舞台。\n\n以上结合数据库的基本架构简单介绍了一条 SQL 的执行过程，当然实际的执行过程远比这个复杂，后续会对各个部分展开说明。","source":"_posts/sql-execute.md","raw":"---\ntitle: 一条 SQL 的执行过程\ndate: 2020-07-04 19:22:11\ntags:\n- MySQL\ncategories: \n- 数据库\n---\n\n现代数据库是一个复杂的系统工程，但是一个典型的数据库系统都是由固定的部分组成，本文以一条 SQL 的执行过程作为入口，对数据库系统的全貌进行一个简单介绍。\n\n<!-- more -->\n\n## 整体架构\n\n如图所示是一个关系型数据库系统的简单架构图，可以看到数据系系统是一个典型的 CS 架构。以 MySQL 为例，一个典型的数据库系统通常由两部分组成：Server 和 Storage Engine。Server 层按照功能划分又可以分为：连接处理（Connection handler）、语法解析（Parser）、优化器（Optimizer）、执行器（Executor）等部分。Storage Engine 也可以有不同的实现方式。\n\n<img src=\"/images/sql-execute-1.jpg\" width=\"78%\"/>\n\n## SQL 执行过程\n\n还是以 MySQL 为例，介绍一条 SQL 的完整执行过程，其它关系型数据库的执行过程与 MySQL 基本类似。\n\n### 连接处理\n\nMySQL 客户端和服务端之间支持多种通信方式，除了最常用的 TCP 通讯外，还支持命名管道和共享内存的方式。以 TCP 通讯为例，MySQL 客户端与服务端的交互主要分为两个阶段：握手认证阶段和命令执行阶段。一次正常的连接过程如下：\n\n```sql\n# 1. 建立 TCP 连接\n\n# 2. 建立 MySQL 连接，协议认证\n\n# 3. 认证通过，等待执行命令\n\n# 4. 断开 MySQL 连接\n\n# 5. 断开 TCP 连接\n```\n\n其中，协议认证过程阶段就会对连接进行 ACL 认证，具体的认证过程和逻辑在此不作过多介绍，认证通过之后，就可以开始正式执行命令了。关于 MySQL 通讯协议的更多介绍，可以参考[这篇文章](https://jin-yang.github.io/post/mysql-protocol.html)。\n\n### 语法解析\n\nSQL 语法的设计也是数据库流行的一个重要原因，相比于传统的检索方式，SQL 语法可以说是相当的简单而且可读性高。SQL 语法有一个语法标准，但是各个数据库在实现的时候都会有自己的特点，以 MySQL 为例，MySQL 也只是兼容了部分 SQL 标准，对此社区有一个[说明](https://dev.mysql.com/doc/refman/8.0/en/compatibility.html)。\n\n语法解析阶段其实包括了：词法分析和语法分析。当前最常用的语法解析方案是 [LEX & YACC](http://dinosaur.compilertools.net/) 的方案，这也是数据库系统里面用的最多的方案。MySQL 采用了一种比较有趣的组合，MySQL 并没有直接使用 LEX 作为词法分析的方案，而是手写了一套词法分析逻辑，但是语法分析依然采用了 YACC。关于 MySQL 语法解析的逻辑，后面会再写一篇文章来进行介绍。需要知道的是：语法解析过程会生成一棵语法树（Lex tree），原始 SQL 中的所有信息都会被记录在这棵树中。\n\n注意：并不是所有的语句都需要经过语法解析的阶段，MySQL 内部实现了一套 Query Cache 机制，针对查询语句进行缓存，当缓存命中时，可以直接返回结果，此时不需要经过语法解析。\n\n### 优化器\n\n顾名思义，优化器的目的就是对用户的查询语句进行优化，找到一个合理的执行计划。之所以说是合理的执行计划，因为优化器本身并不保证所有的执行计划是最优的，而是尽量找到一个可以接受的执行计划。近些年，随着数据的膨胀和数据库本身的发展，对于优化器的研究也变得越来越热门，传统的 OLTP 型数据库也开始借鉴 OLAP 型数据库的优化思路。回到优化器本身，其要做的事情是：确定数据的读取方式和数据的计算方式。\n\n一个最简单的例子，在使用数据库的过程中，当查询很慢的时候，DBA 首先会告诉你的就是：“看一下有没有有索引”。这里面索引的选择就是优化器的工作。\n\n### 执行器\n\n和优化器对应，执行器的工作是执行数据的读取和计算。和存储引擎的交互也都是在执行器内完成。在开始执行前，MySQL 会首先检查一下执行权限，如果没有对应表的权限，会直接返回没有权限的错误。如果有权限，则会根据表的引擎类型，按照优化器生成的执行计划，调用具体的接口进行处理。\n\n### 存储引擎\n\nMySQL 在设计之初就是一个支持多引擎的结构，MySQL 在执行器层定义了一个 handler 接口，接口内描述了所有执行器需要用到的基本操作，所有的存储引擎都需要实现相应的接口。常用的存储引擎包括：MyISAM、InnoDB、CSV、RocksDB等。多引擎的设计确实让 MySQL 拥有了很好的可扩展性，用户可以根据需要在表级指定存储引擎。但是随着 InnoDB 成为 MySQL  的默认引擎，特别是 8.0 版本开始使用 InnoDB 保存数据字典，这种多引擎的支持也会慢慢退出历史舞台。\n\n以上结合数据库的基本架构简单介绍了一条 SQL 的执行过程，当然实际的执行过程远比这个复杂，后续会对各个部分展开说明。","slug":"sql-execute","published":1,"updated":"2020-07-19T08:47:11.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgluc72o000qowgm3gz4de4a","content":"<p>现代数据库是一个复杂的系统工程，但是一个典型的数据库系统都是由固定的部分组成，本文以一条 SQL 的执行过程作为入口，对数据库系统的全貌进行一个简单介绍。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"整体架构\"><a href=\"#整体架构\" class=\"headerlink\" title=\"整体架构\"></a>整体架构</h2><p>如图所示是一个关系型数据库系统的简单架构图，可以看到数据系系统是一个典型的 CS 架构。以 MySQL 为例，一个典型的数据库系统通常由两部分组成：Server 和 Storage Engine。Server 层按照功能划分又可以分为：连接处理（Connection handler）、语法解析（Parser）、优化器（Optimizer）、执行器（Executor）等部分。Storage Engine 也可以有不同的实现方式。</p>\n<img src=\"/images/sql-execute-1.jpg\" width=\"78%\"/>\n\n<h2 id=\"SQL-执行过程\"><a href=\"#SQL-执行过程\" class=\"headerlink\" title=\"SQL 执行过程\"></a>SQL 执行过程</h2><p>还是以 MySQL 为例，介绍一条 SQL 的完整执行过程，其它关系型数据库的执行过程与 MySQL 基本类似。</p>\n<h3 id=\"连接处理\"><a href=\"#连接处理\" class=\"headerlink\" title=\"连接处理\"></a>连接处理</h3><p>MySQL 客户端和服务端之间支持多种通信方式，除了最常用的 TCP 通讯外，还支持命名管道和共享内存的方式。以 TCP 通讯为例，MySQL 客户端与服务端的交互主要分为两个阶段：握手认证阶段和命令执行阶段。一次正常的连接过程如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 建立 TCP 连接</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 建立 MySQL 连接，协议认证</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 认证通过，等待执行命令</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 断开 MySQL 连接</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 断开 TCP 连接</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，协议认证过程阶段就会对连接进行 ACL 认证，具体的认证过程和逻辑在此不作过多介绍，认证通过之后，就可以开始正式执行命令了。关于 MySQL 通讯协议的更多介绍，可以参考<a href=\"https://jin-yang.github.io/post/mysql-protocol.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<h3 id=\"语法解析\"><a href=\"#语法解析\" class=\"headerlink\" title=\"语法解析\"></a>语法解析</h3><p>SQL 语法的设计也是数据库流行的一个重要原因，相比于传统的检索方式，SQL 语法可以说是相当的简单而且可读性高。SQL 语法有一个语法标准，但是各个数据库在实现的时候都会有自己的特点，以 MySQL 为例，MySQL 也只是兼容了部分 SQL 标准，对此社区有一个<a href=\"https://dev.mysql.com/doc/refman/8.0/en/compatibility.html\" target=\"_blank\" rel=\"noopener\">说明</a>。</p>\n<p>语法解析阶段其实包括了：词法分析和语法分析。当前最常用的语法解析方案是 <a href=\"http://dinosaur.compilertools.net/\" target=\"_blank\" rel=\"noopener\">LEX &amp; YACC</a> 的方案，这也是数据库系统里面用的最多的方案。MySQL 采用了一种比较有趣的组合，MySQL 并没有直接使用 LEX 作为词法分析的方案，而是手写了一套词法分析逻辑，但是语法分析依然采用了 YACC。关于 MySQL 语法解析的逻辑，后面会再写一篇文章来进行介绍。需要知道的是：语法解析过程会生成一棵语法树（Lex tree），原始 SQL 中的所有信息都会被记录在这棵树中。</p>\n<p>注意：并不是所有的语句都需要经过语法解析的阶段，MySQL 内部实现了一套 Query Cache 机制，针对查询语句进行缓存，当缓存命中时，可以直接返回结果，此时不需要经过语法解析。</p>\n<h3 id=\"优化器\"><a href=\"#优化器\" class=\"headerlink\" title=\"优化器\"></a>优化器</h3><p>顾名思义，优化器的目的就是对用户的查询语句进行优化，找到一个合理的执行计划。之所以说是合理的执行计划，因为优化器本身并不保证所有的执行计划是最优的，而是尽量找到一个可以接受的执行计划。近些年，随着数据的膨胀和数据库本身的发展，对于优化器的研究也变得越来越热门，传统的 OLTP 型数据库也开始借鉴 OLAP 型数据库的优化思路。回到优化器本身，其要做的事情是：确定数据的读取方式和数据的计算方式。</p>\n<p>一个最简单的例子，在使用数据库的过程中，当查询很慢的时候，DBA 首先会告诉你的就是：“看一下有没有有索引”。这里面索引的选择就是优化器的工作。</p>\n<h3 id=\"执行器\"><a href=\"#执行器\" class=\"headerlink\" title=\"执行器\"></a>执行器</h3><p>和优化器对应，执行器的工作是执行数据的读取和计算。和存储引擎的交互也都是在执行器内完成。在开始执行前，MySQL 会首先检查一下执行权限，如果没有对应表的权限，会直接返回没有权限的错误。如果有权限，则会根据表的引擎类型，按照优化器生成的执行计划，调用具体的接口进行处理。</p>\n<h3 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h3><p>MySQL 在设计之初就是一个支持多引擎的结构，MySQL 在执行器层定义了一个 handler 接口，接口内描述了所有执行器需要用到的基本操作，所有的存储引擎都需要实现相应的接口。常用的存储引擎包括：MyISAM、InnoDB、CSV、RocksDB等。多引擎的设计确实让 MySQL 拥有了很好的可扩展性，用户可以根据需要在表级指定存储引擎。但是随着 InnoDB 成为 MySQL  的默认引擎，特别是 8.0 版本开始使用 InnoDB 保存数据字典，这种多引擎的支持也会慢慢退出历史舞台。</p>\n<p>以上结合数据库的基本架构简单介绍了一条 SQL 的执行过程，当然实际的执行过程远比这个复杂，后续会对各个部分展开说明。</p>\n","site":{"data":{}},"excerpt":"<p>现代数据库是一个复杂的系统工程，但是一个典型的数据库系统都是由固定的部分组成，本文以一条 SQL 的执行过程作为入口，对数据库系统的全貌进行一个简单介绍。</p>","more":"<h2 id=\"整体架构\"><a href=\"#整体架构\" class=\"headerlink\" title=\"整体架构\"></a>整体架构</h2><p>如图所示是一个关系型数据库系统的简单架构图，可以看到数据系系统是一个典型的 CS 架构。以 MySQL 为例，一个典型的数据库系统通常由两部分组成：Server 和 Storage Engine。Server 层按照功能划分又可以分为：连接处理（Connection handler）、语法解析（Parser）、优化器（Optimizer）、执行器（Executor）等部分。Storage Engine 也可以有不同的实现方式。</p>\n<img src=\"/images/sql-execute-1.jpg\" width=\"78%\"/>\n\n<h2 id=\"SQL-执行过程\"><a href=\"#SQL-执行过程\" class=\"headerlink\" title=\"SQL 执行过程\"></a>SQL 执行过程</h2><p>还是以 MySQL 为例，介绍一条 SQL 的完整执行过程，其它关系型数据库的执行过程与 MySQL 基本类似。</p>\n<h3 id=\"连接处理\"><a href=\"#连接处理\" class=\"headerlink\" title=\"连接处理\"></a>连接处理</h3><p>MySQL 客户端和服务端之间支持多种通信方式，除了最常用的 TCP 通讯外，还支持命名管道和共享内存的方式。以 TCP 通讯为例，MySQL 客户端与服务端的交互主要分为两个阶段：握手认证阶段和命令执行阶段。一次正常的连接过程如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 建立 TCP 连接</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 建立 MySQL 连接，协议认证</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 认证通过，等待执行命令</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 断开 MySQL 连接</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 断开 TCP 连接</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，协议认证过程阶段就会对连接进行 ACL 认证，具体的认证过程和逻辑在此不作过多介绍，认证通过之后，就可以开始正式执行命令了。关于 MySQL 通讯协议的更多介绍，可以参考<a href=\"https://jin-yang.github.io/post/mysql-protocol.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<h3 id=\"语法解析\"><a href=\"#语法解析\" class=\"headerlink\" title=\"语法解析\"></a>语法解析</h3><p>SQL 语法的设计也是数据库流行的一个重要原因，相比于传统的检索方式，SQL 语法可以说是相当的简单而且可读性高。SQL 语法有一个语法标准，但是各个数据库在实现的时候都会有自己的特点，以 MySQL 为例，MySQL 也只是兼容了部分 SQL 标准，对此社区有一个<a href=\"https://dev.mysql.com/doc/refman/8.0/en/compatibility.html\" target=\"_blank\" rel=\"noopener\">说明</a>。</p>\n<p>语法解析阶段其实包括了：词法分析和语法分析。当前最常用的语法解析方案是 <a href=\"http://dinosaur.compilertools.net/\" target=\"_blank\" rel=\"noopener\">LEX &amp; YACC</a> 的方案，这也是数据库系统里面用的最多的方案。MySQL 采用了一种比较有趣的组合，MySQL 并没有直接使用 LEX 作为词法分析的方案，而是手写了一套词法分析逻辑，但是语法分析依然采用了 YACC。关于 MySQL 语法解析的逻辑，后面会再写一篇文章来进行介绍。需要知道的是：语法解析过程会生成一棵语法树（Lex tree），原始 SQL 中的所有信息都会被记录在这棵树中。</p>\n<p>注意：并不是所有的语句都需要经过语法解析的阶段，MySQL 内部实现了一套 Query Cache 机制，针对查询语句进行缓存，当缓存命中时，可以直接返回结果，此时不需要经过语法解析。</p>\n<h3 id=\"优化器\"><a href=\"#优化器\" class=\"headerlink\" title=\"优化器\"></a>优化器</h3><p>顾名思义，优化器的目的就是对用户的查询语句进行优化，找到一个合理的执行计划。之所以说是合理的执行计划，因为优化器本身并不保证所有的执行计划是最优的，而是尽量找到一个可以接受的执行计划。近些年，随着数据的膨胀和数据库本身的发展，对于优化器的研究也变得越来越热门，传统的 OLTP 型数据库也开始借鉴 OLAP 型数据库的优化思路。回到优化器本身，其要做的事情是：确定数据的读取方式和数据的计算方式。</p>\n<p>一个最简单的例子，在使用数据库的过程中，当查询很慢的时候，DBA 首先会告诉你的就是：“看一下有没有有索引”。这里面索引的选择就是优化器的工作。</p>\n<h3 id=\"执行器\"><a href=\"#执行器\" class=\"headerlink\" title=\"执行器\"></a>执行器</h3><p>和优化器对应，执行器的工作是执行数据的读取和计算。和存储引擎的交互也都是在执行器内完成。在开始执行前，MySQL 会首先检查一下执行权限，如果没有对应表的权限，会直接返回没有权限的错误。如果有权限，则会根据表的引擎类型，按照优化器生成的执行计划，调用具体的接口进行处理。</p>\n<h3 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h3><p>MySQL 在设计之初就是一个支持多引擎的结构，MySQL 在执行器层定义了一个 handler 接口，接口内描述了所有执行器需要用到的基本操作，所有的存储引擎都需要实现相应的接口。常用的存储引擎包括：MyISAM、InnoDB、CSV、RocksDB等。多引擎的设计确实让 MySQL 拥有了很好的可扩展性，用户可以根据需要在表级指定存储引擎。但是随着 InnoDB 成为 MySQL  的默认引擎，特别是 8.0 版本开始使用 InnoDB 保存数据字典，这种多引擎的支持也会慢慢退出历史舞台。</p>\n<p>以上结合数据库的基本架构简单介绍了一条 SQL 的执行过程，当然实际的执行过程远比这个复杂，后续会对各个部分展开说明。</p>"},{"title":"MySQL X Plugin","date":"2020-07-17T14:33:10.000Z","_content":"\n随着文档型数据库的持续火热，MySQL 也不甘寂寞，开始打起了文档型数据库的主义，全面支持 JSON 数据格式是其中一点，还有一点就是 X Plugin。\n\n<!-- more -->\n\n## What is X Plugin\n\n官方对于 X Plugin 的介绍非常含糊，说了一堆使用的方式，就是不说到底是什么东西。Percona 的一篇文章对此有一个说明，引用如下：\n\n> https://www.percona.com/blog/2019/01/07/understanding-mysql-x-all-flavors/\n\nWhat does the X stand for? Basically, it is a way to name the crossover between relational and document models with extended capabilities, and the X is used for naming the three components we are describing: the Plugin, the Protocol and the DevAPI.\n\n### X Plugin\n\nThis is the actual interface between MySQL server and the clients. By clients we can consider a variety of clients, not only the MySQL shell. It has to be installed in MySQL 5.7 versions via the INSTALL PLUGIN command but comes installed by default in MySQL 8. The plugin adds all the functionality, configuration variables, and status counters we need to use it.\n\nIt has the ability to work with both traditional SQL and Document objects, and also supports CRUD (Create, Read, Update, Delete) operations, asynchronous query execution and so on – this provides a great capacity to extend the current way we work with MySQL.\n\n### X Protocol\n\nThis is a new client protocol created to talk between the X Plugin and Clients. I think it is fair to say this is an eXtended version of the MySQL protocol.\n\nIt was designed with the idea of having the capacity for asynchronous calls, meaning that you can send more than one query to server from same client without the need of waiting for first query to finish before sending the second and so. This improves the overall execution time by saving network round trips between clients and server.\n\nAdditionally, the protocol accepts CRUD operations and, of course, the handling of JSON documents and plain SQL. The protocol is fully implemented in MySQLShell and has several connectors for popular languages (Java and .Net for example)\n\n### X DevAPI\n\nThe last piece of this package is the X DevAPI protocol. Probably the best documented of these pieces is the API implemented on the MySQL Shell and connectors that supports the X Protocol. This API is designed to easily write programs from a given client using some popular languages. For example, we can easily create/test a program from MySQL Shell using Python or JavaScript.\n\n通过上面的描述，基本上可以对 X Plugin 有一个比较直观的认识：**X Plugin 是 MySQL 支持文档模型的一个扩展插件，为了保证对文档模型的操作友好，MySQL 提供了一种全新的协议 X Protocol，并且实现了一套相应的开发接口 X DevAPI**。官方的介绍文档地址如下：\n\n- X Plugin : https://dev.mysql.com/doc/refman/8.0/en/x-plugin.html\n- X Protocol : https://dev.mysql.com/doc/internals/en/x-protocol.html\n- X DevAPI : https://dev.mysql.com/doc/x-devapi-userguide/en/\n\n## How to use\n\n关于 X Plugin 的使用，一个简单的例子如下：\n\n> MySQL Shell Command : https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-configuring.html\n\n```shell\n#mysqlsh\nMySQL Shell 8.0.21\n\nCopyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.\nOracle is a registered trademark of Oracle Corporation and/or its affiliates.\nOther names may be trademarks of their respective owners.\n\nType '\\help' or '\\?' for help; '\\quit' to exit.\n MySQL  JS > \\py\nSwitching to Python mode...\n MySQL  Py >\n MySQL  Py > from mysqlsh import mysqlx\n MySQL  Py > mySession = mysqlx.get_session('test1:123456@127.0.0.1:49320')\n MySQL  Py > myDb = mySession.get_schema('mytest')\n MySQL  Py > myColl = myDb.create_collection('my_collection')\n MySQL  Py > myColl.add({'_id': '1', 'name': 'Laurie', 'age': 19}).execute()\nQuery OK, 1 item affected (0.0076 sec)\n MySQL  Py > myColl.add({'_id': '2', 'name': 'Nadya', 'age': 54}).execute()\nQuery OK, 1 item affected (0.0011 sec)\n MySQL  Py > myColl.add({'_id': '3', 'name': 'Lukas', 'age': 32}).execute()\nQuery OK, 1 item affected (0.0010 sec)\n MySQL  Py >\n MySQL  Py > myColl.find().execute()\n{\n    \"_id\": \"1\",\n    \"age\": 19,\n    \"name\": \"Laurie\"\n}\n{\n    \"_id\": \"2\",\n    \"age\": 54,\n    \"name\": \"Nadya\"\n}\n{\n    \"_id\": \"3\",\n    \"age\": 32,\n    \"name\": \"Lukas\"\n}\n3 documents in set (0.0004 sec)\n MySQL  Py >\n MySQL  Py > \\sql\nSwitching to SQL mode... Commands end with ;\n MySQL  SQL >\n MySQL  SQL > \\connect test1@127.0.0.1:4932\nCreating a session to 'test1@127.0.0.1:4932'\nPlease provide the password for 'test1@127.0.0.1:4932': ******\nFetching schema names for autocompletion... Press ^C to stop.\nYour MySQL connection id is 31\nServer version: 8.0.18-rds-dev Source distribution\nNo default schema selected; type \\use <schema> to set one.\n MySQL  127.0.0.1:4932 ssl  SQL > use mytest\nDefault schema set to `mytest`.\nFetching table and column names from `mytest` for auto-completion... Press ^C to stop.\n MySQL  127.0.0.1:4932 ssl  mytest  SQL > select * from my_collection;\n+-------------------------------------------+-----+\n| doc                                       | _id |\n+-------------------------------------------+-----+\n| {\"_id\": \"1\", \"age\": 19, \"name\": \"Laurie\"} | 1   |\n| {\"_id\": \"2\", \"age\": 54, \"name\": \"Nadya\"}  | 2   |\n| {\"_id\": \"3\", \"age\": 32, \"name\": \"Lukas\"}  | 3   |\n+-------------------------------------------+-----+\n3 rows in set (0.0006 sec)\n MySQL  127.0.0.1:4932 ssl  mytest  SQL > \\q\nBye!\n```\n\n\n\n注意事项：\n\n1. mysqlsh 是 MySQL 提供的一个新的命令行工具，下载地址见：https://dev.mysql.com/downloads/shell/\n2. mysqlsh 提供了丰富的命令操作，详见：https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-commands.html\n3. 使用 mysqlsh 连接时，可能出现如下报错：\n\n```shell\nTraceback (most recent call last):\n  File \"<string>\", line 1, in <module>\nmysqlsh.DBError: MySQL Error (5001): mysqlx.get_session: Capability prepare failed for 'tls'\n```\n\n这是因为 MySQL 没有配置 ssl，本地测试的话可以修改以下两个参数，自动生成证书：\n\n```shell\nauto_detect_certs = ON\nauto_generate_certs = ON\n```","source":"_posts/x-plugin.md","raw":"---\ntitle: MySQL X Plugin\ndate: 2020-07-17 22:33:10\ntags:\n- MySQL\ncategories: \n- 数据库\n---\n\n随着文档型数据库的持续火热，MySQL 也不甘寂寞，开始打起了文档型数据库的主义，全面支持 JSON 数据格式是其中一点，还有一点就是 X Plugin。\n\n<!-- more -->\n\n## What is X Plugin\n\n官方对于 X Plugin 的介绍非常含糊，说了一堆使用的方式，就是不说到底是什么东西。Percona 的一篇文章对此有一个说明，引用如下：\n\n> https://www.percona.com/blog/2019/01/07/understanding-mysql-x-all-flavors/\n\nWhat does the X stand for? Basically, it is a way to name the crossover between relational and document models with extended capabilities, and the X is used for naming the three components we are describing: the Plugin, the Protocol and the DevAPI.\n\n### X Plugin\n\nThis is the actual interface between MySQL server and the clients. By clients we can consider a variety of clients, not only the MySQL shell. It has to be installed in MySQL 5.7 versions via the INSTALL PLUGIN command but comes installed by default in MySQL 8. The plugin adds all the functionality, configuration variables, and status counters we need to use it.\n\nIt has the ability to work with both traditional SQL and Document objects, and also supports CRUD (Create, Read, Update, Delete) operations, asynchronous query execution and so on – this provides a great capacity to extend the current way we work with MySQL.\n\n### X Protocol\n\nThis is a new client protocol created to talk between the X Plugin and Clients. I think it is fair to say this is an eXtended version of the MySQL protocol.\n\nIt was designed with the idea of having the capacity for asynchronous calls, meaning that you can send more than one query to server from same client without the need of waiting for first query to finish before sending the second and so. This improves the overall execution time by saving network round trips between clients and server.\n\nAdditionally, the protocol accepts CRUD operations and, of course, the handling of JSON documents and plain SQL. The protocol is fully implemented in MySQLShell and has several connectors for popular languages (Java and .Net for example)\n\n### X DevAPI\n\nThe last piece of this package is the X DevAPI protocol. Probably the best documented of these pieces is the API implemented on the MySQL Shell and connectors that supports the X Protocol. This API is designed to easily write programs from a given client using some popular languages. For example, we can easily create/test a program from MySQL Shell using Python or JavaScript.\n\n通过上面的描述，基本上可以对 X Plugin 有一个比较直观的认识：**X Plugin 是 MySQL 支持文档模型的一个扩展插件，为了保证对文档模型的操作友好，MySQL 提供了一种全新的协议 X Protocol，并且实现了一套相应的开发接口 X DevAPI**。官方的介绍文档地址如下：\n\n- X Plugin : https://dev.mysql.com/doc/refman/8.0/en/x-plugin.html\n- X Protocol : https://dev.mysql.com/doc/internals/en/x-protocol.html\n- X DevAPI : https://dev.mysql.com/doc/x-devapi-userguide/en/\n\n## How to use\n\n关于 X Plugin 的使用，一个简单的例子如下：\n\n> MySQL Shell Command : https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-configuring.html\n\n```shell\n#mysqlsh\nMySQL Shell 8.0.21\n\nCopyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.\nOracle is a registered trademark of Oracle Corporation and/or its affiliates.\nOther names may be trademarks of their respective owners.\n\nType '\\help' or '\\?' for help; '\\quit' to exit.\n MySQL  JS > \\py\nSwitching to Python mode...\n MySQL  Py >\n MySQL  Py > from mysqlsh import mysqlx\n MySQL  Py > mySession = mysqlx.get_session('test1:123456@127.0.0.1:49320')\n MySQL  Py > myDb = mySession.get_schema('mytest')\n MySQL  Py > myColl = myDb.create_collection('my_collection')\n MySQL  Py > myColl.add({'_id': '1', 'name': 'Laurie', 'age': 19}).execute()\nQuery OK, 1 item affected (0.0076 sec)\n MySQL  Py > myColl.add({'_id': '2', 'name': 'Nadya', 'age': 54}).execute()\nQuery OK, 1 item affected (0.0011 sec)\n MySQL  Py > myColl.add({'_id': '3', 'name': 'Lukas', 'age': 32}).execute()\nQuery OK, 1 item affected (0.0010 sec)\n MySQL  Py >\n MySQL  Py > myColl.find().execute()\n{\n    \"_id\": \"1\",\n    \"age\": 19,\n    \"name\": \"Laurie\"\n}\n{\n    \"_id\": \"2\",\n    \"age\": 54,\n    \"name\": \"Nadya\"\n}\n{\n    \"_id\": \"3\",\n    \"age\": 32,\n    \"name\": \"Lukas\"\n}\n3 documents in set (0.0004 sec)\n MySQL  Py >\n MySQL  Py > \\sql\nSwitching to SQL mode... Commands end with ;\n MySQL  SQL >\n MySQL  SQL > \\connect test1@127.0.0.1:4932\nCreating a session to 'test1@127.0.0.1:4932'\nPlease provide the password for 'test1@127.0.0.1:4932': ******\nFetching schema names for autocompletion... Press ^C to stop.\nYour MySQL connection id is 31\nServer version: 8.0.18-rds-dev Source distribution\nNo default schema selected; type \\use <schema> to set one.\n MySQL  127.0.0.1:4932 ssl  SQL > use mytest\nDefault schema set to `mytest`.\nFetching table and column names from `mytest` for auto-completion... Press ^C to stop.\n MySQL  127.0.0.1:4932 ssl  mytest  SQL > select * from my_collection;\n+-------------------------------------------+-----+\n| doc                                       | _id |\n+-------------------------------------------+-----+\n| {\"_id\": \"1\", \"age\": 19, \"name\": \"Laurie\"} | 1   |\n| {\"_id\": \"2\", \"age\": 54, \"name\": \"Nadya\"}  | 2   |\n| {\"_id\": \"3\", \"age\": 32, \"name\": \"Lukas\"}  | 3   |\n+-------------------------------------------+-----+\n3 rows in set (0.0006 sec)\n MySQL  127.0.0.1:4932 ssl  mytest  SQL > \\q\nBye!\n```\n\n\n\n注意事项：\n\n1. mysqlsh 是 MySQL 提供的一个新的命令行工具，下载地址见：https://dev.mysql.com/downloads/shell/\n2. mysqlsh 提供了丰富的命令操作，详见：https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-commands.html\n3. 使用 mysqlsh 连接时，可能出现如下报错：\n\n```shell\nTraceback (most recent call last):\n  File \"<string>\", line 1, in <module>\nmysqlsh.DBError: MySQL Error (5001): mysqlx.get_session: Capability prepare failed for 'tls'\n```\n\n这是因为 MySQL 没有配置 ssl，本地测试的话可以修改以下两个参数，自动生成证书：\n\n```shell\nauto_detect_certs = ON\nauto_generate_certs = ON\n```","slug":"x-plugin","published":1,"updated":"2020-07-18T13:36:54.647Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgluc72q000vowgm5kgo4jbm","content":"<p>随着文档型数据库的持续火热，MySQL 也不甘寂寞，开始打起了文档型数据库的主义，全面支持 JSON 数据格式是其中一点，还有一点就是 X Plugin。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"What-is-X-Plugin\"><a href=\"#What-is-X-Plugin\" class=\"headerlink\" title=\"What is X Plugin\"></a>What is X Plugin</h2><p>官方对于 X Plugin 的介绍非常含糊，说了一堆使用的方式，就是不说到底是什么东西。Percona 的一篇文章对此有一个说明，引用如下：</p>\n<blockquote>\n<p><a href=\"https://www.percona.com/blog/2019/01/07/understanding-mysql-x-all-flavors/\" target=\"_blank\" rel=\"noopener\">https://www.percona.com/blog/2019/01/07/understanding-mysql-x-all-flavors/</a></p>\n</blockquote>\n<p>What does the X stand for? Basically, it is a way to name the crossover between relational and document models with extended capabilities, and the X is used for naming the three components we are describing: the Plugin, the Protocol and the DevAPI.</p>\n<h3 id=\"X-Plugin\"><a href=\"#X-Plugin\" class=\"headerlink\" title=\"X Plugin\"></a>X Plugin</h3><p>This is the actual interface between MySQL server and the clients. By clients we can consider a variety of clients, not only the MySQL shell. It has to be installed in MySQL 5.7 versions via the INSTALL PLUGIN command but comes installed by default in MySQL 8. The plugin adds all the functionality, configuration variables, and status counters we need to use it.</p>\n<p>It has the ability to work with both traditional SQL and Document objects, and also supports CRUD (Create, Read, Update, Delete) operations, asynchronous query execution and so on – this provides a great capacity to extend the current way we work with MySQL.</p>\n<h3 id=\"X-Protocol\"><a href=\"#X-Protocol\" class=\"headerlink\" title=\"X Protocol\"></a>X Protocol</h3><p>This is a new client protocol created to talk between the X Plugin and Clients. I think it is fair to say this is an eXtended version of the MySQL protocol.</p>\n<p>It was designed with the idea of having the capacity for asynchronous calls, meaning that you can send more than one query to server from same client without the need of waiting for first query to finish before sending the second and so. This improves the overall execution time by saving network round trips between clients and server.</p>\n<p>Additionally, the protocol accepts CRUD operations and, of course, the handling of JSON documents and plain SQL. The protocol is fully implemented in MySQLShell and has several connectors for popular languages (Java and .Net for example)</p>\n<h3 id=\"X-DevAPI\"><a href=\"#X-DevAPI\" class=\"headerlink\" title=\"X DevAPI\"></a>X DevAPI</h3><p>The last piece of this package is the X DevAPI protocol. Probably the best documented of these pieces is the API implemented on the MySQL Shell and connectors that supports the X Protocol. This API is designed to easily write programs from a given client using some popular languages. For example, we can easily create/test a program from MySQL Shell using Python or JavaScript.</p>\n<p>通过上面的描述，基本上可以对 X Plugin 有一个比较直观的认识：<strong>X Plugin 是 MySQL 支持文档模型的一个扩展插件，为了保证对文档模型的操作友好，MySQL 提供了一种全新的协议 X Protocol，并且实现了一套相应的开发接口 X DevAPI</strong>。官方的介绍文档地址如下：</p>\n<ul>\n<li>X Plugin : <a href=\"https://dev.mysql.com/doc/refman/8.0/en/x-plugin.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/8.0/en/x-plugin.html</a></li>\n<li>X Protocol : <a href=\"https://dev.mysql.com/doc/internals/en/x-protocol.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/internals/en/x-protocol.html</a></li>\n<li>X DevAPI : <a href=\"https://dev.mysql.com/doc/x-devapi-userguide/en/\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/x-devapi-userguide/en/</a></li>\n</ul>\n<h2 id=\"How-to-use\"><a href=\"#How-to-use\" class=\"headerlink\" title=\"How to use\"></a>How to use</h2><p>关于 X Plugin 的使用，一个简单的例子如下：</p>\n<blockquote>\n<p>MySQL Shell Command : <a href=\"https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-configuring.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-configuring.html</a></p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">mysqlsh</span></span><br><span class=\"line\">MySQL Shell 8.0.21</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its affiliates.</span><br><span class=\"line\">Other names may be trademarks of their respective owners.</span><br><span class=\"line\"></span><br><span class=\"line\">Type '\\help' or '\\?' for help; '\\quit' to exit.</span><br><span class=\"line\"> MySQL  JS &gt; \\py</span><br><span class=\"line\">Switching to Python mode...</span><br><span class=\"line\"> MySQL  Py &gt;</span><br><span class=\"line\"> MySQL  Py &gt; from mysqlsh import mysqlx</span><br><span class=\"line\"> MySQL  Py &gt; mySession = mysqlx.get_session('test1:123456@127.0.0.1:49320')</span><br><span class=\"line\"> MySQL  Py &gt; myDb = mySession.get_schema('mytest')</span><br><span class=\"line\"> MySQL  Py &gt; myColl = myDb.create_collection('my_collection')</span><br><span class=\"line\"> MySQL  Py &gt; myColl.add(&#123;'_id': '1', 'name': 'Laurie', 'age': 19&#125;).execute()</span><br><span class=\"line\">Query OK, 1 item affected (0.0076 sec)</span><br><span class=\"line\"> MySQL  Py &gt; myColl.add(&#123;'_id': '2', 'name': 'Nadya', 'age': 54&#125;).execute()</span><br><span class=\"line\">Query OK, 1 item affected (0.0011 sec)</span><br><span class=\"line\"> MySQL  Py &gt; myColl.add(&#123;'_id': '3', 'name': 'Lukas', 'age': 32&#125;).execute()</span><br><span class=\"line\">Query OK, 1 item affected (0.0010 sec)</span><br><span class=\"line\"> MySQL  Py &gt;</span><br><span class=\"line\"> MySQL  Py &gt; myColl.find().execute()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"_id\": \"1\",</span><br><span class=\"line\">    \"age\": 19,</span><br><span class=\"line\">    \"name\": \"Laurie\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"_id\": \"2\",</span><br><span class=\"line\">    \"age\": 54,</span><br><span class=\"line\">    \"name\": \"Nadya\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"_id\": \"3\",</span><br><span class=\"line\">    \"age\": 32,</span><br><span class=\"line\">    \"name\": \"Lukas\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">3 documents in set (0.0004 sec)</span><br><span class=\"line\"> MySQL  Py &gt;</span><br><span class=\"line\"> MySQL  Py &gt; \\sql</span><br><span class=\"line\">Switching to SQL mode... Commands end with ;</span><br><span class=\"line\"> MySQL  SQL &gt;</span><br><span class=\"line\"> MySQL  SQL &gt; \\connect test1@127.0.0.1:4932</span><br><span class=\"line\">Creating a session to 'test1@127.0.0.1:4932'</span><br><span class=\"line\">Please provide the password for 'test1@127.0.0.1:4932': ******</span><br><span class=\"line\">Fetching schema names for autocompletion... Press ^C to stop.</span><br><span class=\"line\">Your MySQL connection id is 31</span><br><span class=\"line\">Server version: 8.0.18-rds-dev Source distribution</span><br><span class=\"line\">No default schema selected; type \\use &lt;schema&gt; to set one.</span><br><span class=\"line\"> MySQL  127.0.0.1:4932 ssl  SQL &gt; use mytest</span><br><span class=\"line\">Default schema set to `mytest`.</span><br><span class=\"line\">Fetching table and column names from `mytest` for auto-completion... Press ^C to stop.</span><br><span class=\"line\"> MySQL  127.0.0.1:4932 ssl  mytest  SQL &gt; select * from my_collection;</span><br><span class=\"line\">+-------------------------------------------+-----+</span><br><span class=\"line\">| doc                                       | _id |</span><br><span class=\"line\">+-------------------------------------------+-----+</span><br><span class=\"line\">| &#123;\"_id\": \"1\", \"age\": 19, \"name\": \"Laurie\"&#125; | 1   |</span><br><span class=\"line\">| &#123;\"_id\": \"2\", \"age\": 54, \"name\": \"Nadya\"&#125;  | 2   |</span><br><span class=\"line\">| &#123;\"_id\": \"3\", \"age\": 32, \"name\": \"Lukas\"&#125;  | 3   |</span><br><span class=\"line\">+-------------------------------------------+-----+</span><br><span class=\"line\">3 rows in set (0.0006 sec)</span><br><span class=\"line\"> MySQL  127.0.0.1:4932 ssl  mytest  SQL &gt; \\q</span><br><span class=\"line\">Bye!</span><br></pre></td></tr></table></figure>\n\n\n\n<p>注意事项：</p>\n<ol>\n<li>mysqlsh 是 MySQL 提供的一个新的命令行工具，下载地址见：<a href=\"https://dev.mysql.com/downloads/shell/\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/downloads/shell/</a></li>\n<li>mysqlsh 提供了丰富的命令操作，详见：<a href=\"https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-commands.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-commands.html</a></li>\n<li>使用 mysqlsh 连接时，可能出现如下报错：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File \"&lt;string&gt;\", line 1, in &lt;module&gt;</span><br><span class=\"line\">mysqlsh.DBError: MySQL Error (5001): mysqlx.get_session: Capability prepare failed for 'tls'</span><br></pre></td></tr></table></figure>\n\n<p>这是因为 MySQL 没有配置 ssl，本地测试的话可以修改以下两个参数，自动生成证书：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto_detect_certs = ON</span><br><span class=\"line\">auto_generate_certs = ON</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>随着文档型数据库的持续火热，MySQL 也不甘寂寞，开始打起了文档型数据库的主义，全面支持 JSON 数据格式是其中一点，还有一点就是 X Plugin。</p>","more":"<h2 id=\"What-is-X-Plugin\"><a href=\"#What-is-X-Plugin\" class=\"headerlink\" title=\"What is X Plugin\"></a>What is X Plugin</h2><p>官方对于 X Plugin 的介绍非常含糊，说了一堆使用的方式，就是不说到底是什么东西。Percona 的一篇文章对此有一个说明，引用如下：</p>\n<blockquote>\n<p><a href=\"https://www.percona.com/blog/2019/01/07/understanding-mysql-x-all-flavors/\" target=\"_blank\" rel=\"noopener\">https://www.percona.com/blog/2019/01/07/understanding-mysql-x-all-flavors/</a></p>\n</blockquote>\n<p>What does the X stand for? Basically, it is a way to name the crossover between relational and document models with extended capabilities, and the X is used for naming the three components we are describing: the Plugin, the Protocol and the DevAPI.</p>\n<h3 id=\"X-Plugin\"><a href=\"#X-Plugin\" class=\"headerlink\" title=\"X Plugin\"></a>X Plugin</h3><p>This is the actual interface between MySQL server and the clients. By clients we can consider a variety of clients, not only the MySQL shell. It has to be installed in MySQL 5.7 versions via the INSTALL PLUGIN command but comes installed by default in MySQL 8. The plugin adds all the functionality, configuration variables, and status counters we need to use it.</p>\n<p>It has the ability to work with both traditional SQL and Document objects, and also supports CRUD (Create, Read, Update, Delete) operations, asynchronous query execution and so on – this provides a great capacity to extend the current way we work with MySQL.</p>\n<h3 id=\"X-Protocol\"><a href=\"#X-Protocol\" class=\"headerlink\" title=\"X Protocol\"></a>X Protocol</h3><p>This is a new client protocol created to talk between the X Plugin and Clients. I think it is fair to say this is an eXtended version of the MySQL protocol.</p>\n<p>It was designed with the idea of having the capacity for asynchronous calls, meaning that you can send more than one query to server from same client without the need of waiting for first query to finish before sending the second and so. This improves the overall execution time by saving network round trips between clients and server.</p>\n<p>Additionally, the protocol accepts CRUD operations and, of course, the handling of JSON documents and plain SQL. The protocol is fully implemented in MySQLShell and has several connectors for popular languages (Java and .Net for example)</p>\n<h3 id=\"X-DevAPI\"><a href=\"#X-DevAPI\" class=\"headerlink\" title=\"X DevAPI\"></a>X DevAPI</h3><p>The last piece of this package is the X DevAPI protocol. Probably the best documented of these pieces is the API implemented on the MySQL Shell and connectors that supports the X Protocol. This API is designed to easily write programs from a given client using some popular languages. For example, we can easily create/test a program from MySQL Shell using Python or JavaScript.</p>\n<p>通过上面的描述，基本上可以对 X Plugin 有一个比较直观的认识：<strong>X Plugin 是 MySQL 支持文档模型的一个扩展插件，为了保证对文档模型的操作友好，MySQL 提供了一种全新的协议 X Protocol，并且实现了一套相应的开发接口 X DevAPI</strong>。官方的介绍文档地址如下：</p>\n<ul>\n<li>X Plugin : <a href=\"https://dev.mysql.com/doc/refman/8.0/en/x-plugin.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/8.0/en/x-plugin.html</a></li>\n<li>X Protocol : <a href=\"https://dev.mysql.com/doc/internals/en/x-protocol.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/internals/en/x-protocol.html</a></li>\n<li>X DevAPI : <a href=\"https://dev.mysql.com/doc/x-devapi-userguide/en/\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/x-devapi-userguide/en/</a></li>\n</ul>\n<h2 id=\"How-to-use\"><a href=\"#How-to-use\" class=\"headerlink\" title=\"How to use\"></a>How to use</h2><p>关于 X Plugin 的使用，一个简单的例子如下：</p>\n<blockquote>\n<p>MySQL Shell Command : <a href=\"https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-configuring.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-configuring.html</a></p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">mysqlsh</span></span><br><span class=\"line\">MySQL Shell 8.0.21</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its affiliates.</span><br><span class=\"line\">Other names may be trademarks of their respective owners.</span><br><span class=\"line\"></span><br><span class=\"line\">Type '\\help' or '\\?' for help; '\\quit' to exit.</span><br><span class=\"line\"> MySQL  JS &gt; \\py</span><br><span class=\"line\">Switching to Python mode...</span><br><span class=\"line\"> MySQL  Py &gt;</span><br><span class=\"line\"> MySQL  Py &gt; from mysqlsh import mysqlx</span><br><span class=\"line\"> MySQL  Py &gt; mySession = mysqlx.get_session('test1:123456@127.0.0.1:49320')</span><br><span class=\"line\"> MySQL  Py &gt; myDb = mySession.get_schema('mytest')</span><br><span class=\"line\"> MySQL  Py &gt; myColl = myDb.create_collection('my_collection')</span><br><span class=\"line\"> MySQL  Py &gt; myColl.add(&#123;'_id': '1', 'name': 'Laurie', 'age': 19&#125;).execute()</span><br><span class=\"line\">Query OK, 1 item affected (0.0076 sec)</span><br><span class=\"line\"> MySQL  Py &gt; myColl.add(&#123;'_id': '2', 'name': 'Nadya', 'age': 54&#125;).execute()</span><br><span class=\"line\">Query OK, 1 item affected (0.0011 sec)</span><br><span class=\"line\"> MySQL  Py &gt; myColl.add(&#123;'_id': '3', 'name': 'Lukas', 'age': 32&#125;).execute()</span><br><span class=\"line\">Query OK, 1 item affected (0.0010 sec)</span><br><span class=\"line\"> MySQL  Py &gt;</span><br><span class=\"line\"> MySQL  Py &gt; myColl.find().execute()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"_id\": \"1\",</span><br><span class=\"line\">    \"age\": 19,</span><br><span class=\"line\">    \"name\": \"Laurie\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"_id\": \"2\",</span><br><span class=\"line\">    \"age\": 54,</span><br><span class=\"line\">    \"name\": \"Nadya\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"_id\": \"3\",</span><br><span class=\"line\">    \"age\": 32,</span><br><span class=\"line\">    \"name\": \"Lukas\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">3 documents in set (0.0004 sec)</span><br><span class=\"line\"> MySQL  Py &gt;</span><br><span class=\"line\"> MySQL  Py &gt; \\sql</span><br><span class=\"line\">Switching to SQL mode... Commands end with ;</span><br><span class=\"line\"> MySQL  SQL &gt;</span><br><span class=\"line\"> MySQL  SQL &gt; \\connect test1@127.0.0.1:4932</span><br><span class=\"line\">Creating a session to 'test1@127.0.0.1:4932'</span><br><span class=\"line\">Please provide the password for 'test1@127.0.0.1:4932': ******</span><br><span class=\"line\">Fetching schema names for autocompletion... Press ^C to stop.</span><br><span class=\"line\">Your MySQL connection id is 31</span><br><span class=\"line\">Server version: 8.0.18-rds-dev Source distribution</span><br><span class=\"line\">No default schema selected; type \\use &lt;schema&gt; to set one.</span><br><span class=\"line\"> MySQL  127.0.0.1:4932 ssl  SQL &gt; use mytest</span><br><span class=\"line\">Default schema set to `mytest`.</span><br><span class=\"line\">Fetching table and column names from `mytest` for auto-completion... Press ^C to stop.</span><br><span class=\"line\"> MySQL  127.0.0.1:4932 ssl  mytest  SQL &gt; select * from my_collection;</span><br><span class=\"line\">+-------------------------------------------+-----+</span><br><span class=\"line\">| doc                                       | _id |</span><br><span class=\"line\">+-------------------------------------------+-----+</span><br><span class=\"line\">| &#123;\"_id\": \"1\", \"age\": 19, \"name\": \"Laurie\"&#125; | 1   |</span><br><span class=\"line\">| &#123;\"_id\": \"2\", \"age\": 54, \"name\": \"Nadya\"&#125;  | 2   |</span><br><span class=\"line\">| &#123;\"_id\": \"3\", \"age\": 32, \"name\": \"Lukas\"&#125;  | 3   |</span><br><span class=\"line\">+-------------------------------------------+-----+</span><br><span class=\"line\">3 rows in set (0.0006 sec)</span><br><span class=\"line\"> MySQL  127.0.0.1:4932 ssl  mytest  SQL &gt; \\q</span><br><span class=\"line\">Bye!</span><br></pre></td></tr></table></figure>\n\n\n\n<p>注意事项：</p>\n<ol>\n<li>mysqlsh 是 MySQL 提供的一个新的命令行工具，下载地址见：<a href=\"https://dev.mysql.com/downloads/shell/\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/downloads/shell/</a></li>\n<li>mysqlsh 提供了丰富的命令操作，详见：<a href=\"https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-commands.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-commands.html</a></li>\n<li>使用 mysqlsh 连接时，可能出现如下报错：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File \"&lt;string&gt;\", line 1, in &lt;module&gt;</span><br><span class=\"line\">mysqlsh.DBError: MySQL Error (5001): mysqlx.get_session: Capability prepare failed for 'tls'</span><br></pre></td></tr></table></figure>\n\n<p>这是因为 MySQL 没有配置 ssl，本地测试的话可以修改以下两个参数，自动生成证书：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto_detect_certs = ON</span><br><span class=\"line\">auto_generate_certs = ON</span><br></pre></td></tr></table></figure>"},{"title":"初识事务","date":"2020-07-13T15:03:15.000Z","_content":"\n提到数据库，相信很多人第一个想到的就是事务，今天就从事务开始，对数据库的基本特征以及背后的实现逻辑进行一个简单的说明。\n\n<!-- more -->\n\n## 事务\n\n在写这篇文章的时候，笔者特意又重新查了下事务的定义。维基百科中关于事务的定义是：“事务是数据库系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成”。事务的概念本身并没有什么好展开的，事务之所以成为数据库系统最重要的特征之一，是因为事务的 ACID 属性。\n\n### ACID\n\n**Atomicity（原子性）** ：事务中的一组操作，要么全部成功，要么全部失败，不存在部分成功的情况。原子性的定义相对是比较直观的，可以类比编程语言中的原子操作，从这个角度上来说，事务是数据库系统处理用户操作的最小单位（自动提交模式可以看作是一条语句一个事务）。数据库系统内部主要通过 Undo（回滚日志、前进项）来保证原子性。每一个操作在执行时，都会记录下执行前的状态到 Undo 中，当事务需要回滚时，就可以通过 Undo 恢复到事务执行前的状态。\n\n**Consistency（一致性）** ：数据库总是从一个一致性状态转移到另一个一致性状态。一致性的定义比较模糊，什么叫从一个一致性状态转移到另一个一致性状态？其实这是由于中文的翻译往往只翻译了一半，关于一致性有一段非常最要的补充：\n\n```shell\nAny data written to the database must be valid according to all defined rules, \nincluding constraints, cascades, triggers, and any combination thereof. \n```\n\n总结起来就是：数据库在任意时刻的状态都必须符合所有的验证规则。一个简单的例子：表A记录了用户的账户余额，表B记录了用户的消费记录。从数据库的角度，A中的值与B中记录的和应该总是一个固定值，这就是一条验证规则。另外一个例子：表A存了用户信息，表B存了地址信息，表B中的地址被表A引用（外键），那么删除表B中的记录时，必须检查表A中的记录，这也是一条验证规则。关于一致性的判断，更多的需要与关系间的内在逻辑相结合。\n\n**Isolation（隔离性）** ：不同事务间的操作是相互隔离的，一个事务的操作不受其他事务的影响，也不会影响其他事务。关于隔离性，不同的数据库有不同的实现逻辑，按照可见性进行划分，可以分为四种不同的隔离级别。关于隔离级别，下个部分会进行详细介绍。\n\n**Durability（持久性）** ：一个事务只要提交成功就必须完整保存，不管发生任何软件或者硬件故障都必须保证数据不会丢失。持久性可以说是数据库系统的基础，在真实的业务场景中，数据丢失也往往是最无法容忍的。数据库系统主要通过 Redo（重做日志、后进项）来保证持久性。Redo 是一种典型的 WAL，每一个操作在执行时，都会记录这个操作的内容，并持久化到 Redo 中。当系统恢复时，如果发现之前的操作没有生效，可以通过 Redo 进行重做，保证已提交的操作有效。\n\n### 事务隔离级别\n\n前面提到，按照可见性进行划分，隔离性可以分为四种不同的事务隔离级别，下面逐一进行说明。\n\n**Read Uncommit（读未提交）** ：一个事务的修改可以立即被其它事务读取。读未提交的问题是会出现脏读，举例来说：事务1修改表A的数据，未提交，此时事务2读到了修改项，随后事务1进行了回滚。读未提交是最弱的一种隔离级别，在生产环境中，基本上不会使用。\n\n**Read Committed（读已提交）** ：一个事务的修改在事务提交后可以立即被其它事务读取到。读已提交避免了脏读的问题，这也是当前主流的数据库默认的事务隔离级别。\n\n**Repeatable Read（可重复读）** ：一个事务内部，前后多次的查询结果保持一致。回到隔离性的定义：一个事务的操作不受其他事务的影响。可重复读要解决的就是这个问题。在内部实现上，不管是读已提交还是可重复读，都需要借助 Readview 和 Undo 来实现，只是开启 Readview 的时间点有区别。Readview 和 Undo 也是 MySQL 实现 MVCC 的基础，更多细节在后续的文章单独介绍。\n\n**Serializable（串行化）** ：所有的事务，按顺序执行，任意时刻最多只有一个事务在执行。串行化从本质上来说完全限制了并发，在真实环境中一般不会使用。\n\n### 总结\n\n这篇文章主要从事务入手，简单的介绍了事务的基本特性和实现逻辑，引入了数据库系统中几个非常重要的概念：Undo、Redo、Readview、MVCC。这些概念会在后续的文章中详细说明。\n\n","source":"_posts/transaction-intro.md","raw":"---\ntitle: 初识事务\ndate: 2020-07-13 23:03:15\ntags:\n- 事务\ncategories: \n- 数据库\n---\n\n提到数据库，相信很多人第一个想到的就是事务，今天就从事务开始，对数据库的基本特征以及背后的实现逻辑进行一个简单的说明。\n\n<!-- more -->\n\n## 事务\n\n在写这篇文章的时候，笔者特意又重新查了下事务的定义。维基百科中关于事务的定义是：“事务是数据库系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成”。事务的概念本身并没有什么好展开的，事务之所以成为数据库系统最重要的特征之一，是因为事务的 ACID 属性。\n\n### ACID\n\n**Atomicity（原子性）** ：事务中的一组操作，要么全部成功，要么全部失败，不存在部分成功的情况。原子性的定义相对是比较直观的，可以类比编程语言中的原子操作，从这个角度上来说，事务是数据库系统处理用户操作的最小单位（自动提交模式可以看作是一条语句一个事务）。数据库系统内部主要通过 Undo（回滚日志、前进项）来保证原子性。每一个操作在执行时，都会记录下执行前的状态到 Undo 中，当事务需要回滚时，就可以通过 Undo 恢复到事务执行前的状态。\n\n**Consistency（一致性）** ：数据库总是从一个一致性状态转移到另一个一致性状态。一致性的定义比较模糊，什么叫从一个一致性状态转移到另一个一致性状态？其实这是由于中文的翻译往往只翻译了一半，关于一致性有一段非常最要的补充：\n\n```shell\nAny data written to the database must be valid according to all defined rules, \nincluding constraints, cascades, triggers, and any combination thereof. \n```\n\n总结起来就是：数据库在任意时刻的状态都必须符合所有的验证规则。一个简单的例子：表A记录了用户的账户余额，表B记录了用户的消费记录。从数据库的角度，A中的值与B中记录的和应该总是一个固定值，这就是一条验证规则。另外一个例子：表A存了用户信息，表B存了地址信息，表B中的地址被表A引用（外键），那么删除表B中的记录时，必须检查表A中的记录，这也是一条验证规则。关于一致性的判断，更多的需要与关系间的内在逻辑相结合。\n\n**Isolation（隔离性）** ：不同事务间的操作是相互隔离的，一个事务的操作不受其他事务的影响，也不会影响其他事务。关于隔离性，不同的数据库有不同的实现逻辑，按照可见性进行划分，可以分为四种不同的隔离级别。关于隔离级别，下个部分会进行详细介绍。\n\n**Durability（持久性）** ：一个事务只要提交成功就必须完整保存，不管发生任何软件或者硬件故障都必须保证数据不会丢失。持久性可以说是数据库系统的基础，在真实的业务场景中，数据丢失也往往是最无法容忍的。数据库系统主要通过 Redo（重做日志、后进项）来保证持久性。Redo 是一种典型的 WAL，每一个操作在执行时，都会记录这个操作的内容，并持久化到 Redo 中。当系统恢复时，如果发现之前的操作没有生效，可以通过 Redo 进行重做，保证已提交的操作有效。\n\n### 事务隔离级别\n\n前面提到，按照可见性进行划分，隔离性可以分为四种不同的事务隔离级别，下面逐一进行说明。\n\n**Read Uncommit（读未提交）** ：一个事务的修改可以立即被其它事务读取。读未提交的问题是会出现脏读，举例来说：事务1修改表A的数据，未提交，此时事务2读到了修改项，随后事务1进行了回滚。读未提交是最弱的一种隔离级别，在生产环境中，基本上不会使用。\n\n**Read Committed（读已提交）** ：一个事务的修改在事务提交后可以立即被其它事务读取到。读已提交避免了脏读的问题，这也是当前主流的数据库默认的事务隔离级别。\n\n**Repeatable Read（可重复读）** ：一个事务内部，前后多次的查询结果保持一致。回到隔离性的定义：一个事务的操作不受其他事务的影响。可重复读要解决的就是这个问题。在内部实现上，不管是读已提交还是可重复读，都需要借助 Readview 和 Undo 来实现，只是开启 Readview 的时间点有区别。Readview 和 Undo 也是 MySQL 实现 MVCC 的基础，更多细节在后续的文章单独介绍。\n\n**Serializable（串行化）** ：所有的事务，按顺序执行，任意时刻最多只有一个事务在执行。串行化从本质上来说完全限制了并发，在真实环境中一般不会使用。\n\n### 总结\n\n这篇文章主要从事务入手，简单的介绍了事务的基本特性和实现逻辑，引入了数据库系统中几个非常重要的概念：Undo、Redo、Readview、MVCC。这些概念会在后续的文章中详细说明。\n\n","slug":"transaction-intro","published":1,"updated":"2020-07-17T14:46:50.902Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgluc72r000yowgm8v751cp2","content":"<p>提到数据库，相信很多人第一个想到的就是事务，今天就从事务开始，对数据库的基本特征以及背后的实现逻辑进行一个简单的说明。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>在写这篇文章的时候，笔者特意又重新查了下事务的定义。维基百科中关于事务的定义是：“事务是数据库系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成”。事务的概念本身并没有什么好展开的，事务之所以成为数据库系统最重要的特征之一，是因为事务的 ACID 属性。</p>\n<h3 id=\"ACID\"><a href=\"#ACID\" class=\"headerlink\" title=\"ACID\"></a>ACID</h3><p><strong>Atomicity（原子性）</strong> ：事务中的一组操作，要么全部成功，要么全部失败，不存在部分成功的情况。原子性的定义相对是比较直观的，可以类比编程语言中的原子操作，从这个角度上来说，事务是数据库系统处理用户操作的最小单位（自动提交模式可以看作是一条语句一个事务）。数据库系统内部主要通过 Undo（回滚日志、前进项）来保证原子性。每一个操作在执行时，都会记录下执行前的状态到 Undo 中，当事务需要回滚时，就可以通过 Undo 恢复到事务执行前的状态。</p>\n<p><strong>Consistency（一致性）</strong> ：数据库总是从一个一致性状态转移到另一个一致性状态。一致性的定义比较模糊，什么叫从一个一致性状态转移到另一个一致性状态？其实这是由于中文的翻译往往只翻译了一半，关于一致性有一段非常最要的补充：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Any data written to the database must be valid according to all defined rules, </span><br><span class=\"line\">including constraints, cascades, triggers, and any combination thereof.</span><br></pre></td></tr></table></figure>\n\n<p>总结起来就是：数据库在任意时刻的状态都必须符合所有的验证规则。一个简单的例子：表A记录了用户的账户余额，表B记录了用户的消费记录。从数据库的角度，A中的值与B中记录的和应该总是一个固定值，这就是一条验证规则。另外一个例子：表A存了用户信息，表B存了地址信息，表B中的地址被表A引用（外键），那么删除表B中的记录时，必须检查表A中的记录，这也是一条验证规则。关于一致性的判断，更多的需要与关系间的内在逻辑相结合。</p>\n<p><strong>Isolation（隔离性）</strong> ：不同事务间的操作是相互隔离的，一个事务的操作不受其他事务的影响，也不会影响其他事务。关于隔离性，不同的数据库有不同的实现逻辑，按照可见性进行划分，可以分为四种不同的隔离级别。关于隔离级别，下个部分会进行详细介绍。</p>\n<p><strong>Durability（持久性）</strong> ：一个事务只要提交成功就必须完整保存，不管发生任何软件或者硬件故障都必须保证数据不会丢失。持久性可以说是数据库系统的基础，在真实的业务场景中，数据丢失也往往是最无法容忍的。数据库系统主要通过 Redo（重做日志、后进项）来保证持久性。Redo 是一种典型的 WAL，每一个操作在执行时，都会记录这个操作的内容，并持久化到 Redo 中。当系统恢复时，如果发现之前的操作没有生效，可以通过 Redo 进行重做，保证已提交的操作有效。</p>\n<h3 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h3><p>前面提到，按照可见性进行划分，隔离性可以分为四种不同的事务隔离级别，下面逐一进行说明。</p>\n<p><strong>Read Uncommit（读未提交）</strong> ：一个事务的修改可以立即被其它事务读取。读未提交的问题是会出现脏读，举例来说：事务1修改表A的数据，未提交，此时事务2读到了修改项，随后事务1进行了回滚。读未提交是最弱的一种隔离级别，在生产环境中，基本上不会使用。</p>\n<p><strong>Read Committed（读已提交）</strong> ：一个事务的修改在事务提交后可以立即被其它事务读取到。读已提交避免了脏读的问题，这也是当前主流的数据库默认的事务隔离级别。</p>\n<p><strong>Repeatable Read（可重复读）</strong> ：一个事务内部，前后多次的查询结果保持一致。回到隔离性的定义：一个事务的操作不受其他事务的影响。可重复读要解决的就是这个问题。在内部实现上，不管是读已提交还是可重复读，都需要借助 Readview 和 Undo 来实现，只是开启 Readview 的时间点有区别。Readview 和 Undo 也是 MySQL 实现 MVCC 的基础，更多细节在后续的文章单独介绍。</p>\n<p><strong>Serializable（串行化）</strong> ：所有的事务，按顺序执行，任意时刻最多只有一个事务在执行。串行化从本质上来说完全限制了并发，在真实环境中一般不会使用。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这篇文章主要从事务入手，简单的介绍了事务的基本特性和实现逻辑，引入了数据库系统中几个非常重要的概念：Undo、Redo、Readview、MVCC。这些概念会在后续的文章中详细说明。</p>\n","site":{"data":{}},"excerpt":"<p>提到数据库，相信很多人第一个想到的就是事务，今天就从事务开始，对数据库的基本特征以及背后的实现逻辑进行一个简单的说明。</p>","more":"<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>在写这篇文章的时候，笔者特意又重新查了下事务的定义。维基百科中关于事务的定义是：“事务是数据库系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成”。事务的概念本身并没有什么好展开的，事务之所以成为数据库系统最重要的特征之一，是因为事务的 ACID 属性。</p>\n<h3 id=\"ACID\"><a href=\"#ACID\" class=\"headerlink\" title=\"ACID\"></a>ACID</h3><p><strong>Atomicity（原子性）</strong> ：事务中的一组操作，要么全部成功，要么全部失败，不存在部分成功的情况。原子性的定义相对是比较直观的，可以类比编程语言中的原子操作，从这个角度上来说，事务是数据库系统处理用户操作的最小单位（自动提交模式可以看作是一条语句一个事务）。数据库系统内部主要通过 Undo（回滚日志、前进项）来保证原子性。每一个操作在执行时，都会记录下执行前的状态到 Undo 中，当事务需要回滚时，就可以通过 Undo 恢复到事务执行前的状态。</p>\n<p><strong>Consistency（一致性）</strong> ：数据库总是从一个一致性状态转移到另一个一致性状态。一致性的定义比较模糊，什么叫从一个一致性状态转移到另一个一致性状态？其实这是由于中文的翻译往往只翻译了一半，关于一致性有一段非常最要的补充：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Any data written to the database must be valid according to all defined rules, </span><br><span class=\"line\">including constraints, cascades, triggers, and any combination thereof.</span><br></pre></td></tr></table></figure>\n\n<p>总结起来就是：数据库在任意时刻的状态都必须符合所有的验证规则。一个简单的例子：表A记录了用户的账户余额，表B记录了用户的消费记录。从数据库的角度，A中的值与B中记录的和应该总是一个固定值，这就是一条验证规则。另外一个例子：表A存了用户信息，表B存了地址信息，表B中的地址被表A引用（外键），那么删除表B中的记录时，必须检查表A中的记录，这也是一条验证规则。关于一致性的判断，更多的需要与关系间的内在逻辑相结合。</p>\n<p><strong>Isolation（隔离性）</strong> ：不同事务间的操作是相互隔离的，一个事务的操作不受其他事务的影响，也不会影响其他事务。关于隔离性，不同的数据库有不同的实现逻辑，按照可见性进行划分，可以分为四种不同的隔离级别。关于隔离级别，下个部分会进行详细介绍。</p>\n<p><strong>Durability（持久性）</strong> ：一个事务只要提交成功就必须完整保存，不管发生任何软件或者硬件故障都必须保证数据不会丢失。持久性可以说是数据库系统的基础，在真实的业务场景中，数据丢失也往往是最无法容忍的。数据库系统主要通过 Redo（重做日志、后进项）来保证持久性。Redo 是一种典型的 WAL，每一个操作在执行时，都会记录这个操作的内容，并持久化到 Redo 中。当系统恢复时，如果发现之前的操作没有生效，可以通过 Redo 进行重做，保证已提交的操作有效。</p>\n<h3 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h3><p>前面提到，按照可见性进行划分，隔离性可以分为四种不同的事务隔离级别，下面逐一进行说明。</p>\n<p><strong>Read Uncommit（读未提交）</strong> ：一个事务的修改可以立即被其它事务读取。读未提交的问题是会出现脏读，举例来说：事务1修改表A的数据，未提交，此时事务2读到了修改项，随后事务1进行了回滚。读未提交是最弱的一种隔离级别，在生产环境中，基本上不会使用。</p>\n<p><strong>Read Committed（读已提交）</strong> ：一个事务的修改在事务提交后可以立即被其它事务读取到。读已提交避免了脏读的问题，这也是当前主流的数据库默认的事务隔离级别。</p>\n<p><strong>Repeatable Read（可重复读）</strong> ：一个事务内部，前后多次的查询结果保持一致。回到隔离性的定义：一个事务的操作不受其他事务的影响。可重复读要解决的就是这个问题。在内部实现上，不管是读已提交还是可重复读，都需要借助 Readview 和 Undo 来实现，只是开启 Readview 的时间点有区别。Readview 和 Undo 也是 MySQL 实现 MVCC 的基础，更多细节在后续的文章单独介绍。</p>\n<p><strong>Serializable（串行化）</strong> ：所有的事务，按顺序执行，任意时刻最多只有一个事务在执行。串行化从本质上来说完全限制了并发，在真实环境中一般不会使用。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这篇文章主要从事务入手，简单的介绍了事务的基本特性和实现逻辑，引入了数据库系统中几个非常重要的概念：Undo、Redo、Readview、MVCC。这些概念会在后续的文章中详细说明。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckgluc7210000owgmat85e1k9","category_id":"ckgluc7290004owgm10zbes9o","_id":"ckgluc72h000fowgmarxe0mdb"},{"post_id":"ckgluc7270002owgm472l8hpr","category_id":"ckgluc72e000aowgmb5y3bd68","_id":"ckgluc72m000mowgmghppcs5q"},{"post_id":"ckgluc72j000iowgm2lhb3ghj","category_id":"ckgluc7290004owgm10zbes9o","_id":"ckgluc72p000rowgmhn768t0m"},{"post_id":"ckgluc72b0006owgmctnb4hyo","category_id":"ckgluc72e000aowgmb5y3bd68","_id":"ckgluc72r000wowgm0vgr584x"},{"post_id":"ckgluc72l000kowgm90ejea7q","category_id":"ckgluc7290004owgm10zbes9o","_id":"ckgluc72r000zowgmfx0nacvu"},{"post_id":"ckgluc72n000oowgm31bk5puk","category_id":"ckgluc7290004owgm10zbes9o","_id":"ckgluc72s0013owgm0zh1db58"},{"post_id":"ckgluc72d0008owgm09z80ehy","category_id":"ckgluc72m000lowgmbyuv7c0g","_id":"ckgluc72t0015owgmh1hsdd8v"},{"post_id":"ckgluc72o000qowgm3gz4de4a","category_id":"ckgluc72m000lowgmbyuv7c0g","_id":"ckgluc72t0018owgmd63bek3t"},{"post_id":"ckgluc72q000vowgm5kgo4jbm","category_id":"ckgluc72m000lowgmbyuv7c0g","_id":"ckgluc72u001aowgmgv89h53k"},{"post_id":"ckgluc72e0009owgm9cls1gn2","category_id":"ckgluc72m000lowgmbyuv7c0g","_id":"ckgluc72u001cowgm6glo5xtn"},{"post_id":"ckgluc72r000yowgm8v751cp2","category_id":"ckgluc72m000lowgmbyuv7c0g","_id":"ckgluc72u001eowgm5d8pa0lj"},{"post_id":"ckgluc72g000dowgm28fi419i","category_id":"ckgluc72m000lowgmbyuv7c0g","_id":"ckgluc72u001fowgmajdh43g7"}],"PostTag":[{"post_id":"ckgluc7210000owgmat85e1k9","tag_id":"ckgluc72b0005owgmejn7dreq","_id":"ckgluc72f000cowgmedq47t7t"},{"post_id":"ckgluc7270002owgm472l8hpr","tag_id":"ckgluc72f000bowgmd6612c1r","_id":"ckgluc72k000jowgman35cbh2"},{"post_id":"ckgluc72b0006owgmctnb4hyo","tag_id":"ckgluc72f000bowgmd6612c1r","_id":"ckgluc72o000powgmbwb36ffq"},{"post_id":"ckgluc72l000kowgm90ejea7q","tag_id":"ckgluc72b0005owgmejn7dreq","_id":"ckgluc72p000sowgmh9eubgzp"},{"post_id":"ckgluc72n000oowgm31bk5puk","tag_id":"ckgluc72b0005owgmejn7dreq","_id":"ckgluc72r000xowgm8itg1bza"},{"post_id":"ckgluc72d0008owgm09z80ehy","tag_id":"ckgluc72f000bowgmd6612c1r","_id":"ckgluc72s0010owgm5we6gp3d"},{"post_id":"ckgluc72o000qowgm3gz4de4a","tag_id":"ckgluc72f000bowgmd6612c1r","_id":"ckgluc72t0014owgmd0ke2340"},{"post_id":"ckgluc72q000vowgm5kgo4jbm","tag_id":"ckgluc72f000bowgmd6612c1r","_id":"ckgluc72t0016owgmbot65cvc"},{"post_id":"ckgluc72e0009owgm9cls1gn2","tag_id":"ckgluc72p000towgmgbze7s1f","_id":"ckgluc72t0019owgmdy5j7g9e"},{"post_id":"ckgluc72g000dowgm28fi419i","tag_id":"ckgluc72p000towgmgbze7s1f","_id":"ckgluc72u001bowgmcu0n9v34"},{"post_id":"ckgluc72r000yowgm8v751cp2","tag_id":"ckgluc72t0017owgmdupuaeex","_id":"ckgluc72u001dowgmfae97ug1"}],"Tag":[{"name":"Linux","_id":"ckgluc72b0005owgmejn7dreq"},{"name":"MySQL","_id":"ckgluc72f000bowgmd6612c1r"},{"name":"InnoDB","_id":"ckgluc72p000towgmgbze7s1f"},{"name":"事务","_id":"ckgluc72t0017owgmdupuaeex"}]}}